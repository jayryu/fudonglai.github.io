---
title: 我是这样思考的
date: 2019-01-26 22:12:30
tags:
	- Other
	- Array
categories:
	- Algorithm
---

今天写两道题的思考过程吧，算法嘛，就不要像高中生那样死记硬背解法了，我个人认为，一方面不断积累见过的问题类型，另一方面要敢于天马行空地思考，说不定就“灵机一动”突破了固有的人类思维，获得了 logn 的黑魔法呢？

<!--more-->

**第一道题**，判断一个序列中是否有递增的三个数，他们三个不一定紧挨着，比如说 [1,4,2,0,3] 中就有 1, 2, 3 符合条件，返回 true ，而 [1,4,3,0,2] 就不存在这样的三个元素，返回 false 。长度为 n 的数组 a 中是否存在 0 <= i < j < k < n 使得 a[i] < a[j] < a[k] 。

首先请以常规思维思考出一个解决方案。不要看不起常规的低效方案，找到常规思路低效的原因再优化，是空手遍算法的必经之路。显然，套三个 for 循环是可以解决的。低效一定是由于操作冗余造成，哪里冗余？内层 for 循环走过的路，外层的还得再判断一次，冗余。

看到一个问题，要想方设法和以前见过的问题联系起来。比如说我第一个想到的就是：如何寻找序列中最大的三个元素？最优答案是用优先级队列或者把快速排序改造成快速选择（具体算法不重要，重要的是思考的过程），时间复杂度都在 N 倍 log3 ，但是既然能通过一次线性扫描找到最大值，能不能一次扫描就找到最大的三个呢？不行，不行的原因是一次扫描中，找到最大值之前可能跳过了第二大的值。

这里似乎也可以求下最大的几个值试试能不能解决？但是就算求出最大的三个值，还要考虑相对位置，有巨量的细节问题需要解决。聪明的人要学会偷懒，这个解法我估计无法完成，还不如套三个 for 循环。

我第二个想到的问题是，求数组中的三个数字，他们的和等于给定的目标值。一般人的思路就是暴力试，显然需要三个嵌套 for 循环，复杂度 N 三次方。记住，复杂度大于等于 N 平方的时候，第一时间想一下是否能把原数据排个序再尝试解决。一般不轻易排序，因为排序开销相对大，但是复杂度都平方了，排个序就不过分了，而且一旦有序，就要条件反射想到二分搜索。这个问题的思路是先排个序，然后用双指针技巧进行操作，复杂度降到了 N 平方。

这里能不能先排个序试下？不行，这里相对位置是算法考察的重要标准，必然不可能排序。

好了，我想了十分钟，想不出更多联系了。赶紧看答案吧，不要跟我说只有自己想出来才是自己的，才不会忘。我认为要站在巨人的肩膀上，思考和模仿，至于怎么内化成自己的，只有不断动手，尝试，联系才行，和怎么学会的无关。模仿了不思考，那是站在巨人的裤裆里。

```cpp
bool increasingTriplet(vector<int>& nums) {
        int min = INT_MAX, mid = INT_MAX;
        for (int n : nums) {
            if      (n <= min) { min = n; } 
            else if (n <= mid) { mid = n; } 
            else 			   { return true; }
        }
        return false;
    }
```

我明白了一个道理，if 条件判断不只是分支判断，而且是个过滤器，我记住了。



**第二题**，给一个长度为 n 的数组，其中有一个数字出现的次数大于 n / 2，请找出这个数字。比如 [1,2,3,2,2]，这个元素就是 2 。

关键在于，如何最大限度利用信息。根据香农大佬的理论，信息可以消除不确定性，对于算法来说，充分利用信息必然可以提高算法的效率。

这道题当然可以用一个字典记录各个不同元素出现的次数，但是你应该这样想：如果目标元素出现的次数不是大于总数的一半，这种方法一样可以解决，所以说这个方法是泛化的，没有利用这个题目的特殊性。不必说，不是最优的，浪费了空间。

既然知道目标元素出现的次数是大于元素总数的一半的，那么就要想如何利用这个信息，回忆一下相似的问题解法。

用异或运算？不行，异或技巧无非就是利用同一个数字同时出现偶数次异或结果为零这个性质，这题虽然跟出现次数有关，但是没有特殊的奇偶性特征，所以此处不适合。

既然有“半”这个字眼，是不是可以用二分思想？不行，二分什么时候用？数组有序的时候第一时间想二分，原问题可以划分为子问题时第一时间想借助递归来二分，但这里显然不行。

用双指针技巧，就像上面那道题，通过多指针划分区间，求解？不行，用多指针技巧起码你得有个直觉，就是需要多少个指针，比如链表问题就可以造 n 个指针指向 n 个链表头，上面那道题可以用两个指针固定两个分界线，划分出三个递增区间。而这里，似乎没有什么线索可以使用多指针技巧。

再回头想想，数量是大于二分之一的，这有什么特殊性？这样想，如果不是二分之一，而是三分之一，题目会失去什么特殊性呢？“过半”有什么特性，想想这个词似乎在生活中很常见呢，比如某项决议，需要同意人数过半才能通过，区块链算法需要节点过半才信任该区块等等。这里我又想到一句古语：“以正和，以奇胜”。这个“奇”字是多音，奇数的那个音。意思是打仗要靠人多，小于等于敌方兵力的那部分就中和了，要靠多出来的那部分取胜。

也就是说，现在有 n 个国家打仗，而有一个国家兵力比其他所有国家兵力加起来都要多，结果就是，其他所有国家联手，根据古语，仍然无法战胜该国。这就是特殊性，这就是“过半”所带来的必然性。算法应该从这方面着手优化。

```cpp
int majorityElement(vector<int>& nums) {
    int majority = nums[0], count = 1;
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] == majority) { count++; } 
        else if (count == 0) 	 { majority = nums[i]; } 
        else 					 { count--; }
    }
    return majority;
}
```

