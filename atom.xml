<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿东的算法笔记</title>
  
  <subtitle>Down to earth. &lt;br&gt;Being towards death.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fudonglai.github.io/"/>
  <updated>2019-01-27T05:57:19.672Z</updated>
  <id>https://fudonglai.github.io/</id>
  
  <author>
    <name>付东来</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>何为优质？</title>
    <link href="https://fudonglai.github.io/2019/01/27/SuperiorQuality/"/>
    <id>https://fudonglai.github.io/2019/01/27/SuperiorQuality/</id>
    <published>2019-01-27T05:55:51.000Z</published>
    <updated>2019-01-27T05:57:19.672Z</updated>
    
    <content type="html"><![CDATA[<p>一直在学习薛兆丰老师的经济学专栏，发现经济学的思维真是眼光独到，感觉不写点感悟分享出来真是一种浪费。</p><p>优质来自比较，世界上存在优质产品和低质产品，问题是如何区分它们。从经济学观点看，什么叫优质产品？</p><a id="more"></a><p>一、品质稳定。</p><p>我认为包括空间和时间上的稳定。比如说，星巴克在美国的营业点和中国的营业点，提供的饮品口味都是一致的；而且饮品几年前的口味和现在的口味是差不多的。匀质是优质的必要条件，如果说星巴克在全球各地的产品品质差异很大，怎么可能享誉世界。厂家整齐划一的质量管理，就能从侧面反应厂家在质量上下的功夫，一个产品能保持质量稳定很多年是一件难得的事。就说我们个人，也没有哪件事是坚持了多年保质保量完成的吧。</p><p>二、性价比相当</p><p>这一点似乎很多人都明白，但是我们一般人所说的性价比，都是“横向”的性价比，比如说有人会认为小米手机性价比比苹果手机高之类，这种性价比属于不同产品之间的横向比较。而我想说的是同一个产品“纵向的”性价比，比如说新出的双卡双待 iPhone ，用户购买“双卡双待”这个新功能所付出的成本如果大于使用这个功能的收益，那么性价比就低，反之就高。至于这个功能的性价比我没用过不清楚，不过根据别人的评价，iPhone 双卡双待这个功能的性价比似乎是较低的。</p><p>说的通俗一点，不是质量越高越好，也不是价格越低越好，而是一分价钱一分货，对用户有用才是最好的。专业一点，就是在提高质量的过程中，边际收益等于边际成本时应该停止继续提高了，否则成本大于收益，性价比就会下降，而多出的这些成本，实际上都是消费者来买单。</p><p>其实很多社会事件也可以用经济学眼光看待，是么叫性价比相当？</p><p>再举专栏里的一个例子：几年前一个乡村的一辆校车发生意外，造成严重伤亡，结果社会各界人士就站出来说应该制定校车的安全标准。有律师参加制定这样的标准，但是最终没有制定出来，为什么呢？因为凭空写出来的标准，跟坦克车差不多了，如果要求不够高，出了事就是写标准的人的失职，而太高了的结果就是，学校和家长要承担高额的费用，实际上大家都买不起这样的校车。</p><p>一般人可能会说，那政府强制学校和家长购买这样的校车不就行了？这就是典型的缺乏经济学思维的想法，用经济学的眼光可以看到看不到的东西，你以为强制实施真的就实施了吗？学校和家长一定会有相应的对策，包括采用成本更低但安全性也更低的交通方式，比如骑自行车。</p><p>总结一下，我们做事应该算算边际成本和边际收益，盲目地提高质量也是一种错误。</p><p>发表一点感想：经济学是一种独特思维方式，让我们看到看不见的东西。我列举几个自认为很有趣的例子：</p><ol><li>小偷为什么会对社会有害呢？应为小偷只是对财富进行转移，并没有减少社会的财富总量啊？经济学告诉我们，小偷确实没有减少社会财富，但是增加了社会造锁的成本。</li><li>春节车票凭什么涨价，就不能强制压低价格吗？经济学告诉我们，涨价市场价格的自然调节，不应该强制干预，如果真的强制干预可能适得其反，比如说春运期间价格压下来，那么对于铁路公司，这部分收入的减少必然需要弥补，那么平时的车票就会涨价；价格上涨反应的是需求的增加，如果强压住价格这个尺度，那么就会引发其他尺度的竞争，甚至黑幕交易，这显然是不希望看到的。</li></ol><p>还有很多例子，以后有时间都写写感悟分享出来，经济学思维能跳出固有的思维模式，客观的看待问题，起码不会活在理想的世界里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直在学习薛兆丰老师的经济学专栏，发现经济学的思维真是眼光独到，感觉不写点感悟分享出来真是一种浪费。&lt;/p&gt;
&lt;p&gt;优质来自比较，世界上存在优质产品和低质产品，问题是如何区分它们。从经济学观点看，什么叫优质产品？&lt;/p&gt;
    
    </summary>
    
      <category term="经济学思维" scheme="https://fudonglai.github.io/categories/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%80%9D%E7%BB%B4/"/>
    
    
      <category term="other" scheme="https://fudonglai.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>我是这样思考的</title>
    <link href="https://fudonglai.github.io/2019/01/26/HowToThink/"/>
    <id>https://fudonglai.github.io/2019/01/26/HowToThink/</id>
    <published>2019-01-26T14:12:30.000Z</published>
    <updated>2019-01-26T14:14:45.308Z</updated>
    
    <content type="html"><![CDATA[<p>今天写两道题的思考过程吧，算法嘛，就不要像高中生那样死记硬背解法了，我个人认为，一方面不断积累见过的问题类型，另一方面要敢于天马行空地思考，说不定就“灵机一动”突破了固有的人类思维，获得了 logn 的黑魔法呢？</p><a id="more"></a><p><strong>第一道题</strong>，判断一个序列中是否有递增的三个数，他们三个不一定紧挨着，比如说 [1,4,2,0,3] 中就有 1, 2, 3 符合条件，返回 true ，而 [1,4,3,0,2] 就不存在这样的三个元素，返回 false 。长度为 n 的数组 a 中是否存在 0 &lt;= i &lt; j &lt; k &lt; n 使得 a[i] &lt; a[j] &lt; a[k] 。</p><p>首先请以常规思维思考出一个解决方案。不要看不起常规的低效方案，找到常规思路低效的原因再优化，是空手遍算法的必经之路。显然，套三个 for 循环是可以解决的。低效一定是由于操作冗余造成，哪里冗余？内层 for 循环走过的路，外层的还得再判断一次，冗余。</p><p>看到一个问题，要想方设法和以前见过的问题联系起来。比如说我第一个想到的就是：如何寻找序列中最大的三个元素？最优答案是用优先级队列或者把快速排序改造成快速选择（具体算法不重要，重要的是思考的过程），时间复杂度都在 N 倍 log3 ，但是既然能通过一次线性扫描找到最大值，能不能一次扫描就找到最大的三个呢？不行，不行的原因是一次扫描中，找到最大值之前可能跳过了第二大的值。</p><p>这里似乎也可以求下最大的几个值试试能不能解决？但是就算求出最大的三个值，还要考虑相对位置，有巨量的细节问题需要解决。聪明的人要学会偷懒，这个解法我估计无法完成，还不如套三个 for 循环。</p><p>我第二个想到的问题是，求数组中的三个数字，他们的和等于给定的目标值。一般人的思路就是暴力试，显然需要三个嵌套 for 循环，复杂度 N 三次方。记住，复杂度大于等于 N 平方的时候，第一时间想一下是否能把原数据排个序再尝试解决。一般不轻易排序，因为排序开销相对大，但是复杂度都平方了，排个序就不过分了，而且一旦有序，就要条件反射想到二分搜索。这个问题的思路是先排个序，然后用双指针技巧进行操作，复杂度降到了 N 平方。</p><p>这里能不能先排个序试下？不行，这里相对位置是算法考察的重要标准，必然不可能排序。</p><p>好了，我想了十分钟，想不出更多联系了。赶紧看答案吧，不要跟我说只有自己想出来才是自己的，才不会忘。我认为要站在巨人的肩膀上，思考和模仿，至于怎么内化成自己的，只有不断动手，尝试，联系才行，和怎么学会的无关。模仿了不思考，那是站在巨人的裤裆里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">increasingTriplet</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX, mid = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>      (n &lt;= min) &#123; min = n; &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= mid) &#123; mid = n; &#125; </span><br><span class="line">            <span class="keyword">else</span>    &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我明白了一个道理，if 条件判断不只是分支判断，而且是个过滤器，我记住了。</p><p><strong>第二题</strong>，给一个长度为 n 的数组，其中有一个数字出现的次数大于 n / 2，请找出这个数字。比如 [1,2,3,2,2]，这个元素就是 2 。</p><p>关键在于，如何最大限度利用信息。根据香农大佬的理论，信息可以消除不确定性，对于算法来说，充分利用信息必然可以提高算法的效率。</p><p>这道题当然可以用一个字典记录各个不同元素出现的次数，但是你应该这样想：如果目标元素出现的次数不是大于总数的一半，这种方法一样可以解决，所以说这个方法是泛化的，没有利用这个题目的特殊性。不必说，不是最优的，浪费了空间。</p><p>既然知道目标元素出现的次数是大于元素总数的一半的，那么就要想如何利用这个信息，回忆一下相似的问题解法。</p><p>用异或运算？不行，异或技巧无非就是利用同一个数字同时出现偶数次异或结果为零这个性质，这题虽然跟出现次数有关，但是没有特殊的奇偶性特征，所以此处不适合。</p><p>既然有“半”这个字眼，是不是可以用二分思想？不行，二分什么时候用？数组有序的时候第一时间想二分，原问题可以划分为子问题时第一时间想借助递归来二分，但这里显然不行。</p><p>用双指针技巧，就像上面那道题，通过多指针划分区间，求解？不行，用多指针技巧起码你得有个直觉，就是需要多少个指针，比如链表问题就可以造 n 个指针指向 n 个链表头，上面那道题可以用两个指针固定两个分界线，划分出三个递增区间。而这里，似乎没有什么线索可以使用多指针技巧。</p><p>再回头想想，数量是大于二分之一的，这有什么特殊性？这样想，如果不是二分之一，而是三分之一，题目会失去什么特殊性呢？“过半”有什么特性，想想这个词似乎在生活中很常见呢，比如某项决议，需要同意人数过半才能通过，区块链算法需要节点过半才信任该区块等等。这里我又想到一句古语：“以正和，以奇胜”。这个“奇”字是多音，奇数的那个音。意思是打仗要靠人多，小于等于敌方兵力的那部分就中和了，要靠多出来的那部分取胜。</p><p>也就是说，现在有 n 个国家打仗，而有一个国家兵力比其他所有国家兵力加起来都要多，结果就是，其他所有国家联手，根据古语，仍然无法战胜该国。这就是特殊性，这就是“过半”所带来的必然性。算法应该从这方面着手优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> majority = nums[<span class="number">0</span>], count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == majority) &#123; count++; &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">0</span>)  &#123; majority = nums[i]; &#125; </span><br><span class="line">        <span class="keyword">else</span>  &#123; count--; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天写两道题的思考过程吧，算法嘛，就不要像高中生那样死记硬背解法了，我个人认为，一方面不断积累见过的问题类型，另一方面要敢于天马行空地思考，说不定就“灵机一动”突破了固有的人类思维，获得了 logn 的黑魔法呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Array" scheme="https://fudonglai.github.io/tags/Array/"/>
    
      <category term="Other" scheme="https://fudonglai.github.io/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>二分搜索详解</title>
    <link href="https://fudonglai.github.io/2019/01/21/BinarySearch/"/>
    <id>https://fudonglai.github.io/2019/01/21/BinarySearch/</id>
    <published>2019-01-21T08:14:29.000Z</published>
    <updated>2019-01-21T08:22:08.207Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找，学过一点点算法的人都会，但是很简单的查找算法变体非常广泛，并且非常不容易写正确，不信你就试试？几个月前在 LeetCode 看二分搜索的时候就有点云里雾里，道理我都懂，怎么就是写不对？？现在再回头做以前的题，好像有点开窍了，赶紧记录下来。</p><a id="more"></a><p><strong>PS：Template II 是最核心的结论。</strong></p><p>首先，二分搜索不是只能简简单单的在一堆有序数列中找一个元素，再设计算法时，只要看到有序序列，第一就要想到 Binary Search，这是最高效的算法，<strong>具体操作区别在于”二分“判断的部分</strong>。总体来说，二分查找的框架是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums，<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, <span class="keyword">int</span> hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>; <span class="comment">//防止溢出而已</span></span><br><span class="line">        <span class="keyword">if</span> (左半边可以排除)</span><br><span class="line">            调整 lo;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            调整 hi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo 或 hi 或 <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个简单的框架有四个地方可以自由设计：</p><ol><li><code>hi</code>的取值，可以取为<code>nums.size() - 1</code>，也可能是<code>nums.size()</code>，看具体用哪一个代码模板了（下文讲到）。</li><li>如果使用不同模板，<code>while</code>条件的判断也不同，取决于上一条。</li><li>mid 的计算，我们知道计算机除法是向下取整，所以这个 mid 并不一定是严谨的正中间，有可能会偏差，但这个偏差一定是偏左。注意到这一点会帮助我们在模板二的调整操作。</li><li>如何调整<code>lo</code>和<code>hi</code>，到底等于<code>mid</code>还是<code>mid+１</code>还是<code>mid-1</code>？这个取决于上一点，还取决于我们要搜索 target 的左侧边界还是右侧边界。你要问 target 不就是一个数吗，为什么还有左侧右侧边界？应为这个序列不一定是没有重复数字的，假设序列 <code>[1,2,3,3,4]</code>，让你查找 3 的区间，你是是不是得查找左侧边界和右侧边界？</li></ol><h1 id="Template-I"><a href="#Template-I" class="headerlink" title="Template I"></a>Template I</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// found target</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简陋的二分查找函数，只能查找单个元素，我还没想到什么适合它的变体。而且它的结果是”随机“的，就是说遇到有 target 值重复的情况，根据初始 lo 和 hi 的值的不同，返回的 target 索引可能是不同的。</p><p>话说为什么会这样？因为有一个条件判断了<code>nums[min] == target</code>的情况，这就是说只要找到了就 return，自然无法找到重复 target 的边界了。我个人不喜欢这样的搜索，有点”硬编码“的味道，我还是喜欢不用 <code>==</code>判断，让算法自然收敛到左侧或者右侧，后面的模板都按自然收敛的风格设计。</p><p>这样有啥好处呢？平均复杂度确实低一些，比如说有可能第一次循环就恰好落到 target 值了，那就直接结束了。而自然收敛的算法复杂度是稳定的 O(lgn)。不过，lgn 你懂得，顶级黑魔法了，根本不在乎多搜索这几下嘛。</p><h1 id="Template-II"><a href="#Template-II" class="headerlink" title="Template II"></a>Template II</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            hi = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[lo] == target ? lo : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找的高级模式，注意区别，把每轮循环对<code>hi</code>的更新修改了，把等号和大于号合并了，并在开头添加了判断。</p><p>这里的精髓有两个：</p><ol><li>到底是<code>&gt;=</code>还是<code>&lt;=</code>？</li><li>到底是<code>lo = mid + 1</code>还是<code>hi = mid - 1</code>还是<code>lo</code>和<code>hi</code>都等于<code>mid</code>？</li></ol><p><strong>解决第一个问题的关键是判断 <code>nums[mid]</code> 恰好撞上 <code>target</code> 的情况，来决定带不带等号。</strong>我发现必须是 hi = mid 那个判断带等号，这是这个框架决定的，应为除法自然向下取整，恰好撞上 target 时必须是 hi = mid，否则如果是 lo = mid + 1 的话会跳过这个 mid，也就是跳过了 target，跳过了正确结果，必然是错误的。</p><p><strong>解决第二个问题的关键是思考算法结束的最后一步，已经收缩到两个元素了，不妨假设在<code>[1,2]</code>中搜索 2</strong>，计算mid 时结果不可避免地偏左，这就必须要求<code>lo</code>必须自加才能满足 while 的结束条件，否则就会陷入无限循环（模板三解决该问题就不需要自加，而是直接更改了 while 的条件）。</p><p>在解决问题的同时我发现这个算法结果是左侧边界，为什么，是因为除法自然左偏的结果吗？不是！而是 if 条件判断中不等号中等号的位置来决定，当算法计算出<code>nums[mid] == target</code> 时，执行的更新<code>hi</code>的操作，就是说<code>hi</code>在向左收敛，最终收敛到左侧边界。</p><p>那我把等号给到小于判断上，是不是就可以收敛到右侧边界？不行！上面第一个问题就在解释，这是必须的，由除法向下取整的性质决定的，请仔细体会下。</p><p><strong>所以总结下，以上逻辑的因果链是：由于除法的向下取整性质，决定了必须是<code>lo = lo + 1</code>以避免无限循环，从而决定了等号必须给到大于号，否则算法会跳过正确答案而出错；因此此算法的结果是收敛到左侧边界的。</strong></p><p>那么我就是想让算法收敛到右侧怎么办？根据以上的因果链，关键在于除法的性质，如果让除法能向上取整就好说了。这个简单，这样写都可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (lo + hi + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>不一定要严谨的向上取整，因为算法会自然调整，只要避免无限循环就会收敛。向右取整决定了避免无限循环必须更新<code>hi = mid - 1</code>；更改<code>hi</code>就决定了等号需要给到更新<code>lo</code>的条件判断里，也就是必须<code>&lt;=</code>。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// int mid = lo + (hi - lo) / 2 + 1; Both OK</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            lo = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[hi] == target ? hi : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，到此，二分搜索的代码写起来已经不会有啥 bug 了，而且能够自由调整收敛方向，这个模板是我最常用的。下面再介绍一种模板吧，其实和这个差不多，一个原理，了解一下好了。</p><h1 id="Template-III"><a href="#Template-III" class="headerlink" title="Template III"></a>Template III</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) <span class="comment">//!!!</span></span><br><span class="line">                hi = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lo = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hi == nums.size())  <span class="keyword">return</span> nums[lo] == target ? lo : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[lo] == target) <span class="keyword">return</span> lo; <span class="comment">//!!!</span></span><br><span class="line">        <span class="keyword">if</span> (nums[hi] == target) <span class="keyword">return</span> hi; <span class="comment">//!!!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">higher_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) <span class="comment">//!!!</span></span><br><span class="line">                hi = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                lo = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hi == nums.size())  <span class="keyword">return</span> nums[lo] == target ? lo : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[hi] == target) <span class="keyword">return</span> hi; <span class="comment">//!!!</span></span><br><span class="line">        <span class="keyword">if</span> (nums[lo] == target) <span class="keyword">return</span> lo; <span class="comment">//!!!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个模板有它的特色，就是不用担心陷入无限循环，搜索左侧边界和右侧边界除了等号的区别外，还有个判断先后的问题需要注意，不过这些细节只要认真研究边界情况，都可解决。</p><h1 id="Easy-Problem"><a href="#Easy-Problem" class="headerlink" title="Easy Problem"></a>Easy Problem</h1><p>给一个数组，如何找到<code>peak element</code>的索引？比如 [1,2,3,4,3,2,1] 中 4 就是<code>peak element</code>，返回 4 的索引 3 。假设<code>nums[-1]</code>和<code>nums[nums.size()]</code>都是<code>-inf</code>。</p><p>这就是二分搜索的简单变体啊，只不过把 <code>nums[mid]</code> 和 target 的大小判断改成了<code>nums[mid]</code>处在”上坡“还是”下坡“的判断罢了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二分查找，学过一点点算法的人都会，但是很简单的查找算法变体非常广泛，并且非常不容易写正确，不信你就试试？几个月前在 LeetCode 看二分搜索的时候就有点云里雾里，道理我都懂，怎么就是写不对？？现在再回头做以前的题，好像有点开窍了，赶紧记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Search" scheme="https://fudonglai.github.io/tags/Search/"/>
    
      <category term="Array" scheme="https://fudonglai.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>感知机</title>
    <link href="https://fudonglai.github.io/2019/01/16/Perceptron/"/>
    <id>https://fudonglai.github.io/2019/01/16/Perceptron/</id>
    <published>2019-01-16T02:46:07.000Z</published>
    <updated>2019-01-16T04:19:14.676Z</updated>
    
    <content type="html"><![CDATA[<p>纸上得来终觉浅，绝知此事要躬行，只有亲自实现一个简单的感知机，遇到各种突发奇想的疑问然后尝试解决，才能真正掌握原理。<br><a id="more"></a></p><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><p>输入空间为 $\chi \in R^n$，输出空间 $\Upsilon \in {+1,-1}$，输入空间到输出空间映射的函数为<br>$$f(x) = sign(w \cdot x + b)$$</p><p>其中符号函数<br>$$ sign(x) =<br>\begin{cases}<br>+1, &amp; x&gt;=0 \<br>-1, &amp; x&lt;0 \<br>\end{cases} $$</p><p>只要数据集线性可分，就可以把所有实例点正确划分到超平面两侧，即对于 $y = +1$ 的点，$w \cdot x &gt; 0$，对于 $y = -1$ 的点，$w \cdot x &lt; 0$</p><h1 id="学习策略"><a href="#学习策略" class="headerlink" title="学习策略"></a>学习策略</h1><p>学习的目的就是最优化问题，就是最小化误分点个数，但是误分点个数显然是离散的，无法求导，所以感知机模型采取所有 <strong>误分点</strong> 到超平面的距离：<br>$$\frac{1}{||w||} |w \cdot x_i + b|$$</p><p>注意这个公式是初中就学过的点到直线的距离公式，把点坐标代入直线方程求绝对值然后放到分子，再把直线方程系数做平方和开根号放到分母。这个公式就是那个公式的通用版，适用于高维超平面而已。</p><p>那么如何才能找到误分点呢，仔细看下本段落标题上面那句话，知道了正确划分，自然就知道了错误划分的表现。同时注意符号，求解优化问题，我们都要改成求最小值问题。设集合 $M$ 是误分点集合，所有误分点到超平面总距离为</p><p>$$-\sum_{x_i \in M}\frac{1}{||w||} y_i (w \cdot x_i + b)$$</p><p>由此我们可以定义损失函数<br>$$L(w, b) = -\sum_{x_i \in M} y_i (w \cdot x_i + b)$$</p><p>求解最小化问题<br>$$\min_{w,b} L(w, b) = -\sum_{x_i \in M} y_i (w \cdot x_i + b)$$</p><p>按照梯度的方向下降就能减少误分点了<br>$$\nabla_w L(w, b) = -\sum_{x \in M} y_ix_i$$<br>$$\nabla_b L(w, b) = -\sum_{x \in M} y_i$$</p><p>每次对参数进行更新<br>$$w \leftarrow w + \eta y_i x_i$$<br>$$b \leftarrow b + \eta y_i$$</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n, l=<span class="number">0.001</span>)</span>:</span></span><br><span class="line">    <span class="string">""" n 为数据维度，l 为梯度步长 """</span></span><br><span class="line">        self.w = np.ones(n, dtype=np.float32)</span><br><span class="line">        self.b = <span class="number">0</span></span><br><span class="line">        self.l = l</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sign</span><span class="params">(self, X, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.w @ X + self.b) * y</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X_train, y_train)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            wrong_count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X_train)):</span><br><span class="line">                X = X_train[i]</span><br><span class="line">                y = y_train[i]</span><br><span class="line">                <span class="keyword">if</span> self.sign(X, y) &lt;= <span class="number">0</span>:</span><br><span class="line">                    self.w += self.l * np.dot(X, y)</span><br><span class="line">                    self.b += self.l * y</span><br><span class="line">                    wrong_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> wrong_count == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> (self.w, self.b)</span><br></pre></td></tr></table></figure><p>用 <code>sklearn</code> 包中 <code>iris</code> 数据集作为测试数据集，一系列处理后画图<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">perceptron = Model(<span class="number">2</span>, <span class="number">0.01</span>)</span><br><span class="line">perceptron.fit(X, y)</span><br><span class="line">x_points = np.linspace(<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>)</span><br><span class="line">y_points = <span class="number">-1</span>*(perceptron.w[<span class="number">0</span>] * x_points + perceptron.b)/perceptron.w[<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p><img src="https://github.com/fudonglai/merge_reponsitories/blob/master/perceptron.png?raw=true" alt="perceptron"></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>在处理数据，将输出空间的数据改成 -1 和 +1 的时候，我在纠结到底应该是在超平面以上是 +1 还是以下是 +1，事实证明都可以，因为参数会自动调整，只要跟着梯度的方向走就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;纸上得来终觉浅，绝知此事要躬行，只有亲自实现一个简单的感知机，遇到各种突发奇想的疑问然后尝试解决，才能真正掌握原理。&lt;br&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://fudonglai.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Statistics" scheme="https://fudonglai.github.io/tags/Statistics/"/>
    
      <category term="Mathematics" scheme="https://fudonglai.github.io/tags/Mathematics/"/>
    
  </entry>
  
  <entry>
    <title>最小二乘法和正则化</title>
    <link href="https://fudonglai.github.io/2019/01/12/Statistics-1/"/>
    <id>https://fudonglai.github.io/2019/01/12/Statistics-1/</id>
    <published>2019-01-11T17:51:14.000Z</published>
    <updated>2019-01-16T04:19:13.068Z</updated>
    
    <content type="html"><![CDATA[<p>经过半年的数学，英语，算法学习，阿东又要重回机器学习算法的摸爬滚打中了，现在从统计学习方法开始边学边总结。之前学习过一遍，但是由于当时的知识有限，学起来略有困难，现在不仅有了更强的能力，而且开源社区对这方面的资源也日益完善，首先感谢各位大佬对我学习的帮助，尤其感谢<a href="https://github.com/fengdu78/lihang-code" target="_blank" rel="noopener">黄海广博士</a>将本书翻译成代码，对我们来说确实是一条学习捷径。</p><a id="more"></a><p>系列文章文按照本人学习李航<a href="">《统计学习方法》</a>的顺序，结合吴恩达老师的机器学习课程，记录一些重点和个人的思考，希望能帮助到大家。</p><h1 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h1><p>高斯于1823年在误差 $e_1, … ,e_n$ 独立同分布的假定下,证明了最小二乘方法的一个最优性质: 在所有无偏的线性估计类中,最小二乘方法是其中方差最小的！</p><p>最小二乘法就是设计出一个假设函数 $f(x)$，利用原始训练数据集 $T=(x_i, y_i), i \in [1, m]$，拟合出一组参数 $\omega(\omega_0, \omega_1…\omega_m)$，计算残差 $r_i=f(x_i)-y_i$ 使得损失函数 $Loss(\omega, f) = \sum_{i=1}^mr_i^2$ 最小。其实这个很好想明白吧？我写以上一堆数学符号只是为了重新熟悉一下 Mathjax 的语法，向 Markdown 工程师的方向更进一步，哈哈。</p><p>我们常用的假设函数是多项式函数<br>$$H(x)=w_0+w_1x+w_2x^2+…w_nx^n$$</p><p>为啥来？因为多项式函数的次数足够大的时候，是可以无限逼近很多曲线的，不过次数并不是越多越好的，看具体实现。</p><p>机器学习本质就是拟合，以便对未知作出预测，我们的目的就是最小化损失函数 $Loss(x)$，即<br>$$\min_\omega \sum_{i=1}^m(H(x_i)-y_i)^2$$</p><p>这里用 Python 代码模仿一个简单的最小二乘法示例，先生成了一个含有噪声的 $sin(2\pi x)$图像，然后用不同次数的多项式拟合，代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sin(x * np.pi * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit_func</span><span class="params">(p, x)</span>:</span></span><br><span class="line">    <span class="comment"># 这里 p 需要是一个序列，作为每个多项式的系数</span></span><br><span class="line">    <span class="comment"># 相当于之前的权值向量 w</span></span><br><span class="line">    f = np.polyld(p)</span><br><span class="line">    <span class="keyword">return</span> f(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">residuals</span><span class="params">(p, x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fit_func(x, p) - y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fitting</span><span class="params">(M=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    M 为多项式的次数</span></span><br><span class="line"><span class="string">    """</span>    </span><br><span class="line">    <span class="comment"># 随机初始化多项式参数</span></span><br><span class="line">    p_init = np.random.rand(M+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 最小二乘法</span></span><br><span class="line">    p_lsq = leastsq(residuals_func, p_init, args=(x, y))</span><br><span class="line">    print(<span class="string">'Fitting Parameters:'</span>, p_lsq[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 可视化</span></span><br><span class="line">    plt.plot(x_points, real_func(x_points), label=<span class="string">'real'</span>)</span><br><span class="line">    plt.plot(x_points, fit_func(p_lsq[<span class="number">0</span>], x_points), label=<span class="string">'fitted curve'</span>)</span><br><span class="line">    plt.plot(x, y, <span class="string">'bo'</span>, label=<span class="string">'noise'</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    <span class="keyword">return</span> p_lsq</span><br></pre></td></tr></table></figure><p>p_lsq_1 = fitting(M=1)]</p><p><img src="https://github.com/fudonglai/merge_reponsitories/blob/master/Screenshot%20from%202018-12-10%2011-49-09.png?raw=true" alt="picture"></p><p>p_lsq_3 = fitting(M=3)</p><p><img src="https://github.com/fudonglai/merge_reponsitories/blob/master/download.png?raw=true" alt="picture"></p><p>p_lsq_9 = fitting(M=9)</p><p><img src="https://github.com/fudonglai/merge_reponsitories/blob/master/download%20%281%29.png?raw=true" alt="picture"></p><p>显然最后一个过拟合，第一个拟合不足，第二个还差不多。</p><h1 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h1><p>为了解决过拟合，添加正则化项，模型越复杂，正则化项越大，越能抑制过拟合。<br>正则化项的一般形式为<br>$$\min_{f\in F} \frac{1}{N} \sum_{i=1}^n L(y_i, f(x_i)) + \lambda J(f) $$</p><p>其中 $L(y_i, f(x_i))$ 表示损失函数，说白了就是误差，就是说着一块要越小越好，越小越准确啊。一般我们损失函数都是平方函数，正则化项可以考虑 $L_1$ 或 $L_2$ 范数，一般用 $L_2$ 范数比较多吧。</p><p>那么我们解决的问题就是最小化损失函数</p><p>$$ L(w) = \frac{1}{N} (f(x_i;w)-y_i)^2 + \frac{\lambda}{2}||w||^2 $$</p><p>$||w||$ 是 $L_2$ 范数，$||w||= \sqrt{w~w^T}$，至于为什么，我推荐<a href="https://www.cnblogs.com/weizc/p/5778678.html" target="_blank" rel="noopener">一篇博客</a>。</p><p>以下是算法代码，从这里我发现了一点之前没有注意过的问题：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">residuals_func_regularization</span><span class="params">(p, x, y)</span>:</span></span><br><span class="line">    ret = fit_func(p, x) - y</span><br><span class="line">    ret = np.append(ret, np.sqrt(<span class="number">0.5</span>*regularization*np.square(p))) <span class="comment"># L2范数作为正则化项</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></p><p>我发现一个问题：np.append() 函数是直接在向量之后增加，相当于增加了原始向量的长度，而我记得以前学习正则化的时候，是直接把罚项加到损失函数里面，这样最小化损失函数的时候也可以同时最小化罚项，也就是简化了模型参数。而且上面那个公式不是写了要对 $L_2$ 范数平方吗，那对罚项再开根号有什么意义，都是求最小值，为何要徒增计算量？</p><p>我觉得这个函数这样写都可以:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_residuals_func_regularization</span><span class="params">(p, x, y)</span>:</span></span><br><span class="line">    ret = fit_func(p, x) - y</span><br><span class="line">    ret = np.append(ret, np.sqrt(<span class="number">0.5</span>*regularization*np.square(p)))</span><br><span class="line">    <span class="comment"># ret = np.append(ret, 0.5*regularization*np.square(p))</span></span><br><span class="line">    <span class="comment"># ret = ret + 0.5*regularization*np.square(p)</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></p><p>我试了下，果然都可以，应为思想都没变，都是要同时最小化损失函数和权值向量，只是 append 的话就是把正则项同时作为损失参考指标而已，相当于把损失函数和正则项分开，同时优化。</p><p>我对这里正则化的理解是，多项式系数越高，模型越复杂，就是说参数越多，可以把每个次数的单项式理解成一个特征，然而有的特征并不是重点，却占有较大权值，应该舍弃，但是如果没有正则化项的话，这些特征就是过拟合的元凶。而有了正则化，迫使参数和模型的复杂度同时降低，就使这种特征的权值很低，接近于 0，相当于减少了冗余特征，增加了模型的泛化能力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经过半年的数学，英语，算法学习，阿东又要重回机器学习算法的摸爬滚打中了，现在从统计学习方法开始边学边总结。之前学习过一遍，但是由于当时的知识有限，学起来略有困难，现在不仅有了更强的能力，而且开源社区对这方面的资源也日益完善，首先感谢各位大佬对我学习的帮助，尤其感谢&lt;a href=&quot;https://github.com/fengdu78/lihang-code&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;黄海广博士&lt;/a&gt;将本书翻译成代码，对我们来说确实是一条学习捷径。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://fudonglai.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Statistics" scheme="https://fudonglai.github.io/tags/Statistics/"/>
    
      <category term="Mathematics" scheme="https://fudonglai.github.io/tags/Mathematics/"/>
    
  </entry>
  
  <entry>
    <title>排序I - 归并 &amp; 快排</title>
    <link href="https://fudonglai.github.io/2019/01/10/Quick-Merge-Sort/"/>
    <id>https://fudonglai.github.io/2019/01/10/Quick-Merge-Sort/</id>
    <published>2019-01-10T11:03:18.000Z</published>
    <updated>2019-01-11T03:13:06.950Z</updated>
    
    <content type="html"><![CDATA[<p>最经又刷了不少算法题，啃了啃《算法导论》，觉得很多算法光写而不拿出来总结，还是不能体会出精髓，于是将自己吸收的东西总结一下，力求能让其他人都看懂。同时练习一下 C++ 泛型编程，写成泛型算法。</p><a id="more"></a><h1 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h1><p>归并排序，典型的分治算法；分治，典型的递归结构。</p><p>分治算法可以分三步走：分解 -&gt; 解决 -&gt; 合并</p><ol><li>分解原问题为结构相同的子问题。</li><li>分解到某个容易求解的边界之后，进行第归求解。</li><li>将子问题的解合并成原问题的解。</li></ol><p><strong>递归</strong> 并不是一种算法，而只是一种编程技巧，例如在分治算法的第二步，很容易看出递归结构，所以分治算法都是由递归实现的。关于递归，我会抽时间专门写一篇文章，从数学和计算机的角度来简单分析一下。</p><p>这里只说一点我编写递归代码的心得：<strong>递归函数只做一件事，并且你相信它一定能做好</strong>，千万不要跳进这个函数里面企图探究更多细节，否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。就举个最简单的例子：遍历二叉树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    traverse(root-&gt;left);</span><br><span class="line">    traverse(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几行代码就足以扫荡任何一棵二叉树了。我想说的是，对于递归函数<code>traverse(root)</code>，我们只要相信：给它一个根节点<code>root</code>，它就能遍历这棵树，因为写这个函数不就是为了这个目的吗？所以我们只需要把这个节点的左右节点再甩给这个函数就行了，因为我相信它能完成任务的。那么遍历一棵N叉数呢？太简单了好吧，和二叉树一模一样啊。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (child : root-&gt;children)</span><br><span class="line">        traverse(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于遍历的什么前、中、后序，那都是显而易见的，对于N叉树，显然没有中序遍历。</p><p>写了这么多题外话，就是让你记住，<strong>明确写出来的这个函数的职责，并且相信它一定能完成</strong>，这样就能看懂，甚至随手写出漂亮的递归代码了。在之后的<a href="">回溯算法</a>，<a href="">动态规划</a>中还会有大量算法由递归实现。现在言归正传。</p><p>归并排序，我们就叫这个函数<code>merge_sort</code>吧，按照我们上面说的，要明确该函数的职责，即<strong>对传入的一个数组排序</strong>。OK，那么这个问题能不能分解呢？当然可以！给一个数组排序，不就等于给该数组的两半分别排序，然后合并就完事了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(一个数组)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (可以很容易处理) <span class="keyword">return</span>;</span><br><span class="line">    merge_sort(左半个数组);</span><br><span class="line">    merge_sort(右半个数组);</span><br><span class="line">    merge(左半个数组, 右半个数组);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这个算法也就这样了，完全没有任何难度。记住之前说的，相信函数的能力，传给他半个数组，那么这半个数组就已经被排好了。而且你会发现这不就是个二叉树遍历模板吗？为什么是后序遍历？因为我们分治算法的套路是 <strong>分解 -&gt; 解决（触底） -&gt; 合并（回溯）</strong> 啊，先左右分解，再处理合并，回溯就是在退栈，就相当于后序遍历了。至于<code>merge</code>函数，参考两个有序链表的合并，简直一模一样，下面直接贴代码吧。</p><p>注意三点就行：</p><ol><li>我给每一半数组的最后一位添加了一个哨兵位，理论上应该是正无穷，这里用INT_MAX代替。</li><li>形参 <code>begin</code>, <code>end</code>参考 C++ 迭代器，取左闭右开区间，即数组范围在 <code>[begin, end)</code>。</li><li><code>pivot = begin + (end - begin) / 2</code>实际上就是取中值，防止溢出罢了。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">    merge_sort(nums, begin, pivot);</span><br><span class="line">    merge_sort(nums, pivot, end);</span><br><span class="line">    merge(nums, begin, pivot, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> pivot, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(nums.begin() + begin, nums.begin() + pivot);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(nums.begin() + pivot, nums.begin() + end);</span><br><span class="line">    left.push_back(INT_MAX);</span><br><span class="line">    right.push_back(INT_MAX);</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[p] &lt; right[q]) &#123;</span><br><span class="line">            nums[i] = left[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[i] = right[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h1><p>之所以把快速排序和归并排序放在一起，因为他俩很像，尤其是算法框架上，但是区别也很明显：</p><ol><li>归并排序是典型的分治思想，遵循 分解 -&gt; 处理 -&gt; 合并 的模式，<strong>观察归并代码，递归调用是在分解问题，<code>merge</code>函数兼顾处理和合并操作。</strong>快排不是分治的模式，而是遵行 <strong>预处理 -&gt; 分解 -&gt; 回溯</strong> 的模式，关键在于预处理阶段，<code>partition</code>函数能够将一个元素放到正确的位置，并将数组分成两半。</li><li>观察函数执行的过程，归并排序是从左到右或从右到左形成有序，而快速排序是单点突破，每次递归都会将某个元素排好，放到它的最终位置，而这个元素的选择是随机的，并没有什么规律。</li></ol><p>快排的<strong>关键点在于<code>partition</code>函数，返回划分点的索引，并使该点左侧的值都小于该点，右侧都大于该点</strong>。</p><p>划分完成后，再对这两半数组递归调用<code>quick_sort</code>函数即可。所以这个框架看起来像这个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(数组)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (没办法再分了) <span class="keyword">return</span>;</span><br><span class="line">    划分点 = partition(数组);</span><br><span class="line">    quick_sort(划分点左边的数组);</span><br><span class="line">    quick_sort(划分点右边的数组);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是个前序遍历二叉树嘛，至于为什么，你应该能猜出来了。<code>partition</code>函数就不好形容了，直接看代码好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> pivot, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    swap(nums[end - <span class="number">1</span>], nums[pivot]);</span><br><span class="line">    <span class="keyword">int</span> i = begin - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = begin; j &lt; end - <span class="number">1</span>; j++) &#123; <span class="comment">//!!!!!!!!!!</span></span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt; nums[end - <span class="number">1</span>])</span><br><span class="line">            swap(nums[++i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums[end - <span class="number">1</span>], nums[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end - begin &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> partitioned = partition(nums, begin, end - <span class="number">1</span>, end);</span><br><span class="line">    quick_sort(nums, begin, partitioned);</span><br><span class="line">    quick_sort(nums, partitioned + <span class="number">1</span>, end); <span class="comment">//!!!!!!!!!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打感叹号的地方尤其需要注意，<code>j=begin</code>, <code>partitioned + 1</code>, 这两个地方我没注意，调了半天 bug 。</p><p>记住递归调用的时候是传入划分点左右的数组，<strong>不包括划分点本身！</strong>否则算法就会无限递归下去。</p><p>最后放一个 C++ 写的快排泛型算法，参照 Github 上的项目编写（泛型写起来麻烦点，但是用起来真香）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SortAlgorithm &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> CompareType=<span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::value_type&gt;&gt;</span><br><span class="line">    Iterator partition(<span class="keyword">const</span> Iterator begin, <span class="keyword">const</span> Iterator end, <span class="keyword">const</span> Iterator pivot_iter,</span><br><span class="line">                       CompareType compare = CompareType()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> size = <span class="built_in">std</span>::distance(begin, end);</span><br><span class="line">        assert(size &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> end;</span><br><span class="line">        assert(<span class="built_in">std</span>::distance(begin, pivot_iter) &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">std</span>::distance(pivot_iter, end) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> smaller_next = begin;</span><br><span class="line">        <span class="keyword">auto</span> current = begin;</span><br><span class="line">        <span class="keyword">while</span> (current != end - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compare(*current, *(end - <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(*current, *smaller_next);</span><br><span class="line">                smaller_next++;</span><br><span class="line">            &#125;</span><br><span class="line">            current++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::swap(*smaller_next, *(end - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> smaller_next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> CompareType=<span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::value_type&gt;&gt;</span><br><span class="line">    <span class="keyword">void</span> quick_sort(<span class="keyword">const</span> Iterator begin, <span class="keyword">const</span> Iterator end, CompareType compare = CompareType()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> size = <span class="built_in">std</span>::distance(begin, end);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> partitioned_iter = partition(begin, end, end - <span class="number">1</span>, compare); <span class="comment">//end-1 as pivot</span></span><br><span class="line">        quick_sort(begin, partitioned_iter, compare);</span><br><span class="line">        quick_sort(partitioned_iter + <span class="number">1</span>, end, compare);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最经又刷了不少算法题，啃了啃《算法导论》，觉得很多算法光写而不拿出来总结，还是不能体会出精髓，于是将自己吸收的东西总结一下，力求能让其他人都看懂。同时练习一下 C++ 泛型编程，写成泛型算法。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Sort" scheme="https://fudonglai.github.io/tags/Sort/"/>
    
      <category term="算法导论" scheme="https://fudonglai.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数组旋转算法</title>
    <link href="https://fudonglai.github.io/2018/12/23/Rotate-Array/"/>
    <id>https://fudonglai.github.io/2018/12/23/Rotate-Array/</id>
    <published>2018-12-23T05:19:18.000Z</published>
    <updated>2018-12-23T07:01:15.558Z</updated>
    
    <content type="html"><![CDATA[<p>交换数组的两个区域很简单吗？</p><p>以下给出链表解法，递归解法，连续翻转，杂技解法。</p><a id="more"></a><p>题目和图片来自 <a href="https://leetcode.com/explore/featured/card/top-interview-questions-easy/92/array/646/" target="_blank" rel="noopener">LeetCode</a>。</p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h2><p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7] and k = 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class="line">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class="line">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [-1,-100,3,99] and k = 2</span><br><span class="line">Output: [3,99,-1,-100]</span><br><span class="line">Explanation: </span><br><span class="line">rotate 1 steps to the right: [99,-1,-100,3]</span><br><span class="line">rotate 2 steps to the right: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><h2 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection:"></a>Reflection:</h2><p>这个问题实际上可以简化为如何交换数组的两部分，但是在思维模式上还是有差别，那么首先按照题目的意思，Rotate 一个数组，相当于循环位移每个元素？显然对于数组来说，看起来简单的整体移动涉及大量数据搬移，可以说非常低效。数组要是能连接成一个环就好了？那我用链表造个环不就完事了。</p><p>抛开循环移动这个思维，<code>Rotate</code>这个操作的结果不就是把数组某个节点两边数据交换了一下吗？这个操作看起来也好简单啊，swap 就完了？但是事实好像并没有这么简单。</p><h2 id="Approach-I-Cycle-Linked-List"><a href="#Approach-I-Cycle-Linked-List" class="headerlink" title="Approach I: Cycle Linked List"></a>Approach I: Cycle Linked List</h2><p><strong>Time Complexity: O(n), Space Complexity: O(n)</strong></p><p>我们创造一个环链表，记住开头元素位置，然后走相应步数之后，把这个地方作为开头，读取环链表，得到的就是结果了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode *p = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> ListNode(n);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = head-&gt;next;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> step = nums.size() - k % nums.size();</span><br><span class="line">    <span class="keyword">while</span> (step--) p = p-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        nums[i] = p-&gt;val;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-II-Recursion"><a href="#Approach-II-Recursion" class="headerlink" title="Approach II: Recursion"></a>Approach II: Recursion</h2><p><strong>Time Complexity: O(n), Space Complexity: O(n)</strong></p><p>抛开整体移动，直接粗暴地交换元素的话，两个区域长度相同的话直接<code>swap</code> n/2 次就完全交换了，但是如果两个区域长度不同，长的那部分就会有剩余，该剩余区域还需要和长区域经过交换的那个区域交换，以还原长区域的原始顺序，然后这个交换过程又会产生长短不一的问题，然后请重新阅读这段话。</p><p>子问题和原问题结构完全相同，规模更小，明显的递归结构，结束边界就是两个区域长度相等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursiveSwap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    k %= length;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) </span><br><span class="line">        swap(nums[start + i], nums[nums.size() - k + i]);</span><br><span class="line">    recursiveSwap(nums, k, start + k, length - k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度是最坏情况，也就是交换<code>nums[0]</code>和<code>nums[1...size-1]</code>的极端情况。</p><p>写出该递归数学形式，求解封闭解，可以把该函数改为封闭递推形式：</p><p><strong>Time Complexity: O(n), Space Complexity: O(1)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span> (; k %= n; n -= k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            swap(nums[i], nums[n - k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于递归式求解封闭解，需要数学技巧，并且写出来的代码基本看不懂，不会就算了。</p><h2 id="Approach-III-Magic-Method"><a href="#Approach-III-Magic-Method" class="headerlink" title="Approach III: Magic Method"></a>Approach III: Magic Method</h2><p><strong>Time Complexity: O(n), Space Complexity: O(1)</strong></p><p>类似链表解法，但是不需要额外的链表节点表示，直接在数组上进行跳跃。反正描述不清楚，看代码自行体会一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums: [1, 2, 3, 4, 5, 6]</span><br><span class="line">k: 2</span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/media/original_images/189_Rotate_Array.png" alt="example"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; step &lt; nums.size(); start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = start;</span><br><span class="line">            <span class="keyword">int</span> prev_val = nums[start];</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> next = (curr + k) % nums.size();</span><br><span class="line">                <span class="keyword">int</span> temp = nums[next];</span><br><span class="line">                nums[next] = prev_val;</span><br><span class="line">                prev_val = temp;</span><br><span class="line">                curr = next;</span><br><span class="line">                step++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (curr != start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-IV-KISS"><a href="#Approach-IV-KISS" class="headerlink" title="Approach IV: KISS"></a>Approach IV: KISS</h2><p><strong>Time Complexity: O(n), Space Complexity: O(1)</strong></p><p>只有看到这里的真的猛士才配拥有真正的终极算法。</p><p>交换两段数据？只要分别反转这两段，再把整个数组反转就行了，不信自己数一数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Keep it simple, stupid.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        reverse(nums.begin(), nums.begin() + n - k);</span><br><span class="line">        reverse(nums.begin() + n - k, nums.end());</span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;交换数组的两个区域很简单吗？&lt;/p&gt;
&lt;p&gt;以下给出链表解法，递归解法，连续翻转，杂技解法。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Array" scheme="https://fudonglai.github.io/tags/Array/"/>
    
      <category term="LinkedList" scheme="https://fudonglai.github.io/tags/LinkedList/"/>
    
      <category term="Recursion" scheme="https://fudonglai.github.io/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>深度复制随机链表</title>
    <link href="https://fudonglai.github.io/2018/12/22/deepCopyRandomLink/"/>
    <id>https://fudonglai.github.io/2018/12/22/deepCopyRandomLink/</id>
    <published>2018-12-22T15:03:31.000Z</published>
    <updated>2018-12-22T15:12:00.952Z</updated>
    
    <content type="html"><![CDATA[<p>以下有三种常规解决方案，和一种杂技解法。</p><p>Best Approach: Time Complexity O(n), Space Complexity O(1).</p><a id="more"></a><p><strong>题目及图片均源于 <a href="https://leetcode.com/explore/interview/card/top-interview-questions-hard/117/linked-list/841/]" target="_blank" rel="noopener">LeetCode</a> </strong>。</p><p>题目：给一个链表，这个链表有点特殊，即每个节点还包含一个随机指针，随机指向链表中的某一个节点，请你深度复制（DeepCopy）这个链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * class RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode next, random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) &#123; this.label = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/problems/copy-list-with-random-pointer/Figures/138/138_Copy_List_Random_1.png" alt="RandomLinkedList"></p><p>首先想到，这随机链表不就是个图吗？首先就想到 <a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">Clone Graph</a>，最起码有深度优先和广度优先两种方法。</p><h2 id="Approach-I-DFS"><a href="#Approach-I-DFS" class="headerlink" title="Approach I: DFS"></a>Approach I: DFS</h2><p><strong>Time Complexity O(n), Space Complexity O(n)</strong></p><p>递归实现简单易懂，确定边界条件，然后调用自己就完事了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;RandomListNode, RandomListNode&gt;</span><br><span class="line">        visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span> (visited.containsKey(head)) <span class="keyword">return</span> visited.get(head);</span><br><span class="line">        RandomListNode cp = <span class="keyword">new</span> RandomListNode(head.label);</span><br><span class="line">        visited.put(head, cp);</span><br><span class="line">        cp.next = copyRandomList(head.next);</span><br><span class="line">        cp.random = copyRandomList(head.random);</span><br><span class="line">        <span class="keyword">return</span> cp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-II-BFS"><a href="#Approach-II-BFS" class="headerlink" title="Approach II: BFS"></a>Approach II: BFS</h2><p><strong>Time Complexity O(n), Space Complexity O(n)</strong></p><p>这段是我用 C++ 写的，借鉴图克隆的算法，可以说都是一套模板了，个人认为没有递归舒服。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;RandomListNode*, RandomListNode*&gt; <span class="built_in">map</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;RandomListNode*&gt; q;</span><br><span class="line">        q.push(head);</span><br><span class="line">        <span class="built_in">map</span>[head] = <span class="keyword">new</span> RandomListNode(head-&gt;label);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> front = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;next &amp;&amp; <span class="built_in">map</span>.find(front-&gt;next) == <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                <span class="built_in">map</span>[front-&gt;next] = <span class="keyword">new</span> RandomListNode(front-&gt;next-&gt;label);</span><br><span class="line">                q.push(front-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;random &amp;&amp; <span class="built_in">map</span>.find(front-&gt;random) == <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                <span class="built_in">map</span>[front-&gt;random] = <span class="keyword">new</span> RandomListNode(front-&gt;random-&gt;label);</span><br><span class="line">                q.push(front-&gt;random);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>[front]-&gt;random = <span class="built_in">map</span>[front-&gt;random];</span><br><span class="line">            <span class="built_in">map</span>[front]-&gt;next = <span class="built_in">map</span>[front-&gt;next];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[head];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-III-Double-Pointer"><a href="#Approach-III-Double-Pointer" class="headerlink" title="Approach III: Double Pointer"></a>Approach III: Double Pointer</h2><p><strong>Time Complexity O(n), Space Complexity O(n)</strong></p><p>常规方法吧，类似双指针同步操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;RandomListNode, RandomListNode&gt;</span><br><span class="line">        visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> RandomListNode <span class="title">getCloneNode</span><span class="params">(RandomListNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span> (!visited.containsKey(node))</span><br><span class="line">            visited.put(node, <span class="keyword">new</span> RandomListNode(node.label));</span><br><span class="line">        <span class="keyword">return</span> visited.get(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        RandomListNode oldNode = head;</span><br><span class="line">        RandomListNode newNode = getCloneNode(head);</span><br><span class="line">        <span class="keyword">while</span> (oldNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            newNode.next = getCloneNode(oldNode.next);</span><br><span class="line">            newNode.random = getCloneNode(oldNode.random);</span><br><span class="line">            oldNode = oldNode.next;</span><br><span class="line">            newNode = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-IV：Magic-Method"><a href="#Approach-IV：Magic-Method" class="headerlink" title="Approach IV：Magic Method"></a>Approach IV：Magic Method</h2><p><strong>Time Complexity O(n), Space Complexity O(1)</strong></p><p>比较难想到，竟然不需要额外存储空间来记录已生成的节点？</p><p>本方法分为两步走：</p><ol><li><p>克隆原节点的 next 域和 random 域，然后将克隆的节点（cloned）放到原始节点（original）之后，此处需要链表插入操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cloned.next = original.next</span><br><span class="line">original.next = cloned</span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/articles/Figures/138/138_Copy_List_Random_9_1.png" alt="step1"></p></li><li>解开 cloned 和 original 的连接，分为两条链表，完成复制。</li></ol><p><img src="https://leetcode.com/articles/Figures/138/138_Copy_List_Random_10.png" alt="step2"></p><p>Java 代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        RandomListNode original = head;</span><br><span class="line">        <span class="keyword">while</span> (original != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloned = <span class="keyword">new</span> RandomListNode(original.label);</span><br><span class="line">            cloned.next = original.next;</span><br><span class="line">            original.next = cloned;</span><br><span class="line">            original = cloned.next;</span><br><span class="line">        &#125;</span><br><span class="line">        original = head;</span><br><span class="line">        <span class="keyword">while</span> (original != <span class="keyword">null</span>) &#123;</span><br><span class="line">            original.next.random = </span><br><span class="line">                (original.random != <span class="keyword">null</span>) ? original.random.next : <span class="keyword">null</span>;</span><br><span class="line">            original = original.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        RandomListNode cloned_head = head.next;</span><br><span class="line">        RandomListNode cloned = cloned_head;</span><br><span class="line">        original = head;</span><br><span class="line">        <span class="keyword">while</span> (cloned != <span class="keyword">null</span>) &#123;</span><br><span class="line">            original.next = cloned.next;</span><br><span class="line">            original = original.next;</span><br><span class="line">            cloned.next = (original != <span class="keyword">null</span>) ? original.next : <span class="keyword">null</span>;</span><br><span class="line">            cloned = cloned.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloned_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下有三种常规解决方案，和一种杂技解法。&lt;/p&gt;
&lt;p&gt;Best Approach: Time Complexity O(n), Space Complexity O(1).&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="LinkedList" scheme="https://fudonglai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>现代C语言--I</title>
    <link href="https://fudonglai.github.io/2018/11/19/Modern-C-Lang/"/>
    <id>https://fudonglai.github.io/2018/11/19/Modern-C-Lang/</id>
    <published>2018-11-18T17:09:53.000Z</published>
    <updated>2018-11-20T06:55:13.184Z</updated>
    
    <content type="html"><![CDATA[<p>C语言简单而隐晦的角落。</p><a id="more"></a><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><p>scanf 遇到的字符不是当前内容时， 会把它放回原处，在扫描下一个输入项或下一次调用 scanf 时再试图读入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">float</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%f%f"</span>, &amp;i, &amp;j, &amp;x, &amp;y);</span><br></pre></td></tr></table></figure><p>Suppose that the user enters three lines of input:</p><blockquote><p>1-20.3-4.0e3</p></blockquote><ul><li>第一个转换符是 %d，第一个非空字符是 1，可以出现在整数中，下一个字符是 ”-“，scanf 认为它不应该出现在整数内部，所以把 “-” 放回原处，把 1 读入 i 。</li><li>第二个读入 -20 之后发现小数点，scanf 认为它不该出现在整数中，所以把 -20 读入 j 。</li><li>第三个读入 .3，发现负号不该出现在浮点数中间，所以把 0.3 读入 x 。</li><li>最后把 -4*10^3 读入 y，并把最后的换行符放回原处。</li></ul><p>在读取格式串时遇到任何空白字符，scanf 会跳过空白符直到遇到非空白符尝试读取。</p><p>如 <code>&quot;%d/%d&quot;</code> 格式串，输入<code>5/    96</code>，能够成功读取两个整数。</p><p>如输入<code>5  /    96</code>，则在读取 5 后无法匹配 <code>/</code>而把之后的所有留给下次 scanf 调用。</p><h2 id="的副作用（side-effect）"><a href="#的副作用（side-effect）" class="headerlink" title="+= 的副作用（side effect）"></a>+= 的副作用（side effect）</h2><p>如果 v 有副作用，那么 v += e 不等价于 v = v + e 。</p><p>因为 v += e 只会导致一次 v 的求值，而 v = v + e 有两次。</p><p>如 <code>a[i++] += 1</code> 只会导致 i 自增 1；</p><p>而 <code>a[i++] = a[i++] + 1</code> 导致 i 自增 2 。</p><h2 id="getchar"><a href="#getchar" class="headerlink" title="getchar"></a>getchar</h2><p>getchar(), putchar() faster than scanf and printf.</p><p><strong>idiom</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>) <span class="comment">/*skips rest of line*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) == <span class="string">' '</span>) <span class="comment">/*skips blanks*/</span></span><br></pre></td></tr></table></figure><p>如果混用 scanf 和 getchar，注意 scanf 读取剩下的字符（包括换行符）会被 getchar 读取。</p><h2 id="使用-lf-读取-double-型的值，用-f-进行显示"><a href="#使用-lf-读取-double-型的值，用-f-进行显示" class="headerlink" title="使用 %lf 读取 double 型的值，用 %f 进行显示"></a>使用 %lf 读取 double 型的值，用 %f 进行显示</h2><p>因为 printf 和 scanf 都没有限制参数个数，使用了可变长度参数列表。</p><p>当调用可变长度参数列表函数时编译器安排 float 自动转化成 double 型，所以 printf 无法区分 float 和 double，所以可以用 %f 表示 float 和 double。</p><p>但是 scanf 用指针指向变量，必须知道地址上存储的类型，否则如果 float 和 double 位模式不同，scanf 会存储错误的字节数量。</p><h2 id="typedef-优于宏定义"><a href="#typedef-优于宏定义" class="headerlink" title="typedef 优于宏定义"></a>typedef 优于宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR_TO_INT int *</span></span><br><span class="line">PTR_TO_INT p, q;</span><br><span class="line"><span class="comment">// int *p, q;</span></span><br><span class="line"><span class="comment">// typedef will be better</span></span><br></pre></td></tr></table></figure><h2 id="远离-1"><a href="#远离-1" class="headerlink" title="远离 1"></a>远离 1</h2><p>下标从 0 开始，注意数组的下标越界陷阱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">    a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可能会导致无限循环。因为 <code>a[10]</code>已经越界，如果变量 <code>i</code>如果储存在这块空间，则错误地把<code>i</code>赋值为 0，无限循环。</p><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>如果给定长度和初始化列表，列表长度为0 或超过长度都是非法的，如果小于长度，剩余位置自动初始化为 0 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">/*initial value: 1,2,0,0,0,0,0,0,0,0*/</span></span><br></pre></td></tr></table></figure><p><strong>多维数组初始化：</strong></p><ul><li>如果一行给出的列表不能填满该行，该行剩余填满 0 。</li><li>如果给出的列表行数不足数组行数，剩余行数全部填满 0 。</li><li>如果去掉大括号也可以，一旦填满一行，编译器自动去填下一行。（危险）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">               &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="comment">/* 1,2,0,0,</span></span><br><span class="line"><span class="comment">   1,2,3,4,</span></span><br><span class="line"><span class="comment">   0,0,0,0,</span></span><br><span class="line"><span class="comment">   0,0,0,0 */</span></span><br></pre></td></tr></table></figure><p>所以要全部初始化为 0 应该是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组和指针区别"><a href="#数组和指针区别" class="headerlink" title="数组和指针区别"></a>数组和指针区别</h2><ol><li><p>数组名不能被赋予新值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (*a != <span class="number">0</span>)</span><br><span class="line">    a++;<span class="comment">/*WRONG*/</span></span><br></pre></td></tr></table></figure></li><li><p><code>sizeof()</code>对数组名和指针效果不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len_of_a = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">/* len_of_a == 3 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line"><span class="keyword">int</span> len_of_p = <span class="keyword">sizeof</span>(p); <span class="comment">/* len_of_p == sizeof(int*) */</span></span><br></pre></td></tr></table></figure><p>sizeof 对普通指针计算一个指针在内存中的字节长度，这取决于机器。</p><p>sizeof 对数组名计算该数组在内存中的总字节长度，所以可以那样求得数组元素个数。</p></li></ol><h2 id="函数形式参数中-int-a-还是-int-a"><a href="#函数形式参数中-int-a-还是-int-a" class="headerlink" title="函数形式参数中 int *a 还是 int a[ ] ?"></a>函数形式参数中 int *a 还是 int a[ ] ?</h2><p>考虑到函数参数传入的是拷贝，<code>int *a</code> 和 <code>int a[]</code> 完全相同，即便后者形式好像是数组，实际上也是普通指针，没有任何数组名的特殊技能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);  <span class="comment">/*WRONG*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组型参数"><a href="#数组型参数" class="headerlink" title="数组型参数"></a>数组型参数</h2><p>传入一维数组时，不需要写长度，写了也没用。</p><p>传入多为数组时，只有第一维长度是不必要的。因为要让编译器知道一个元素长度到底是多少。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a[<span class="number">10</span>])</span></span>&#123;  <span class="comment">//OK</span></span><br><span class="line">    <span class="comment">/* equal to fun(int a[]) and fun(int* a) */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">10</span>])</span></span>&#123; <span class="comment">//correct</span></span><br><span class="line">    <span class="comment">/* because complier konws there are sizeof(int) * 10 </span></span><br><span class="line"><span class="comment">    bits between a[0] and a[1] */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* fun2(int a[][]) is WRONG */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="i-a"><a href="#i-a" class="headerlink" title="i [a] ???"></a>i [a] ???</h2><p>对编译器而言：<code>i[a] == *(i + a) == a[i]</code></p><h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h2><p>最后一个是空字符<code>/0</code>，其 ASCII 码为 0 ，而数字 <code>0</code> 的 ASCII 码为 48 。</p><h2 id="字符数组和数组指针"><a href="#字符数组和数组指针" class="headerlink" title="字符数组和数组指针"></a>字符数组和数组指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> date_arr[] = <span class="string">"Nov 20"</span>;</span><br><span class="line"><span class="keyword">char</span>* date_ptr = <span class="string">"Nov 20"</span>;</span><br></pre></td></tr></table></figure><ul><li><code>date_ptr</code>是指针变量，可以再指向其他值，<code>date_arr</code>不能。</li><li><code>date_ptr</code>指向的字符串是字面值，不可修改，<code>date_arr</code>可以随意修改。</li></ul><p>初始化字符数组时类似普通数组，若填不满空位添 0 ，超过限制就非法，但是不会检查最后是否有停止标识符<code>/0</code>。</p><p>考虑 <code>printf</code>和<code>scanf</code>第一个参数都是接受字符串常量，即该串的首地址。</p><h2 id="读写字符串"><a href="#读写字符串" class="headerlink" title="读写字符串"></a>读写字符串</h2><h3 id="printf-amp-amp-puts"><a href="#printf-amp-amp-puts" class="headerlink" title="printf &amp;&amp; puts"></a>printf &amp;&amp; puts</h3><p>printf 逐个读取字符，直到读到空字符，如果空字符丢失，继续读，知道在内存找到一个空字符为止。</p><p>puts 接受一个参数没有格式串，写完字符串后自动添加换行符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"abcdef"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.3s"</span>, str); <span class="comment">// abc</span></span><br><span class="line"><span class="built_in">puts</span>(str); <span class="comment">// abcdef</span></span><br></pre></td></tr></table></figure><h3 id="scanf-amp-amp-gets"><a href="#scanf-amp-amp-gets" class="headerlink" title="scanf &amp;&amp; gets"></a>scanf &amp;&amp; gets</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 11</span></span><br><span class="line"><span class="keyword">char</span> str[LEN];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line"><span class="comment">/* input: "   hello world"*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   str: 'h','e','l','l','o','\0', ...</span></span><br><span class="line"><span class="comment">   scanf never get string with space, skip blank and end at blank,</span></span><br><span class="line"><span class="comment">   and add '\0' automatically.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">gets(str); <span class="comment">//all will be recieved, but dangerous</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言简单而隐晦的角落。&lt;/p&gt;
    
    </summary>
    
      <category term="C Programming Language" scheme="https://fudonglai.github.io/categories/C-Programming-Language/"/>
    
    
  </entry>
  
  <entry>
    <title>KMP for Pattern Searching</title>
    <link href="https://fudonglai.github.io/2018/10/26/KMP-for-Pattern-Searching/"/>
    <id>https://fudonglai.github.io/2018/10/26/KMP-for-Pattern-Searching/</id>
    <published>2018-10-26T08:18:39.000Z</published>
    <updated>2018-12-22T15:26:59.248Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Question:</strong> Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p><p>KMP (Knuth-Morris-Pratt Algorithm) is a classic and yet notoriously hard-to-understand algorithm.Fortunately, I found some perspicuous explainations.</p><p>Here are both Brute-Force method and KMP algorithm.</p><a id="more"></a><h1 id="Brute-Force-Implement"><a href="#Brute-Force-Implement" class="headerlink" title="Brute-Force Implement"></a>Brute-Force Implement</h1><p>It’s easy. Code is here:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (haystack.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> h = haystack.length(), n = needle.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= h - n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle.front())&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n &amp;&amp; haystack[i + j] == needle[j]; ++j)</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">if</span> (j == n)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The worst case complexity of the naive algorithm is $O(m(n-m+1))$. </p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">text[] = <span class="string">"AAAAAAAAAAAAAAAAAB"</span></span><br><span class="line">pattern[] = <span class="string">"AAAAB"</span></span><br><span class="line"><span class="comment">/*the worst case*/</span></span><br><span class="line"></span><br><span class="line">txt[] = <span class="string">"ABABABCABABABCABABABC"</span></span><br><span class="line">pat[] =  <span class="string">"ABABAC"</span> </span><br><span class="line"><span class="comment">/*not a worst case, but a bad case for Naive*/</span></span><br></pre></td></tr></table></figure><p>But the time complexity of KMP algorithm is $O(n)$ in the worst case. Of course, you need some extra space to preprocess the pattern.</p><p>Then you  can challenge yourself implement the KMP algorithm for this problem.</p><h1 id="KMP-Algorithm"><a href="#KMP-Algorithm" class="headerlink" title="KMP Algorithm"></a>KMP Algorithm</h1><p>You can refer to them for the detials:</p><ol><li>KMP on <a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="noopener">Jake Boxer’s Blog</a></li><li>KMP on <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/" target="_blank" rel="noopener">Geeks-for-Geeks</a></li></ol><h2 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h2><h3 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h3><p>Whenever we detect a mismatch (after some matches), we already know some of the characters in the text of the next window. We take advantage of this information to avoid matching the characters that we know will anyway match. </p><p>To know how many characters we can skip, we pre-process pattern and get an integer array that tells us the count of characters to be skipped. </p><h3 id="The-Partial-Match-Table"><a href="#The-Partial-Match-Table" class="headerlink" title="The Partial Match Table"></a>The Partial Match Table</h3><p>Here I want to quote <a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="noopener">Jake Boxer’s perspicuous explaination</a>.</p><p>Here’s the partial match table for the pattern “abababca”:</p><table><thead><tr><th>char</th><th>a</th><th>b</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>a</th></tr></thead><tbody><tr><td>index</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>value</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>0</td><td>1</td></tr></tbody></table><blockquote><p><strong>Proper prefix</strong>: All the characters in a string, with one or more cut off the end. “S”, “Sn”, “Sna”, and “Snap” are all the proper prefixes of “Snape”.</p><p><strong>Proper suffix</strong>: All the characters in a string, with one or more cut off the beginning. “agrid”, “grid”, “rid”, “id”, and “d” are all proper suffixes of “Hagrid”.</p><p>Here, we’re interested in the first four characters (“abab”). We have three proper prefixes (“a”, “ab”, and “aba”) and three proper suffixes (“b”, “ab”, and “bab”). This time, “ab” is in both, and is two characters long, so cell four gets value 2.</p><p>let’s also try it for cell five, which concerns “ababa”. We have four proper prefixes (“a”, “ab”, “aba”, and “abab”) and four proper suffixes (“a”, “ba”, “aba”, and “baba”). Now, we have two matches: “a” and “aba” are both proper prefixes and proper suffixes. Since “aba” is longer than “a”, it wins, and cell five gets value 3.</p><p>Let’s skip ahead to cell seven (the second-to-last cell), which is concerned with the pattern “abababc”. Even without enumerating all the proper prefixes and suffixes, it should be obvious that there aren’t going to be any matches; all the suffixes will end with the letter “c”, and none of the prefixes will. Since there are no matches, cell seven gets 0.</p></blockquote><h2 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h2><p>quote <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/" target="_blank" rel="noopener">Geeks-for-Geeks</a>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lps[i] = the longest proper prefix of pat[<span class="number">0.</span>.i] </span><br><span class="line">which is also a suffix of pat[<span class="number">0.</span>.i]. </span><br><span class="line">         </span><br><span class="line">Examples of lps[] construction:</span><br><span class="line"></span><br><span class="line">For the pattern “AAAA”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">For the pattern “ABCDE”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">For the pattern “AABAACAABAA”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">For the pattern “AAACAAAAAC”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>] </span><br><span class="line"></span><br><span class="line">For the pattern “AAABAAA”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="Preprocessing-Algorithm"><a href="#Preprocessing-Algorithm" class="headerlink" title="Preprocessing Algorithm"></a>Preprocessing Algorithm</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pat[] = <span class="string">"AAACAAAA"</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">0.</span></span><br><span class="line">lps[<span class="number">0</span>] <span class="keyword">is</span> always <span class="number">0</span>, we move </span><br><span class="line">to i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">1.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">1</span>, lps[<span class="number">1</span>] = <span class="number">1</span>, i = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">1</span>, i  = <span class="number">2.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">2</span>, lps[<span class="number">2</span>] = <span class="number">2</span>, i = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">2</span>, i  = <span class="number">3.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match, <span class="keyword">and</span> len &gt; <span class="number">0</span>, </span><br><span class="line">set len = lps[len<span class="number">-1</span>] = lps[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">1</span>, i  = <span class="number">3.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match <span class="keyword">and</span> len &gt; <span class="number">0</span>, </span><br><span class="line">len = lps[len<span class="number">-1</span>] = lps[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">3.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match <span class="keyword">and</span> len = <span class="number">0</span>, </span><br><span class="line">Set lps[<span class="number">3</span>] = <span class="number">0</span> <span class="keyword">and</span> i = <span class="number">4.</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">4.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">1</span>, lps[<span class="number">4</span>] = <span class="number">1</span>, i = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">1</span>, i  = <span class="number">5.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">2</span>, lps[<span class="number">5</span>] = <span class="number">2</span>, i = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">2</span>, i  = <span class="number">6.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">3</span>, lps[<span class="number">6</span>] = <span class="number">3</span>, i = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">3</span>, i  = <span class="number">7.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match <span class="keyword">and</span> len &gt; <span class="number">0</span>,</span><br><span class="line">set len = lps[len<span class="number">-1</span>] = lps[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">2</span>, i  = <span class="number">7.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">3</span>, lps[<span class="number">7</span>] = <span class="number">3</span>, i = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">We stop here <span class="keyword">as</span> we have constructed the whole lps[].</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Here is my preprocessing code:</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; generator(<span class="built_in">string</span> pattern)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lps(pattern.size());</span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pattern.size(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[len])&#123;</span><br><span class="line">            len++;</span><br><span class="line">            lps[i] = len;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">                len = lps[len - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                len = <span class="number">0</span>; i++;</span><br><span class="line">            &#125;<span class="comment">//else</span></span><br><span class="line">        &#125;<span class="comment">//else</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> lps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Matching-Algorithm"><a href="#Matching-Algorithm" class="headerlink" title="Matching Algorithm"></a>Matching Algorithm</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (haystack.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lps = generator(needle);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.size(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle[j])&#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j = lps[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;&#125;</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; Return the index of the first occurrence of needle in haystack, or &lt;strong&gt;-1&lt;/strong&gt; if needle is not part of haystack.&lt;/p&gt;
&lt;p&gt;KMP (Knuth-Morris-Pratt Algorithm) is a classic and yet notoriously hard-to-understand algorithm.Fortunately, I found some perspicuous explainations.&lt;/p&gt;
&lt;p&gt;Here are both Brute-Force method and KMP algorithm.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="patern search" scheme="https://fudonglai.github.io/tags/patern-search/"/>
    
  </entry>
  
  <entry>
    <title>Fundamental DP Problem</title>
    <link href="https://fudonglai.github.io/2018/10/26/Fundamental-DP-Problem/"/>
    <id>https://fudonglai.github.io/2018/10/26/Fundamental-DP-Problem/</id>
    <published>2018-10-26T02:52:13.000Z</published>
    <updated>2018-12-30T03:39:37.781Z</updated>
    
    <content type="html"><![CDATA[<p>There is an interesting problem in LeetCode: <a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">Unique Paths</a>.</p><p>I found some perspicuous explanation in the comments. Thank @<a href="https://leetcode.com/yfgu0618" target="_blank" rel="noopener">YFGu0618</a> for his graph.</p><a id="more"></a><h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><blockquote><p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid.</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid.</p><p>How many possible unique paths are there?</p></blockquote><h3 id="Observations"><a href="#Observations" class="headerlink" title="Observations:"></a>Observations:</h3><p>Since the robot can only move right and down, when it arrives at a point, there are only two possibilities:</p><ol><li>It arrives at that point from above (moving down to that point);</li><li>It arrives at that point from left (moving right to that point).</li></ol><p>Thus we have the following equations: $Approach(i, j)=Approach(i - 1, j) + Approach(i, j-1)$</p><p><img src="https://assets.leetcode.com/users/yfgu0618/image_1540157891.png" alt="picture"></p><p>The boundary conditions of the above equation have some problems at the leftmost column and the uppermost row due to $(0, j)$ and $(i, 0)$ do not exist. To oversmart the problem automatically,  it’s easier that we initialize the array to something like following:</p><p><img src="https://assets.leetcode.com/users/yfgu0618/image_1540158218.png" alt="picture"></p><h3 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h3><p>So, here is my codes:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; ++j) </span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][j - <span class="number">1</span>] + <span class="built_in">map</span>[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>As can be seen, the above solution runs in $O(n^2)$ time and costs $O(m*n)$ space.</p><p>But we find that each time we update the <code>map[i][j]</code>, we only need to consider the current column(for <code>map[i-1, j]</code>) and the previous column(for <code>map[i, j-1]</code>), so only two vector can be enough.</p><p>Here is new codes:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c1(m + <span class="number">1</span>, <span class="number">0</span>), c2(c1);</span><br><span class="line">        c1[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                c2[j] = c1[j] + c2[j - <span class="number">1</span>];</span><br><span class="line">            c1 = c2;</span><br><span class="line">            c2 = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c1[m];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Further inspecting the above code, we find it needs $O(m)$ space, but if $n&lt;m$, should I convert to $O(n)$ space? And we find that <code>vector c2</code>will convert to zero in every loop, so the operation is actually <code>c1[i] += c1[i-1]</code>. Now we can implement a more efficient approach:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">           <span class="keyword">return</span> uniquePaths(n, m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(m, <span class="number">0</span>);</span><br><span class="line">        c[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - <span class="number">1</span>; ++j) </span><br><span class="line">                c[j] += c[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> c[m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Now it is prefect, how interesting it is!</p><p>PS: 2018/12/30</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) <span class="keyword">return</span> uniquePaths(n, m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;There is an interesting problem in LeetCode: &lt;a href=&quot;https://leetcode.com/problems/unique-paths/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Unique Paths&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I found some perspicuous explanation in the comments. Thank @&lt;a href=&quot;https://leetcode.com/yfgu0618&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YFGu0618&lt;/a&gt; for his graph.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="dynamic programming" scheme="https://fudonglai.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Non-Repeating Longest Substring</title>
    <link href="https://fudonglai.github.io/2018/10/20/Non-Repeating-longest-substring/"/>
    <id>https://fudonglai.github.io/2018/10/20/Non-Repeating-longest-substring/</id>
    <published>2018-10-20T10:24:49.000Z</published>
    <updated>2018-10-26T13:01:00.989Z</updated>
    
    <content type="html"><![CDATA[<p>An ingenuity to use map to solve Substring.</p><a id="more"></a><h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><blockquote><p>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3. </p></blockquote><p>###Solution</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> * Solution (DP, O(n)):</span><br><span class="line"> * </span><br><span class="line"> * Assume L[i] = s[m...i], denotes the longest substring without repeating</span><br><span class="line"> * characters that ends up at s[i], <span class="keyword">and</span> we keep a hashmap <span class="keyword">for</span> every</span><br><span class="line"> * characters between m ... i, <span class="keyword">while</span> storing &lt;character, index&gt; in the</span><br><span class="line"> * hashmap.</span><br><span class="line"> * We know that each character will appear only once.</span><br><span class="line"> </span><br><span class="line"> * Then to find s[i+<span class="number">1</span>]:</span><br><span class="line"> * <span class="number">1</span>) <span class="keyword">if</span> s[i+<span class="number">1</span>] does <span class="keyword">not</span> appear in hashmap</span><br><span class="line"> *    we can just add s[i+<span class="number">1</span>] to hash <span class="built_in">map</span>. <span class="keyword">and</span> L[i+<span class="number">1</span>] = s[m...i+<span class="number">1</span>]</span><br><span class="line"> * <span class="number">2</span>) <span class="keyword">if</span> s[i+<span class="number">1</span>] exists in hashmap, <span class="keyword">and</span> the hashmap value (the index) is k</span><br><span class="line"> *    let m = max(m, k), then L[i+<span class="number">1</span>] = s[m...i+<span class="number">1</span>], we also need to update</span><br><span class="line"> *    entry in hashmap to mark the latest occurency of s[i+<span class="number">1</span>].</span><br><span class="line"> * </span><br><span class="line"> * Since we scan the <span class="built_in">string</span> <span class="keyword">for</span> only once, <span class="keyword">and</span> the <span class="string">'m'</span> will also move from</span><br><span class="line"> * beginning to end <span class="keyword">for</span> at most once. Overall complexity is O(n).</span><br><span class="line"> *</span><br><span class="line"> * If characters are all in ASCII, we could use <span class="built_in">array</span> to mimic hashmap.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> lengthOfLongestSubstring(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dict(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            m = max(m, dict[s[i]] + <span class="number">1</span>);</span><br><span class="line">            dict[s[i]] = i;</span><br><span class="line">            len = max(len, i - m + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Complement"><a href="#Complement" class="headerlink" title="Complement"></a>Complement</h3><p>Now I’ve meet some point of it:</p><ul><li>ASSIC uses one byte to encode, $2^{8}=256$, so we can regard a 256-size vector as a hashtable. The ASSIC of character will be key, its index will be value.</li><li><p>Remeber, every value in <code>dict</code> which not equals $-1$ represents the element’s index clostest to $i$’th element. </p></li><li><p>If all the character is unique, $m$ always equals 0, longest length will increase one by one.</p></li><li>If  encount a character repeates, then we compare $m$ and the index. If $m$ is greater than index, it means the element occured in a substring before, but no big deal for current substring count. If $m$ is less than index, it means the current substring can’t be longer any more, so $m$ will update to the index.</li><li>In other word, every time we update $m$ , we actually find a substring, which is <code>string[m: i]</code>.</li><li>As for varaible <code>len</code>, it compares every loop. Only when current substring <code>i - m + 1</code>longer than before, it will update to a large length.</li></ul><p>I think the partern of solution can have a double pointer expension.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;An ingenuity to use map to solve Substring.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Substring" scheme="https://fudonglai.github.io/tags/Substring/"/>
    
  </entry>
  
  <entry>
    <title>Think Recursively</title>
    <link href="https://fudonglai.github.io/2018/10/18/Think-Recursively/"/>
    <id>https://fudonglai.github.io/2018/10/18/Think-Recursively/</id>
    <published>2018-10-18T11:12:34.000Z</published>
    <updated>2018-12-23T07:01:16.462Z</updated>
    
    <content type="html"><![CDATA[<h3 id="“Top-down”-Solution"><a href="#“Top-down”-Solution" class="headerlink" title="“Top-down” Solution"></a>“Top-down” Solution</h3><p>When you meet a tree problem, ask yourself two questions: </p><ul><li>Can you determine some parameters to help the node know the answer of itself? </li><li>Can you use these parameters and the value of the node itself to determine what should be the parameters parsing to its children? </li></ul><a id="more"></a><p> If the answers are both <strong>yes</strong>, try to solve this problem using a “top-down” recursion solution.</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> answer;       <span class="comment">// don't forget to initialize answer before call maximum_depth</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maximum_depth</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        answer = max(answer, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    maximum_depth(root-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">    maximum_depth(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="“Bottom-up”-Solution"><a href="#“Bottom-up”-Solution" class="headerlink" title="“Bottom-up” Solution"></a>“Bottom-up” Solution</h3><p>Or you can think the problem in this way: </p><p>for a node in a tree, if you know the answer of its children, can you calculate the answer of the node? </p><p>If the answer is yes, solving the problem recursively from bottom up might be a good way.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum_depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;                                   <span class="comment">// return 0 for null node</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left_depth = maximum_depth(root.left);</span><br><span class="line"><span class="keyword">int</span> right_depth = maximum_depth(root.right);</span><br><span class="line"><span class="keyword">return</span> Math.max(left_depth, right_depth) + <span class="number">1</span>;<span class="comment">// return depth of the subtree rooted at root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;“Top-down”-Solution&quot;&gt;&lt;a href=&quot;#“Top-down”-Solution&quot; class=&quot;headerlink&quot; title=&quot;“Top-down” Solution&quot;&gt;&lt;/a&gt;“Top-down” Solution&lt;/h3&gt;&lt;p&gt;When you meet a tree problem, ask yourself two questions: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Can you determine some parameters to help the node know the answer of itself? &lt;/li&gt;
&lt;li&gt;Can you use these parameters and the value of the node itself to determine what should be the parameters parsing to its children? &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Recursion" scheme="https://fudonglai.github.io/tags/Recursion/"/>
    
  </entry>
  
</feed>
