<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FDL&#39;s BLOG</title>
  
  <subtitle>Down to earth. &lt;br&gt;Being towards death.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fudonglai.github.io/"/>
  <updated>2018-12-22T15:12:00.952Z</updated>
  <id>https://fudonglai.github.io/</id>
  
  <author>
    <name>Fudonglai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度复制随机链表</title>
    <link href="https://fudonglai.github.io/2018/12/22/%E6%B7%B1%E5%BA%A6%E5%A4%8D%E5%88%B6%E9%9A%8F%E6%9C%BA%E9%93%BE%E8%A1%A8/"/>
    <id>https://fudonglai.github.io/2018/12/22/深度复制随机链表/</id>
    <published>2018-12-22T15:03:31.000Z</published>
    <updated>2018-12-22T15:12:00.952Z</updated>
    
    <content type="html"><![CDATA[<p>以下有三种常规解决方案，和一种杂技解法。</p><p>Best Approach: Time Complexity O(n), Space Complexity O(1).</p><a id="more"></a><p><strong>题目及图片均源于 <a href="https://leetcode.com/explore/interview/card/top-interview-questions-hard/117/linked-list/841/]" target="_blank" rel="noopener">LeetCode</a> </strong>。</p><p>题目：给一个链表，这个链表有点特殊，即每个节点还包含一个随机指针，随机指向链表中的某一个节点，请你深度复制（DeepCopy）这个链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * class RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode next, random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) &#123; this.label = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/problems/copy-list-with-random-pointer/Figures/138/138_Copy_List_Random_1.png" alt="RandomLinkedList"></p><p>首先想到，这随机链表不就是个图吗？首先就想到 <a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">Clone Graph</a>，最起码有深度优先和广度优先两种方法。</p><h2 id="Approach-I-DFS"><a href="#Approach-I-DFS" class="headerlink" title="Approach I: DFS"></a>Approach I: DFS</h2><p><strong>Time Complexity O(n), Space Complexity O(n)</strong></p><p>递归实现简单易懂，确定边界条件，然后调用自己就完事了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;RandomListNode, RandomListNode&gt;</span><br><span class="line">        visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span> (visited.containsKey(head)) <span class="keyword">return</span> visited.get(head);</span><br><span class="line">        RandomListNode cp = <span class="keyword">new</span> RandomListNode(head.label);</span><br><span class="line">        visited.put(head, cp);</span><br><span class="line">        cp.next = copyRandomList(head.next);</span><br><span class="line">        cp.random = copyRandomList(head.random);</span><br><span class="line">        <span class="keyword">return</span> cp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-II-BFS"><a href="#Approach-II-BFS" class="headerlink" title="Approach II: BFS"></a>Approach II: BFS</h2><p><strong>Time Complexity O(n), Space Complexity O(n)</strong></p><p>这段是我用 C++ 写的，借鉴图克隆的算法，可以说都是一套模板了，个人认为没有递归舒服。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;RandomListNode*, RandomListNode*&gt; <span class="built_in">map</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;RandomListNode*&gt; q;</span><br><span class="line">        q.push(head);</span><br><span class="line">        <span class="built_in">map</span>[head] = <span class="keyword">new</span> RandomListNode(head-&gt;label);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> front = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;next &amp;&amp; <span class="built_in">map</span>.find(front-&gt;next) == <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                <span class="built_in">map</span>[front-&gt;next] = <span class="keyword">new</span> RandomListNode(front-&gt;next-&gt;label);</span><br><span class="line">                q.push(front-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;random &amp;&amp; <span class="built_in">map</span>.find(front-&gt;random) == <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                <span class="built_in">map</span>[front-&gt;random] = <span class="keyword">new</span> RandomListNode(front-&gt;random-&gt;label);</span><br><span class="line">                q.push(front-&gt;random);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>[front]-&gt;random = <span class="built_in">map</span>[front-&gt;random];</span><br><span class="line">            <span class="built_in">map</span>[front]-&gt;next = <span class="built_in">map</span>[front-&gt;next];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[head];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-III-Double-Pointer"><a href="#Approach-III-Double-Pointer" class="headerlink" title="Approach III: Double Pointer"></a>Approach III: Double Pointer</h2><p><strong>Time Complexity O(n), Space Complexity O(n)</strong></p><p>常规方法吧，类似双指针同步操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;RandomListNode, RandomListNode&gt;</span><br><span class="line">        visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> RandomListNode <span class="title">getCloneNode</span><span class="params">(RandomListNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span> (!visited.containsKey(node))</span><br><span class="line">            visited.put(node, <span class="keyword">new</span> RandomListNode(node.label));</span><br><span class="line">        <span class="keyword">return</span> visited.get(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        RandomListNode oldNode = head;</span><br><span class="line">        RandomListNode newNode = getCloneNode(head);</span><br><span class="line">        <span class="keyword">while</span> (oldNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            newNode.next = getCloneNode(oldNode.next);</span><br><span class="line">            newNode.random = getCloneNode(oldNode.random);</span><br><span class="line">            oldNode = oldNode.next;</span><br><span class="line">            newNode = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-IV：Magic-Method"><a href="#Approach-IV：Magic-Method" class="headerlink" title="Approach IV：Magic Method"></a>Approach IV：Magic Method</h2><p><strong>Time Complexity O(n), Space Complexity O(1)</strong></p><p>比较难想到，竟然不需要额外存储空间来记录已生成的节点？</p><p>本方法分为两步走：</p><ol><li><p>克隆原节点的 next 域和 random 域，然后将克隆的节点（cloned）放到原始节点（original）之后，此处需要链表插入操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cloned.next = original.next</span><br><span class="line">original.next = cloned</span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/articles/Figures/138/138_Copy_List_Random_9_1.png" alt="step1"></p></li><li>解开 cloned 和 original 的连接，分为两条链表，完成复制。</li></ol><p><img src="https://leetcode.com/articles/Figures/138/138_Copy_List_Random_10.png" alt="step2"></p><p>Java 代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        RandomListNode original = head;</span><br><span class="line">        <span class="keyword">while</span> (original != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloned = <span class="keyword">new</span> RandomListNode(original.label);</span><br><span class="line">            cloned.next = original.next;</span><br><span class="line">            original.next = cloned;</span><br><span class="line">            original = cloned.next;</span><br><span class="line">        &#125;</span><br><span class="line">        original = head;</span><br><span class="line">        <span class="keyword">while</span> (original != <span class="keyword">null</span>) &#123;</span><br><span class="line">            original.next.random = </span><br><span class="line">                (original.random != <span class="keyword">null</span>) ? original.random.next : <span class="keyword">null</span>;</span><br><span class="line">            original = original.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        RandomListNode cloned_head = head.next;</span><br><span class="line">        RandomListNode cloned = cloned_head;</span><br><span class="line">        original = head;</span><br><span class="line">        <span class="keyword">while</span> (cloned != <span class="keyword">null</span>) &#123;</span><br><span class="line">            original.next = cloned.next;</span><br><span class="line">            original = original.next;</span><br><span class="line">            cloned.next = (original != <span class="keyword">null</span>) ? original.next : <span class="keyword">null</span>;</span><br><span class="line">            cloned = cloned.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloned_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下有三种常规解决方案，和一种杂技解法。&lt;/p&gt;
&lt;p&gt;Best Approach: Time Complexity O(n), Space Complexity O(1).&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="LinkedList" scheme="https://fudonglai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>现代C语言--I</title>
    <link href="https://fudonglai.github.io/2018/11/19/%E7%8E%B0%E4%BB%A3C%E8%AF%AD%E8%A8%80-I/"/>
    <id>https://fudonglai.github.io/2018/11/19/现代C语言-I/</id>
    <published>2018-11-18T17:09:53.000Z</published>
    <updated>2018-11-20T06:55:13.184Z</updated>
    
    <content type="html"><![CDATA[<p>C语言简单而隐晦的角落。</p><a id="more"></a><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><p>scanf 遇到的字符不是当前内容时， 会把它放回原处，在扫描下一个输入项或下一次调用 scanf 时再试图读入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">float</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%f%f"</span>, &amp;i, &amp;j, &amp;x, &amp;y);</span><br></pre></td></tr></table></figure><p>Suppose that the user enters three lines of input:</p><blockquote><p>1-20.3-4.0e3</p></blockquote><ul><li>第一个转换符是 %d，第一个非空字符是 1，可以出现在整数中，下一个字符是 ”-“，scanf 认为它不应该出现在整数内部，所以把 “-” 放回原处，把 1 读入 i 。</li><li>第二个读入 -20 之后发现小数点，scanf 认为它不该出现在整数中，所以把 -20 读入 j 。</li><li>第三个读入 .3，发现负号不该出现在浮点数中间，所以把 0.3 读入 x 。</li><li>最后把 -4*10^3 读入 y，并把最后的换行符放回原处。</li></ul><p>在读取格式串时遇到任何空白字符，scanf 会跳过空白符直到遇到非空白符尝试读取。</p><p>如 <code>&quot;%d/%d&quot;</code> 格式串，输入<code>5/    96</code>，能够成功读取两个整数。</p><p>如输入<code>5  /    96</code>，则在读取 5 后无法匹配 <code>/</code>而把之后的所有留给下次 scanf 调用。</p><h2 id="的副作用（side-effect）"><a href="#的副作用（side-effect）" class="headerlink" title="+= 的副作用（side effect）"></a>+= 的副作用（side effect）</h2><p>如果 v 有副作用，那么 v += e 不等价于 v = v + e 。</p><p>因为 v += e 只会导致一次 v 的求值，而 v = v + e 有两次。</p><p>如 <code>a[i++] += 1</code> 只会导致 i 自增 1；</p><p>而 <code>a[i++] = a[i++] + 1</code> 导致 i 自增 2 。</p><h2 id="getchar"><a href="#getchar" class="headerlink" title="getchar"></a>getchar</h2><p>getchar(), putchar() faster than scanf and printf.</p><p><strong>idiom</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>) <span class="comment">/*skips rest of line*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) == <span class="string">' '</span>) <span class="comment">/*skips blanks*/</span></span><br></pre></td></tr></table></figure><p>如果混用 scanf 和 getchar，注意 scanf 读取剩下的字符（包括换行符）会被 getchar 读取。</p><h2 id="使用-lf-读取-double-型的值，用-f-进行显示"><a href="#使用-lf-读取-double-型的值，用-f-进行显示" class="headerlink" title="使用 %lf 读取 double 型的值，用 %f 进行显示"></a>使用 %lf 读取 double 型的值，用 %f 进行显示</h2><p>因为 printf 和 scanf 都没有限制参数个数，使用了可变长度参数列表。</p><p>当调用可变长度参数列表函数时编译器安排 float 自动转化成 double 型，所以 printf 无法区分 float 和 double，所以可以用 %f 表示 float 和 double。</p><p>但是 scanf 用指针指向变量，必须知道地址上存储的类型，否则如果 float 和 double 位模式不同，scanf 会存储错误的字节数量。</p><h2 id="typedef-优于宏定义"><a href="#typedef-优于宏定义" class="headerlink" title="typedef 优于宏定义"></a>typedef 优于宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR_TO_INT int *</span></span><br><span class="line">PTR_TO_INT p, q;</span><br><span class="line"><span class="comment">// int *p, q;</span></span><br><span class="line"><span class="comment">// typedef will be better</span></span><br></pre></td></tr></table></figure><h2 id="远离-1"><a href="#远离-1" class="headerlink" title="远离 1"></a>远离 1</h2><p>下标从 0 开始，注意数组的下标越界陷阱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">    a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可能会导致无限循环。因为 <code>a[10]</code>已经越界，如果变量 <code>i</code>如果储存在这块空间，则错误地把<code>i</code>赋值为 0，无限循环。</p><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>如果给定长度和初始化列表，列表长度为0 或超过长度都是非法的，如果小于长度，剩余位置自动初始化为 0 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">/*initial value: 1,2,0,0,0,0,0,0,0,0*/</span></span><br></pre></td></tr></table></figure><p><strong>多维数组初始化：</strong></p><ul><li>如果一行给出的列表不能填满该行，该行剩余填满 0 。</li><li>如果给出的列表行数不足数组行数，剩余行数全部填满 0 。</li><li>如果去掉大括号也可以，一旦填满一行，编译器自动去填下一行。（危险）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">               &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="comment">/* 1,2,0,0,</span></span><br><span class="line"><span class="comment">   1,2,3,4,</span></span><br><span class="line"><span class="comment">   0,0,0,0,</span></span><br><span class="line"><span class="comment">   0,0,0,0 */</span></span><br></pre></td></tr></table></figure><p>所以要全部初始化为 0 应该是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组和指针区别"><a href="#数组和指针区别" class="headerlink" title="数组和指针区别"></a>数组和指针区别</h2><ol><li><p>数组名不能被赋予新值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (*a != <span class="number">0</span>)</span><br><span class="line">    a++;<span class="comment">/*WRONG*/</span></span><br></pre></td></tr></table></figure></li><li><p><code>sizeof()</code>对数组名和指针效果不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len_of_a = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">/* len_of_a == 3 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line"><span class="keyword">int</span> len_of_p = <span class="keyword">sizeof</span>(p); <span class="comment">/* len_of_p == sizeof(int*) */</span></span><br></pre></td></tr></table></figure><p>sizeof 对普通指针计算一个指针在内存中的字节长度，这取决于机器。</p><p>sizeof 对数组名计算该数组在内存中的总字节长度，所以可以那样求得数组元素个数。</p></li></ol><h2 id="函数形式参数中-int-a-还是-int-a"><a href="#函数形式参数中-int-a-还是-int-a" class="headerlink" title="函数形式参数中 int *a 还是 int a[ ] ?"></a>函数形式参数中 int *a 还是 int a[ ] ?</h2><p>考虑到函数参数传入的是拷贝，<code>int *a</code> 和 <code>int a[]</code> 完全相同，即便后者形式好像是数组，实际上也是普通指针，没有任何数组名的特殊技能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);  <span class="comment">/*WRONG*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组型参数"><a href="#数组型参数" class="headerlink" title="数组型参数"></a>数组型参数</h2><p>传入一维数组时，不需要写长度，写了也没用。</p><p>传入多为数组时，只有第一维长度是不必要的。因为要让编译器知道一个元素长度到底是多少。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a[<span class="number">10</span>])</span></span>&#123;  <span class="comment">//OK</span></span><br><span class="line">    <span class="comment">/* equal to fun(int a[]) and fun(int* a) */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">10</span>])</span></span>&#123; <span class="comment">//correct</span></span><br><span class="line">    <span class="comment">/* because complier konws there are sizeof(int) * 10 </span></span><br><span class="line"><span class="comment">    bits between a[0] and a[1] */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* fun2(int a[][]) is WRONG */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="i-a"><a href="#i-a" class="headerlink" title="i [a] ???"></a>i [a] ???</h2><p>对编译器而言：<code>i[a] == *(i + a) == a[i]</code></p><h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h2><p>最后一个是空字符<code>/0</code>，其 ASCII 码为 0 ，而数字 <code>0</code> 的 ASCII 码为 48 。</p><h2 id="字符数组和数组指针"><a href="#字符数组和数组指针" class="headerlink" title="字符数组和数组指针"></a>字符数组和数组指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> date_arr[] = <span class="string">"Nov 20"</span>;</span><br><span class="line"><span class="keyword">char</span>* date_ptr = <span class="string">"Nov 20"</span>;</span><br></pre></td></tr></table></figure><ul><li><code>date_ptr</code>是指针变量，可以再指向其他值，<code>date_arr</code>不能。</li><li><code>date_ptr</code>指向的字符串是字面值，不可修改，<code>date_arr</code>可以随意修改。</li></ul><p>初始化字符数组时类似普通数组，若填不满空位添 0 ，超过限制就非法，但是不会检查最后是否有停止标识符<code>/0</code>。</p><p>考虑 <code>printf</code>和<code>scanf</code>第一个参数都是接受字符串常量，即该串的首地址。</p><h2 id="读写字符串"><a href="#读写字符串" class="headerlink" title="读写字符串"></a>读写字符串</h2><h3 id="printf-amp-amp-puts"><a href="#printf-amp-amp-puts" class="headerlink" title="printf &amp;&amp; puts"></a>printf &amp;&amp; puts</h3><p>printf 逐个读取字符，直到读到空字符，如果空字符丢失，继续读，知道在内存找到一个空字符为止。</p><p>puts 接受一个参数没有格式串，写完字符串后自动添加换行符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"abcdef"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.3s"</span>, str); <span class="comment">// abc</span></span><br><span class="line"><span class="built_in">puts</span>(str); <span class="comment">// abcdef</span></span><br></pre></td></tr></table></figure><h3 id="scanf-amp-amp-gets"><a href="#scanf-amp-amp-gets" class="headerlink" title="scanf &amp;&amp; gets"></a>scanf &amp;&amp; gets</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 11</span></span><br><span class="line"><span class="keyword">char</span> str[LEN];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line"><span class="comment">/* input: "   hello world"*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   str: 'h','e','l','l','o','\0', ...</span></span><br><span class="line"><span class="comment">   scanf never get string with space, skip blank and end at blank,</span></span><br><span class="line"><span class="comment">   and add '\0' automatically.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">gets(str); <span class="comment">//all will be recieved, but dangerous</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言简单而隐晦的角落。&lt;/p&gt;
    
    </summary>
    
      <category term="C Programming Language" scheme="https://fudonglai.github.io/categories/C-Programming-Language/"/>
    
    
  </entry>
  
  <entry>
    <title>KMP for Pattern Searching</title>
    <link href="https://fudonglai.github.io/2018/10/26/KMP-for-Pattern-Searching/"/>
    <id>https://fudonglai.github.io/2018/10/26/KMP-for-Pattern-Searching/</id>
    <published>2018-10-26T08:18:39.000Z</published>
    <updated>2018-12-22T15:26:59.248Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Question:</strong> Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p><p>KMP (Knuth-Morris-Pratt Algorithm) is a classic and yet notoriously hard-to-understand algorithm.Fortunately, I found some perspicuous explainations.</p><p>Here are both Brute-Force method and KMP algorithm.</p><a id="more"></a><h1 id="Brute-Force-Implement"><a href="#Brute-Force-Implement" class="headerlink" title="Brute-Force Implement"></a>Brute-Force Implement</h1><p>It’s easy. Code is here:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (haystack.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> h = haystack.length(), n = needle.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= h - n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle.front())&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n &amp;&amp; haystack[i + j] == needle[j]; ++j)</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">if</span> (j == n)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The worst case complexity of the naive algorithm is $O(m(n-m+1))$. </p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">text[] = <span class="string">"AAAAAAAAAAAAAAAAAB"</span></span><br><span class="line">pattern[] = <span class="string">"AAAAB"</span></span><br><span class="line"><span class="comment">/*the worst case*/</span></span><br><span class="line"></span><br><span class="line">txt[] = <span class="string">"ABABABCABABABCABABABC"</span></span><br><span class="line">pat[] =  <span class="string">"ABABAC"</span> </span><br><span class="line"><span class="comment">/*not a worst case, but a bad case for Naive*/</span></span><br></pre></td></tr></table></figure><p>But the time complexity of KMP algorithm is $O(n)$ in the worst case. Of course, you need some extra space to preprocess the pattern.</p><p>Then you  can challenge yourself implement the KMP algorithm for this problem.</p><h1 id="KMP-Algorithm"><a href="#KMP-Algorithm" class="headerlink" title="KMP Algorithm"></a>KMP Algorithm</h1><p>You can refer to them for the detials:</p><ol><li>KMP on <a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="noopener">Jake Boxer’s Blog</a></li><li>KMP on <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/" target="_blank" rel="noopener">Geeks-for-Geeks</a></li></ol><h2 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h2><h3 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h3><p>Whenever we detect a mismatch (after some matches), we already know some of the characters in the text of the next window. We take advantage of this information to avoid matching the characters that we know will anyway match. </p><p>To know how many characters we can skip, we pre-process pattern and get an integer array that tells us the count of characters to be skipped. </p><h3 id="The-Partial-Match-Table"><a href="#The-Partial-Match-Table" class="headerlink" title="The Partial Match Table"></a>The Partial Match Table</h3><p>Here I want to quote <a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="noopener">Jake Boxer’s perspicuous explaination</a>.</p><p>Here’s the partial match table for the pattern “abababca”:</p><table><thead><tr><th>char</th><th>a</th><th>b</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>a</th></tr></thead><tbody><tr><td>index</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>value</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>0</td><td>1</td></tr></tbody></table><blockquote><p><strong>Proper prefix</strong>: All the characters in a string, with one or more cut off the end. “S”, “Sn”, “Sna”, and “Snap” are all the proper prefixes of “Snape”.</p><p><strong>Proper suffix</strong>: All the characters in a string, with one or more cut off the beginning. “agrid”, “grid”, “rid”, “id”, and “d” are all proper suffixes of “Hagrid”.</p><p>Here, we’re interested in the first four characters (“abab”). We have three proper prefixes (“a”, “ab”, and “aba”) and three proper suffixes (“b”, “ab”, and “bab”). This time, “ab” is in both, and is two characters long, so cell four gets value 2.</p><p>let’s also try it for cell five, which concerns “ababa”. We have four proper prefixes (“a”, “ab”, “aba”, and “abab”) and four proper suffixes (“a”, “ba”, “aba”, and “baba”). Now, we have two matches: “a” and “aba” are both proper prefixes and proper suffixes. Since “aba” is longer than “a”, it wins, and cell five gets value 3.</p><p>Let’s skip ahead to cell seven (the second-to-last cell), which is concerned with the pattern “abababc”. Even without enumerating all the proper prefixes and suffixes, it should be obvious that there aren’t going to be any matches; all the suffixes will end with the letter “c”, and none of the prefixes will. Since there are no matches, cell seven gets 0.</p></blockquote><h2 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h2><p>quote <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/" target="_blank" rel="noopener">Geeks-for-Geeks</a>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lps[i] = the longest proper prefix of pat[<span class="number">0.</span>.i] </span><br><span class="line">which is also a suffix of pat[<span class="number">0.</span>.i]. </span><br><span class="line">         </span><br><span class="line">Examples of lps[] construction:</span><br><span class="line"></span><br><span class="line">For the pattern “AAAA”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">For the pattern “ABCDE”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">For the pattern “AABAACAABAA”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">For the pattern “AAACAAAAAC”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>] </span><br><span class="line"></span><br><span class="line">For the pattern “AAABAAA”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="Preprocessing-Algorithm"><a href="#Preprocessing-Algorithm" class="headerlink" title="Preprocessing Algorithm"></a>Preprocessing Algorithm</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pat[] = <span class="string">"AAACAAAA"</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">0.</span></span><br><span class="line">lps[<span class="number">0</span>] <span class="keyword">is</span> always <span class="number">0</span>, we move </span><br><span class="line">to i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">1.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">1</span>, lps[<span class="number">1</span>] = <span class="number">1</span>, i = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">1</span>, i  = <span class="number">2.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">2</span>, lps[<span class="number">2</span>] = <span class="number">2</span>, i = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">2</span>, i  = <span class="number">3.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match, <span class="keyword">and</span> len &gt; <span class="number">0</span>, </span><br><span class="line">set len = lps[len<span class="number">-1</span>] = lps[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">1</span>, i  = <span class="number">3.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match <span class="keyword">and</span> len &gt; <span class="number">0</span>, </span><br><span class="line">len = lps[len<span class="number">-1</span>] = lps[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">3.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match <span class="keyword">and</span> len = <span class="number">0</span>, </span><br><span class="line">Set lps[<span class="number">3</span>] = <span class="number">0</span> <span class="keyword">and</span> i = <span class="number">4.</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">4.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">1</span>, lps[<span class="number">4</span>] = <span class="number">1</span>, i = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">1</span>, i  = <span class="number">5.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">2</span>, lps[<span class="number">5</span>] = <span class="number">2</span>, i = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">2</span>, i  = <span class="number">6.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">3</span>, lps[<span class="number">6</span>] = <span class="number">3</span>, i = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">3</span>, i  = <span class="number">7.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match <span class="keyword">and</span> len &gt; <span class="number">0</span>,</span><br><span class="line">set len = lps[len<span class="number">-1</span>] = lps[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">2</span>, i  = <span class="number">7.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">3</span>, lps[<span class="number">7</span>] = <span class="number">3</span>, i = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">We stop here <span class="keyword">as</span> we have constructed the whole lps[].</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Here is my preprocessing code:</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; generator(<span class="built_in">string</span> pattern)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lps(pattern.size());</span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pattern.size(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[len])&#123;</span><br><span class="line">            len++;</span><br><span class="line">            lps[i] = len;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">                len = lps[len - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                len = <span class="number">0</span>; i++;</span><br><span class="line">            &#125;<span class="comment">//else</span></span><br><span class="line">        &#125;<span class="comment">//else</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> lps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Matching-Algorithm"><a href="#Matching-Algorithm" class="headerlink" title="Matching Algorithm"></a>Matching Algorithm</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (haystack.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lps = generator(needle);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.size(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle[j])&#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j = lps[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;&#125;</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; Return the index of the first occurrence of needle in haystack, or &lt;strong&gt;-1&lt;/strong&gt; if needle is not part of haystack.&lt;/p&gt;
&lt;p&gt;KMP (Knuth-Morris-Pratt Algorithm) is a classic and yet notoriously hard-to-understand algorithm.Fortunately, I found some perspicuous explainations.&lt;/p&gt;
&lt;p&gt;Here are both Brute-Force method and KMP algorithm.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="patern search" scheme="https://fudonglai.github.io/tags/patern-search/"/>
    
  </entry>
  
  <entry>
    <title>Fundamental DP Problem</title>
    <link href="https://fudonglai.github.io/2018/10/26/Fundamental-DP-Problem/"/>
    <id>https://fudonglai.github.io/2018/10/26/Fundamental-DP-Problem/</id>
    <published>2018-10-26T02:52:13.000Z</published>
    <updated>2018-10-26T06:14:42.158Z</updated>
    
    <content type="html"><![CDATA[<p>There is an interesting problem in LeetCode: <a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">Unique Paths</a>.</p><p>I found some pespicuous explaination in the comments.</p><a id="more"></a><h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><blockquote><p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid.</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid.</p><p>How many possible unique paths are there?</p></blockquote><h3 id="Observations"><a href="#Observations" class="headerlink" title="Observations:"></a>Observations:</h3><p>Since the robot can only move right and down, when it arrives at a point, there are only two possibilities:</p><ol><li>It arrives at that point from above (moving down to that point);</li><li>It arrives at that point from left (moving right to that point).</li></ol><p>Thus we have the following equations: $Approach(i, j)=Approach(i - 1, j) + Approach(i, j-1)$</p><p><img src="http://ph6w748rg.bkt.clouddn.com/18-10-26/15711693.jpg" alt="picture"></p><p>The boundary conditions of the above equation have some problems at the leftmost column and the uppermost row due to $(0, j)$ and $(i, 0)$ do not exist. To oversmart the problem automatically,  it’s easier that we initialize the array to something like following:</p><p><img src="http://ph6w748rg.bkt.clouddn.com/18-10-26/36462436.jpg" alt="picture"></p><h3 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h3><p>So, here is my codes:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; ++j) </span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][j - <span class="number">1</span>] + <span class="built_in">map</span>[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>As can be seen, the above solution runs in $O(n^2)$ time and costs $O(m*n)$ space.</p><p>But we find that each time we update the <code>map[i][j]</code>, we only need to consider the current column(for <code>map[i-1, j]</code>) and the previous column(for <code>map[i, j-1]</code>), so only two vector can be enough.</p><p>Here is new codes:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c1(m + <span class="number">1</span>, <span class="number">0</span>), c2(c1);</span><br><span class="line">        c1[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                c2[j] = c1[j] + c2[j - <span class="number">1</span>];</span><br><span class="line">            c1 = c2;</span><br><span class="line">            c2 = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c1[m];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Further inspecting the above code, we find it needs $O(m)$ space, but if $n&lt;m$, should I convert to $O(n)$ space? And we find that <code>vector c2</code>will convert to zero in every loop, so the operation is actually <code>c1[i] += c1[i-1]</code>. Now we can implement a more efficient approach:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">           <span class="keyword">return</span> uniquePaths(n, m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(m, <span class="number">0</span>);</span><br><span class="line">        c[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - <span class="number">1</span>; ++j) </span><br><span class="line">                c[j] += c[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> c[m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Now it is prefect, how interesting it is!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;There is an interesting problem in LeetCode: &lt;a href=&quot;https://leetcode.com/problems/unique-paths/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Unique Paths&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I found some pespicuous explaination in the comments.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="dynamic programming" scheme="https://fudonglai.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Non-Repeating Longest Substring</title>
    <link href="https://fudonglai.github.io/2018/10/20/Non-Repeating-longest-substring/"/>
    <id>https://fudonglai.github.io/2018/10/20/Non-Repeating-longest-substring/</id>
    <published>2018-10-20T10:24:49.000Z</published>
    <updated>2018-10-26T13:01:00.989Z</updated>
    
    <content type="html"><![CDATA[<p>An ingenuity to use map to solve Substring.</p><a id="more"></a><h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><blockquote><p>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3. </p></blockquote><p>###Solution</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> * Solution (DP, O(n)):</span><br><span class="line"> * </span><br><span class="line"> * Assume L[i] = s[m...i], denotes the longest substring without repeating</span><br><span class="line"> * characters that ends up at s[i], <span class="keyword">and</span> we keep a hashmap <span class="keyword">for</span> every</span><br><span class="line"> * characters between m ... i, <span class="keyword">while</span> storing &lt;character, index&gt; in the</span><br><span class="line"> * hashmap.</span><br><span class="line"> * We know that each character will appear only once.</span><br><span class="line"> </span><br><span class="line"> * Then to find s[i+<span class="number">1</span>]:</span><br><span class="line"> * <span class="number">1</span>) <span class="keyword">if</span> s[i+<span class="number">1</span>] does <span class="keyword">not</span> appear in hashmap</span><br><span class="line"> *    we can just add s[i+<span class="number">1</span>] to hash <span class="built_in">map</span>. <span class="keyword">and</span> L[i+<span class="number">1</span>] = s[m...i+<span class="number">1</span>]</span><br><span class="line"> * <span class="number">2</span>) <span class="keyword">if</span> s[i+<span class="number">1</span>] exists in hashmap, <span class="keyword">and</span> the hashmap value (the index) is k</span><br><span class="line"> *    let m = max(m, k), then L[i+<span class="number">1</span>] = s[m...i+<span class="number">1</span>], we also need to update</span><br><span class="line"> *    entry in hashmap to mark the latest occurency of s[i+<span class="number">1</span>].</span><br><span class="line"> * </span><br><span class="line"> * Since we scan the <span class="built_in">string</span> <span class="keyword">for</span> only once, <span class="keyword">and</span> the <span class="string">'m'</span> will also move from</span><br><span class="line"> * beginning to end <span class="keyword">for</span> at most once. Overall complexity is O(n).</span><br><span class="line"> *</span><br><span class="line"> * If characters are all in ASCII, we could use <span class="built_in">array</span> to mimic hashmap.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> lengthOfLongestSubstring(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dict(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            m = max(m, dict[s[i]] + <span class="number">1</span>);</span><br><span class="line">            dict[s[i]] = i;</span><br><span class="line">            len = max(len, i - m + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Complement"><a href="#Complement" class="headerlink" title="Complement"></a>Complement</h3><p>Now I’ve meet some point of it:</p><ul><li>ASSIC uses one byte to encode, $2^{8}=256$, so we can regard a 256-size vector as a hashtable. The ASSIC of character will be key, its index will be value.</li><li><p>Remeber, every value in <code>dict</code> which not equals $-1$ represents the element’s index clostest to $i$’th element. </p></li><li><p>If all the character is unique, $m$ always equals 0, longest length will increase one by one.</p></li><li>If  encount a character repeates, then we compare $m$ and the index. If $m$ is greater than index, it means the element occured in a substring before, but no big deal for current substring count. If $m$ is less than index, it means the current substring can’t be longer any more, so $m$ will update to the index.</li><li>In other word, every time we update $m$ , we actually find a substring, which is <code>string[m: i]</code>.</li><li>As for varaible <code>len</code>, it compares every loop. Only when current substring <code>i - m + 1</code>longer than before, it will update to a large length.</li></ul><p>I think the partern of solution can have a double pointer expension.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;An ingenuity to use map to solve Substring.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Substring" scheme="https://fudonglai.github.io/tags/Substring/"/>
    
  </entry>
  
  <entry>
    <title>Think Recursively</title>
    <link href="https://fudonglai.github.io/2018/10/18/Think-Recursively/"/>
    <id>https://fudonglai.github.io/2018/10/18/Think-Recursively/</id>
    <published>2018-10-18T11:12:34.000Z</published>
    <updated>2018-10-26T05:53:33.297Z</updated>
    
    <content type="html"><![CDATA[<h3 id="“Top-down”-Solution"><a href="#“Top-down”-Solution" class="headerlink" title="“Top-down” Solution"></a>“Top-down” Solution</h3><p>When you meet a tree problem, ask yourself two questions: </p><ul><li>Can you determine some parameters to help the node know the answer of itself? </li><li>Can you use these parameters and the value of the node itself to determine what should be the parameters parsing to its children? </li></ul><a id="more"></a><p> If the answers are both <strong>yes</strong>, try to solve this problem using a “top-down” recursion solution.</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> answer;       <span class="comment">// don't forget to initialize answer before call maximum_depth</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maximum_depth</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        answer = max(answer, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    maximum_depth(root-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">    maximum_depth(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="“Bottom-up”-Solution"><a href="#“Bottom-up”-Solution" class="headerlink" title="“Bottom-up” Solution"></a>“Bottom-up” Solution</h3><p>Or you can think the problem in this way: </p><p>for a node in a tree, if you know the answer of its children, can you calculate the answer of the node? </p><p>If the answer is yes, solving the problem recursively from bottom up might be a good way.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum_depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;                                   <span class="comment">// return 0 for null node</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left_depth = maximum_depth(root.left);</span><br><span class="line"><span class="keyword">int</span> right_depth = maximum_depth(root.right);</span><br><span class="line"><span class="keyword">return</span> Math.max(left_depth, right_depth) + <span class="number">1</span>;<span class="comment">// return depth of the subtree rooted at root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;“Top-down”-Solution&quot;&gt;&lt;a href=&quot;#“Top-down”-Solution&quot; class=&quot;headerlink&quot; title=&quot;“Top-down” Solution&quot;&gt;&lt;/a&gt;“Top-down” Solution&lt;/h3&gt;&lt;p&gt;When you meet a tree problem, ask yourself two questions: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Can you determine some parameters to help the node know the answer of itself? &lt;/li&gt;
&lt;li&gt;Can you use these parameters and the value of the node itself to determine what should be the parameters parsing to its children? &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Recurive" scheme="https://fudonglai.github.io/tags/Recurive/"/>
    
  </entry>
  
</feed>
