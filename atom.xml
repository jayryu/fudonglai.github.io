<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿东的算法笔记</title>
  
  <subtitle>Down to earth. &lt;br&gt;Being towards death.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fudonglai.github.io/"/>
  <updated>2019-01-11T03:13:06.950Z</updated>
  <id>https://fudonglai.github.io/</id>
  
  <author>
    <name>付东来</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序I - 归并 &amp; 快排</title>
    <link href="https://fudonglai.github.io/2019/01/10/Quick-Merge-Sort/"/>
    <id>https://fudonglai.github.io/2019/01/10/Quick-Merge-Sort/</id>
    <published>2019-01-10T11:03:18.000Z</published>
    <updated>2019-01-11T03:13:06.950Z</updated>
    
    <content type="html"><![CDATA[<p>最经又刷了不少算法题，啃了啃《算法导论》，觉得很多算法光写而不拿出来总结，还是不能体会出精髓，于是将自己吸收的东西总结一下，力求能让其他人都看懂。同时练习一下 C++ 泛型编程，写成泛型算法。</p><a id="more"></a><h1 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h1><p>归并排序，典型的分治算法；分治，典型的递归结构。</p><p>分治算法可以分三步走：分解 -&gt; 解决 -&gt; 合并</p><ol><li>分解原问题为结构相同的子问题。</li><li>分解到某个容易求解的边界之后，进行第归求解。</li><li>将子问题的解合并成原问题的解。</li></ol><p><strong>递归</strong> 并不是一种算法，而只是一种编程技巧，例如在分治算法的第二步，很容易看出递归结构，所以分治算法都是由递归实现的。关于递归，我会抽时间专门写一篇文章，从数学和计算机的角度来简单分析一下。</p><p>这里只说一点我编写递归代码的心得：<strong>递归函数只做一件事，并且你相信它一定能做好</strong>，千万不要跳进这个函数里面企图探究更多细节，否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。就举个最简单的例子：遍历二叉树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    traverse(root-&gt;left);</span><br><span class="line">    traverse(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几行代码就足以扫荡任何一棵二叉树了。我想说的是，对于递归函数<code>traverse(root)</code>，我们只要相信：给它一个根节点<code>root</code>，它就能遍历这棵树，因为写这个函数不就是为了这个目的吗？所以我们只需要把这个节点的左右节点再甩给这个函数就行了，因为我相信它能完成任务的。那么遍历一棵N叉数呢？太简单了好吧，和二叉树一模一样啊。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (child : root-&gt;children)</span><br><span class="line">        traverse(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于遍历的什么前、中、后序，那都是显而易见的，对于N叉树，显然没有中序遍历。</p><p>写了这么多题外话，就是让你记住，<strong>明确写出来的这个函数的职责，并且相信它一定能完成</strong>，这样就能看懂，甚至随手写出漂亮的递归代码了。在之后的<a href="">回溯算法</a>，<a href="">动态规划</a>中还会有大量算法由递归实现。现在言归正传。</p><p>归并排序，我们就叫这个函数<code>merge_sort</code>吧，按照我们上面说的，要明确该函数的职责，即<strong>对传入的一个数组排序</strong>。OK，那么这个问题能不能分解呢？当然可以！给一个数组排序，不就等于给该数组的两半分别排序，然后合并就完事了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(一个数组)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (可以很容易处理) <span class="keyword">return</span>;</span><br><span class="line">    merge_sort(左半个数组);</span><br><span class="line">    merge_sort(右半个数组);</span><br><span class="line">    merge(左半个数组, 右半个数组);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这个算法也就这样了，完全没有任何难度。记住之前说的，相信函数的能力，传给他半个数组，那么这半个数组就已经被排好了。而且你会发现这不就是个二叉树遍历模板吗？为什么是后序遍历？因为我们分治算法的套路是 <strong>分解 -&gt; 解决（触底） -&gt; 合并（回溯）</strong> 啊，先左右分解，再处理合并，回溯就是在退栈，就相当于后序遍历了。至于<code>merge</code>函数，参考两个有序链表的合并，简直一模一样，下面直接贴代码吧。</p><p>注意三点就行：</p><ol><li>我给每一半数组的最后一位添加了一个哨兵位，理论上应该是正无穷，这里用INT_MAX代替。</li><li>形参 <code>begin</code>, <code>end</code>参考 C++ 迭代器，取左闭右开区间，即数组范围在 <code>[begin, end)</code>。</li><li><code>pivot = begin + (end - begin) / 2</code>实际上就是取中值，防止溢出罢了。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">    merge_sort(nums, begin, pivot);</span><br><span class="line">    merge_sort(nums, pivot, end);</span><br><span class="line">    merge(nums, begin, pivot, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> pivot, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(nums.begin() + begin, nums.begin() + pivot);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(nums.begin() + pivot, nums.begin() + end);</span><br><span class="line">    left.push_back(INT_MAX);</span><br><span class="line">    right.push_back(INT_MAX);</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[p] &lt; right[q]) &#123;</span><br><span class="line">            nums[i] = left[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[i] = right[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h1><p>之所以把快速排序和归并排序放在一起，因为他俩很像，尤其是算法框架上，但是区别也很明显：</p><ol><li>归并排序是典型的分治思想，遵循 分解 -&gt; 处理 -&gt; 合并 的模式，<strong>观察归并代码，递归调用是在分解问题，<code>merge</code>函数兼顾处理和合并操作。</strong>快排不是分治的模式，而是遵行 <strong>预处理 -&gt; 分解 -&gt; 回溯</strong> 的模式，关键在于预处理阶段，<code>partition</code>函数能够将一个元素放到正确的位置，并将数组分成两半。</li><li>观察函数执行的过程，归并排序是从左到右或从右到左形成有序，而快速排序是单点突破，每次递归都会将某个元素排好，放到它的最终位置，而这个元素的选择是随机的，并没有什么规律。</li></ol><p>快排的<strong>关键点在于<code>partition</code>函数，返回划分点的索引，并使该点左侧的值都小于该点，右侧都大于该点</strong>。</p><p>划分完成后，再对这两半数组递归调用<code>quick_sort</code>函数即可。所以这个框架看起来像这个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(数组)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (没办法再分了) <span class="keyword">return</span>;</span><br><span class="line">    划分点 = partition(数组);</span><br><span class="line">    quick_sort(划分点左边的数组);</span><br><span class="line">    quick_sort(划分点右边的数组);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是个前序遍历二叉树嘛，至于为什么，你应该能猜出来了。<code>partition</code>函数就不好形容了，直接看代码好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> pivot, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    swap(nums[end - <span class="number">1</span>], nums[pivot]);</span><br><span class="line">    <span class="keyword">int</span> i = begin - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = begin; j &lt; end - <span class="number">1</span>; j++) &#123; <span class="comment">//!!!!!!!!!!</span></span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt; nums[end - <span class="number">1</span>])</span><br><span class="line">            swap(nums[++i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums[end - <span class="number">1</span>], nums[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end - begin &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> partitioned = partition(nums, begin, end - <span class="number">1</span>, end);</span><br><span class="line">    quick_sort(nums, begin, partitioned);</span><br><span class="line">    quick_sort(nums, partitioned + <span class="number">1</span>, end); <span class="comment">//!!!!!!!!!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打感叹号的地方尤其需要注意，<code>j=begin</code>, <code>partitioned + 1</code>, 这两个地方我没注意，调了半天 bug 。</p><p>记住递归调用的时候是传入划分点左右的数组，<strong>不包括划分点本身！</strong>否则算法就会无限递归下去。</p><p>最后放一个 C++ 写的快排泛型算法，参照 Github 上的项目编写（泛型写起来麻烦点，但是用起来真香）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SortAlgorithm &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> CompareType=<span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::value_type&gt;&gt;</span><br><span class="line">    Iterator partition(<span class="keyword">const</span> Iterator begin, <span class="keyword">const</span> Iterator end, <span class="keyword">const</span> Iterator pivot_iter,</span><br><span class="line">                       CompareType compare = CompareType()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> size = <span class="built_in">std</span>::distance(begin, end);</span><br><span class="line">        assert(size &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> end;</span><br><span class="line">        assert(<span class="built_in">std</span>::distance(begin, pivot_iter) &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">std</span>::distance(pivot_iter, end) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> smaller_next = begin;</span><br><span class="line">        <span class="keyword">auto</span> current = begin;</span><br><span class="line">        <span class="keyword">while</span> (current != end - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compare(*current, *(end - <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(*current, *smaller_next);</span><br><span class="line">                smaller_next++;</span><br><span class="line">            &#125;</span><br><span class="line">            current++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::swap(*smaller_next, *(end - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> smaller_next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> CompareType=<span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::value_type&gt;&gt;</span><br><span class="line">    <span class="keyword">void</span> quick_sort(<span class="keyword">const</span> Iterator begin, <span class="keyword">const</span> Iterator end, CompareType compare = CompareType()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> size = <span class="built_in">std</span>::distance(begin, end);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> partitioned_iter = partition(begin, end, end - <span class="number">1</span>, compare); <span class="comment">//end-1 as pivot</span></span><br><span class="line">        quick_sort(begin, partitioned_iter, compare);</span><br><span class="line">        quick_sort(partitioned_iter + <span class="number">1</span>, end, compare);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最经又刷了不少算法题，啃了啃《算法导论》，觉得很多算法光写而不拿出来总结，还是不能体会出精髓，于是将自己吸收的东西总结一下，力求能让其他人都看懂。同时练习一下 C++ 泛型编程，写成泛型算法。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Sort" scheme="https://fudonglai.github.io/tags/Sort/"/>
    
      <category term="算法导论" scheme="https://fudonglai.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数组旋转算法</title>
    <link href="https://fudonglai.github.io/2018/12/23/Rotate-Array/"/>
    <id>https://fudonglai.github.io/2018/12/23/Rotate-Array/</id>
    <published>2018-12-23T05:19:18.000Z</published>
    <updated>2018-12-23T07:01:15.558Z</updated>
    
    <content type="html"><![CDATA[<p>交换数组的两个区域很简单吗？</p><p>以下给出链表解法，递归解法，连续翻转，杂技解法。</p><a id="more"></a><p>题目和图片来自 <a href="https://leetcode.com/explore/featured/card/top-interview-questions-easy/92/array/646/" target="_blank" rel="noopener">LeetCode</a>。</p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h2><p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7] and k = 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class="line">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class="line">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [-1,-100,3,99] and k = 2</span><br><span class="line">Output: [3,99,-1,-100]</span><br><span class="line">Explanation: </span><br><span class="line">rotate 1 steps to the right: [99,-1,-100,3]</span><br><span class="line">rotate 2 steps to the right: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><h2 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection:"></a>Reflection:</h2><p>这个问题实际上可以简化为如何交换数组的两部分，但是在思维模式上还是有差别，那么首先按照题目的意思，Rotate 一个数组，相当于循环位移每个元素？显然对于数组来说，看起来简单的整体移动涉及大量数据搬移，可以说非常低效。数组要是能连接成一个环就好了？那我用链表造个环不就完事了。</p><p>抛开循环移动这个思维，<code>Rotate</code>这个操作的结果不就是把数组某个节点两边数据交换了一下吗？这个操作看起来也好简单啊，swap 就完了？但是事实好像并没有这么简单。</p><h2 id="Approach-I-Cycle-Linked-List"><a href="#Approach-I-Cycle-Linked-List" class="headerlink" title="Approach I: Cycle Linked List"></a>Approach I: Cycle Linked List</h2><p><strong>Time Complexity: O(n), Space Complexity: O(n)</strong></p><p>我们创造一个环链表，记住开头元素位置，然后走相应步数之后，把这个地方作为开头，读取环链表，得到的就是结果了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode *p = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> ListNode(n);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = head-&gt;next;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> step = nums.size() - k % nums.size();</span><br><span class="line">    <span class="keyword">while</span> (step--) p = p-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        nums[i] = p-&gt;val;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-II-Recursion"><a href="#Approach-II-Recursion" class="headerlink" title="Approach II: Recursion"></a>Approach II: Recursion</h2><p><strong>Time Complexity: O(n), Space Complexity: O(n)</strong></p><p>抛开整体移动，直接粗暴地交换元素的话，两个区域长度相同的话直接<code>swap</code> n/2 次就完全交换了，但是如果两个区域长度不同，长的那部分就会有剩余，该剩余区域还需要和长区域经过交换的那个区域交换，以还原长区域的原始顺序，然后这个交换过程又会产生长短不一的问题，然后请重新阅读这段话。</p><p>子问题和原问题结构完全相同，规模更小，明显的递归结构，结束边界就是两个区域长度相等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursiveSwap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    k %= length;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) </span><br><span class="line">        swap(nums[start + i], nums[nums.size() - k + i]);</span><br><span class="line">    recursiveSwap(nums, k, start + k, length - k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度是最坏情况，也就是交换<code>nums[0]</code>和<code>nums[1...size-1]</code>的极端情况。</p><p>写出该递归数学形式，求解封闭解，可以把该函数改为封闭递推形式：</p><p><strong>Time Complexity: O(n), Space Complexity: O(1)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span> (; k %= n; n -= k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            swap(nums[i], nums[n - k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于递归式求解封闭解，需要数学技巧，并且写出来的代码基本看不懂，不会就算了。</p><h2 id="Approach-III-Magic-Method"><a href="#Approach-III-Magic-Method" class="headerlink" title="Approach III: Magic Method"></a>Approach III: Magic Method</h2><p><strong>Time Complexity: O(n), Space Complexity: O(1)</strong></p><p>类似链表解法，但是不需要额外的链表节点表示，直接在数组上进行跳跃。反正描述不清楚，看代码自行体会一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums: [1, 2, 3, 4, 5, 6]</span><br><span class="line">k: 2</span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/media/original_images/189_Rotate_Array.png" alt="example"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; step &lt; nums.size(); start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = start;</span><br><span class="line">            <span class="keyword">int</span> prev_val = nums[start];</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> next = (curr + k) % nums.size();</span><br><span class="line">                <span class="keyword">int</span> temp = nums[next];</span><br><span class="line">                nums[next] = prev_val;</span><br><span class="line">                prev_val = temp;</span><br><span class="line">                curr = next;</span><br><span class="line">                step++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (curr != start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-IV-KISS"><a href="#Approach-IV-KISS" class="headerlink" title="Approach IV: KISS"></a>Approach IV: KISS</h2><p><strong>Time Complexity: O(n), Space Complexity: O(1)</strong></p><p>只有看到这里的真的猛士才配拥有真正的终极算法。</p><p>交换两段数据？只要分别反转这两段，再把整个数组反转就行了，不信自己数一数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Keep it simple, stupid.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        reverse(nums.begin(), nums.begin() + n - k);</span><br><span class="line">        reverse(nums.begin() + n - k, nums.end());</span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;交换数组的两个区域很简单吗？&lt;/p&gt;
&lt;p&gt;以下给出链表解法，递归解法，连续翻转，杂技解法。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Recursion" scheme="https://fudonglai.github.io/tags/Recursion/"/>
    
      <category term="Array" scheme="https://fudonglai.github.io/tags/Array/"/>
    
      <category term="LinkedList" scheme="https://fudonglai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>深度复制随机链表</title>
    <link href="https://fudonglai.github.io/2018/12/22/deepCopyRandomLink/"/>
    <id>https://fudonglai.github.io/2018/12/22/deepCopyRandomLink/</id>
    <published>2018-12-22T15:03:31.000Z</published>
    <updated>2018-12-22T15:12:00.952Z</updated>
    
    <content type="html"><![CDATA[<p>以下有三种常规解决方案，和一种杂技解法。</p><p>Best Approach: Time Complexity O(n), Space Complexity O(1).</p><a id="more"></a><p><strong>题目及图片均源于 <a href="https://leetcode.com/explore/interview/card/top-interview-questions-hard/117/linked-list/841/]" target="_blank" rel="noopener">LeetCode</a> </strong>。</p><p>题目：给一个链表，这个链表有点特殊，即每个节点还包含一个随机指针，随机指向链表中的某一个节点，请你深度复制（DeepCopy）这个链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * class RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode next, random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) &#123; this.label = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/problems/copy-list-with-random-pointer/Figures/138/138_Copy_List_Random_1.png" alt="RandomLinkedList"></p><p>首先想到，这随机链表不就是个图吗？首先就想到 <a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">Clone Graph</a>，最起码有深度优先和广度优先两种方法。</p><h2 id="Approach-I-DFS"><a href="#Approach-I-DFS" class="headerlink" title="Approach I: DFS"></a>Approach I: DFS</h2><p><strong>Time Complexity O(n), Space Complexity O(n)</strong></p><p>递归实现简单易懂，确定边界条件，然后调用自己就完事了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;RandomListNode, RandomListNode&gt;</span><br><span class="line">        visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span> (visited.containsKey(head)) <span class="keyword">return</span> visited.get(head);</span><br><span class="line">        RandomListNode cp = <span class="keyword">new</span> RandomListNode(head.label);</span><br><span class="line">        visited.put(head, cp);</span><br><span class="line">        cp.next = copyRandomList(head.next);</span><br><span class="line">        cp.random = copyRandomList(head.random);</span><br><span class="line">        <span class="keyword">return</span> cp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-II-BFS"><a href="#Approach-II-BFS" class="headerlink" title="Approach II: BFS"></a>Approach II: BFS</h2><p><strong>Time Complexity O(n), Space Complexity O(n)</strong></p><p>这段是我用 C++ 写的，借鉴图克隆的算法，可以说都是一套模板了，个人认为没有递归舒服。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;RandomListNode*, RandomListNode*&gt; <span class="built_in">map</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;RandomListNode*&gt; q;</span><br><span class="line">        q.push(head);</span><br><span class="line">        <span class="built_in">map</span>[head] = <span class="keyword">new</span> RandomListNode(head-&gt;label);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> front = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;next &amp;&amp; <span class="built_in">map</span>.find(front-&gt;next) == <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                <span class="built_in">map</span>[front-&gt;next] = <span class="keyword">new</span> RandomListNode(front-&gt;next-&gt;label);</span><br><span class="line">                q.push(front-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;random &amp;&amp; <span class="built_in">map</span>.find(front-&gt;random) == <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                <span class="built_in">map</span>[front-&gt;random] = <span class="keyword">new</span> RandomListNode(front-&gt;random-&gt;label);</span><br><span class="line">                q.push(front-&gt;random);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>[front]-&gt;random = <span class="built_in">map</span>[front-&gt;random];</span><br><span class="line">            <span class="built_in">map</span>[front]-&gt;next = <span class="built_in">map</span>[front-&gt;next];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[head];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-III-Double-Pointer"><a href="#Approach-III-Double-Pointer" class="headerlink" title="Approach III: Double Pointer"></a>Approach III: Double Pointer</h2><p><strong>Time Complexity O(n), Space Complexity O(n)</strong></p><p>常规方法吧，类似双指针同步操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;RandomListNode, RandomListNode&gt;</span><br><span class="line">        visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> RandomListNode <span class="title">getCloneNode</span><span class="params">(RandomListNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span> (!visited.containsKey(node))</span><br><span class="line">            visited.put(node, <span class="keyword">new</span> RandomListNode(node.label));</span><br><span class="line">        <span class="keyword">return</span> visited.get(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        RandomListNode oldNode = head;</span><br><span class="line">        RandomListNode newNode = getCloneNode(head);</span><br><span class="line">        <span class="keyword">while</span> (oldNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            newNode.next = getCloneNode(oldNode.next);</span><br><span class="line">            newNode.random = getCloneNode(oldNode.random);</span><br><span class="line">            oldNode = oldNode.next;</span><br><span class="line">            newNode = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-IV：Magic-Method"><a href="#Approach-IV：Magic-Method" class="headerlink" title="Approach IV：Magic Method"></a>Approach IV：Magic Method</h2><p><strong>Time Complexity O(n), Space Complexity O(1)</strong></p><p>比较难想到，竟然不需要额外存储空间来记录已生成的节点？</p><p>本方法分为两步走：</p><ol><li><p>克隆原节点的 next 域和 random 域，然后将克隆的节点（cloned）放到原始节点（original）之后，此处需要链表插入操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cloned.next = original.next</span><br><span class="line">original.next = cloned</span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/articles/Figures/138/138_Copy_List_Random_9_1.png" alt="step1"></p></li><li>解开 cloned 和 original 的连接，分为两条链表，完成复制。</li></ol><p><img src="https://leetcode.com/articles/Figures/138/138_Copy_List_Random_10.png" alt="step2"></p><p>Java 代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        RandomListNode original = head;</span><br><span class="line">        <span class="keyword">while</span> (original != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloned = <span class="keyword">new</span> RandomListNode(original.label);</span><br><span class="line">            cloned.next = original.next;</span><br><span class="line">            original.next = cloned;</span><br><span class="line">            original = cloned.next;</span><br><span class="line">        &#125;</span><br><span class="line">        original = head;</span><br><span class="line">        <span class="keyword">while</span> (original != <span class="keyword">null</span>) &#123;</span><br><span class="line">            original.next.random = </span><br><span class="line">                (original.random != <span class="keyword">null</span>) ? original.random.next : <span class="keyword">null</span>;</span><br><span class="line">            original = original.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        RandomListNode cloned_head = head.next;</span><br><span class="line">        RandomListNode cloned = cloned_head;</span><br><span class="line">        original = head;</span><br><span class="line">        <span class="keyword">while</span> (cloned != <span class="keyword">null</span>) &#123;</span><br><span class="line">            original.next = cloned.next;</span><br><span class="line">            original = original.next;</span><br><span class="line">            cloned.next = (original != <span class="keyword">null</span>) ? original.next : <span class="keyword">null</span>;</span><br><span class="line">            cloned = cloned.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloned_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下有三种常规解决方案，和一种杂技解法。&lt;/p&gt;
&lt;p&gt;Best Approach: Time Complexity O(n), Space Complexity O(1).&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="LinkedList" scheme="https://fudonglai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>现代C语言--I</title>
    <link href="https://fudonglai.github.io/2018/11/19/Modern-C-Lang/"/>
    <id>https://fudonglai.github.io/2018/11/19/Modern-C-Lang/</id>
    <published>2018-11-18T17:09:53.000Z</published>
    <updated>2018-11-20T06:55:13.184Z</updated>
    
    <content type="html"><![CDATA[<p>C语言简单而隐晦的角落。</p><a id="more"></a><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><p>scanf 遇到的字符不是当前内容时， 会把它放回原处，在扫描下一个输入项或下一次调用 scanf 时再试图读入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">float</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%f%f"</span>, &amp;i, &amp;j, &amp;x, &amp;y);</span><br></pre></td></tr></table></figure><p>Suppose that the user enters three lines of input:</p><blockquote><p>1-20.3-4.0e3</p></blockquote><ul><li>第一个转换符是 %d，第一个非空字符是 1，可以出现在整数中，下一个字符是 ”-“，scanf 认为它不应该出现在整数内部，所以把 “-” 放回原处，把 1 读入 i 。</li><li>第二个读入 -20 之后发现小数点，scanf 认为它不该出现在整数中，所以把 -20 读入 j 。</li><li>第三个读入 .3，发现负号不该出现在浮点数中间，所以把 0.3 读入 x 。</li><li>最后把 -4*10^3 读入 y，并把最后的换行符放回原处。</li></ul><p>在读取格式串时遇到任何空白字符，scanf 会跳过空白符直到遇到非空白符尝试读取。</p><p>如 <code>&quot;%d/%d&quot;</code> 格式串，输入<code>5/    96</code>，能够成功读取两个整数。</p><p>如输入<code>5  /    96</code>，则在读取 5 后无法匹配 <code>/</code>而把之后的所有留给下次 scanf 调用。</p><h2 id="的副作用（side-effect）"><a href="#的副作用（side-effect）" class="headerlink" title="+= 的副作用（side effect）"></a>+= 的副作用（side effect）</h2><p>如果 v 有副作用，那么 v += e 不等价于 v = v + e 。</p><p>因为 v += e 只会导致一次 v 的求值，而 v = v + e 有两次。</p><p>如 <code>a[i++] += 1</code> 只会导致 i 自增 1；</p><p>而 <code>a[i++] = a[i++] + 1</code> 导致 i 自增 2 。</p><h2 id="getchar"><a href="#getchar" class="headerlink" title="getchar"></a>getchar</h2><p>getchar(), putchar() faster than scanf and printf.</p><p><strong>idiom</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>) <span class="comment">/*skips rest of line*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) == <span class="string">' '</span>) <span class="comment">/*skips blanks*/</span></span><br></pre></td></tr></table></figure><p>如果混用 scanf 和 getchar，注意 scanf 读取剩下的字符（包括换行符）会被 getchar 读取。</p><h2 id="使用-lf-读取-double-型的值，用-f-进行显示"><a href="#使用-lf-读取-double-型的值，用-f-进行显示" class="headerlink" title="使用 %lf 读取 double 型的值，用 %f 进行显示"></a>使用 %lf 读取 double 型的值，用 %f 进行显示</h2><p>因为 printf 和 scanf 都没有限制参数个数，使用了可变长度参数列表。</p><p>当调用可变长度参数列表函数时编译器安排 float 自动转化成 double 型，所以 printf 无法区分 float 和 double，所以可以用 %f 表示 float 和 double。</p><p>但是 scanf 用指针指向变量，必须知道地址上存储的类型，否则如果 float 和 double 位模式不同，scanf 会存储错误的字节数量。</p><h2 id="typedef-优于宏定义"><a href="#typedef-优于宏定义" class="headerlink" title="typedef 优于宏定义"></a>typedef 优于宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR_TO_INT int *</span></span><br><span class="line">PTR_TO_INT p, q;</span><br><span class="line"><span class="comment">// int *p, q;</span></span><br><span class="line"><span class="comment">// typedef will be better</span></span><br></pre></td></tr></table></figure><h2 id="远离-1"><a href="#远离-1" class="headerlink" title="远离 1"></a>远离 1</h2><p>下标从 0 开始，注意数组的下标越界陷阱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">    a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可能会导致无限循环。因为 <code>a[10]</code>已经越界，如果变量 <code>i</code>如果储存在这块空间，则错误地把<code>i</code>赋值为 0，无限循环。</p><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>如果给定长度和初始化列表，列表长度为0 或超过长度都是非法的，如果小于长度，剩余位置自动初始化为 0 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">/*initial value: 1,2,0,0,0,0,0,0,0,0*/</span></span><br></pre></td></tr></table></figure><p><strong>多维数组初始化：</strong></p><ul><li>如果一行给出的列表不能填满该行，该行剩余填满 0 。</li><li>如果给出的列表行数不足数组行数，剩余行数全部填满 0 。</li><li>如果去掉大括号也可以，一旦填满一行，编译器自动去填下一行。（危险）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">               &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="comment">/* 1,2,0,0,</span></span><br><span class="line"><span class="comment">   1,2,3,4,</span></span><br><span class="line"><span class="comment">   0,0,0,0,</span></span><br><span class="line"><span class="comment">   0,0,0,0 */</span></span><br></pre></td></tr></table></figure><p>所以要全部初始化为 0 应该是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组和指针区别"><a href="#数组和指针区别" class="headerlink" title="数组和指针区别"></a>数组和指针区别</h2><ol><li><p>数组名不能被赋予新值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (*a != <span class="number">0</span>)</span><br><span class="line">    a++;<span class="comment">/*WRONG*/</span></span><br></pre></td></tr></table></figure></li><li><p><code>sizeof()</code>对数组名和指针效果不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len_of_a = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">/* len_of_a == 3 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line"><span class="keyword">int</span> len_of_p = <span class="keyword">sizeof</span>(p); <span class="comment">/* len_of_p == sizeof(int*) */</span></span><br></pre></td></tr></table></figure><p>sizeof 对普通指针计算一个指针在内存中的字节长度，这取决于机器。</p><p>sizeof 对数组名计算该数组在内存中的总字节长度，所以可以那样求得数组元素个数。</p></li></ol><h2 id="函数形式参数中-int-a-还是-int-a"><a href="#函数形式参数中-int-a-还是-int-a" class="headerlink" title="函数形式参数中 int *a 还是 int a[ ] ?"></a>函数形式参数中 int *a 还是 int a[ ] ?</h2><p>考虑到函数参数传入的是拷贝，<code>int *a</code> 和 <code>int a[]</code> 完全相同，即便后者形式好像是数组，实际上也是普通指针，没有任何数组名的特殊技能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);  <span class="comment">/*WRONG*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组型参数"><a href="#数组型参数" class="headerlink" title="数组型参数"></a>数组型参数</h2><p>传入一维数组时，不需要写长度，写了也没用。</p><p>传入多为数组时，只有第一维长度是不必要的。因为要让编译器知道一个元素长度到底是多少。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a[<span class="number">10</span>])</span></span>&#123;  <span class="comment">//OK</span></span><br><span class="line">    <span class="comment">/* equal to fun(int a[]) and fun(int* a) */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">10</span>])</span></span>&#123; <span class="comment">//correct</span></span><br><span class="line">    <span class="comment">/* because complier konws there are sizeof(int) * 10 </span></span><br><span class="line"><span class="comment">    bits between a[0] and a[1] */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* fun2(int a[][]) is WRONG */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="i-a"><a href="#i-a" class="headerlink" title="i [a] ???"></a>i [a] ???</h2><p>对编译器而言：<code>i[a] == *(i + a) == a[i]</code></p><h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h2><p>最后一个是空字符<code>/0</code>，其 ASCII 码为 0 ，而数字 <code>0</code> 的 ASCII 码为 48 。</p><h2 id="字符数组和数组指针"><a href="#字符数组和数组指针" class="headerlink" title="字符数组和数组指针"></a>字符数组和数组指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> date_arr[] = <span class="string">"Nov 20"</span>;</span><br><span class="line"><span class="keyword">char</span>* date_ptr = <span class="string">"Nov 20"</span>;</span><br></pre></td></tr></table></figure><ul><li><code>date_ptr</code>是指针变量，可以再指向其他值，<code>date_arr</code>不能。</li><li><code>date_ptr</code>指向的字符串是字面值，不可修改，<code>date_arr</code>可以随意修改。</li></ul><p>初始化字符数组时类似普通数组，若填不满空位添 0 ，超过限制就非法，但是不会检查最后是否有停止标识符<code>/0</code>。</p><p>考虑 <code>printf</code>和<code>scanf</code>第一个参数都是接受字符串常量，即该串的首地址。</p><h2 id="读写字符串"><a href="#读写字符串" class="headerlink" title="读写字符串"></a>读写字符串</h2><h3 id="printf-amp-amp-puts"><a href="#printf-amp-amp-puts" class="headerlink" title="printf &amp;&amp; puts"></a>printf &amp;&amp; puts</h3><p>printf 逐个读取字符，直到读到空字符，如果空字符丢失，继续读，知道在内存找到一个空字符为止。</p><p>puts 接受一个参数没有格式串，写完字符串后自动添加换行符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"abcdef"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.3s"</span>, str); <span class="comment">// abc</span></span><br><span class="line"><span class="built_in">puts</span>(str); <span class="comment">// abcdef</span></span><br></pre></td></tr></table></figure><h3 id="scanf-amp-amp-gets"><a href="#scanf-amp-amp-gets" class="headerlink" title="scanf &amp;&amp; gets"></a>scanf &amp;&amp; gets</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 11</span></span><br><span class="line"><span class="keyword">char</span> str[LEN];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line"><span class="comment">/* input: "   hello world"*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   str: 'h','e','l','l','o','\0', ...</span></span><br><span class="line"><span class="comment">   scanf never get string with space, skip blank and end at blank,</span></span><br><span class="line"><span class="comment">   and add '\0' automatically.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">gets(str); <span class="comment">//all will be recieved, but dangerous</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言简单而隐晦的角落。&lt;/p&gt;
    
    </summary>
    
      <category term="C Programming Language" scheme="https://fudonglai.github.io/categories/C-Programming-Language/"/>
    
    
  </entry>
  
  <entry>
    <title>KMP for Pattern Searching</title>
    <link href="https://fudonglai.github.io/2018/10/26/KMP-for-Pattern-Searching/"/>
    <id>https://fudonglai.github.io/2018/10/26/KMP-for-Pattern-Searching/</id>
    <published>2018-10-26T08:18:39.000Z</published>
    <updated>2018-12-22T15:26:59.248Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Question:</strong> Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p><p>KMP (Knuth-Morris-Pratt Algorithm) is a classic and yet notoriously hard-to-understand algorithm.Fortunately, I found some perspicuous explainations.</p><p>Here are both Brute-Force method and KMP algorithm.</p><a id="more"></a><h1 id="Brute-Force-Implement"><a href="#Brute-Force-Implement" class="headerlink" title="Brute-Force Implement"></a>Brute-Force Implement</h1><p>It’s easy. Code is here:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (haystack.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> h = haystack.length(), n = needle.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= h - n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle.front())&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n &amp;&amp; haystack[i + j] == needle[j]; ++j)</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">if</span> (j == n)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The worst case complexity of the naive algorithm is $O(m(n-m+1))$. </p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">text[] = <span class="string">"AAAAAAAAAAAAAAAAAB"</span></span><br><span class="line">pattern[] = <span class="string">"AAAAB"</span></span><br><span class="line"><span class="comment">/*the worst case*/</span></span><br><span class="line"></span><br><span class="line">txt[] = <span class="string">"ABABABCABABABCABABABC"</span></span><br><span class="line">pat[] =  <span class="string">"ABABAC"</span> </span><br><span class="line"><span class="comment">/*not a worst case, but a bad case for Naive*/</span></span><br></pre></td></tr></table></figure><p>But the time complexity of KMP algorithm is $O(n)$ in the worst case. Of course, you need some extra space to preprocess the pattern.</p><p>Then you  can challenge yourself implement the KMP algorithm for this problem.</p><h1 id="KMP-Algorithm"><a href="#KMP-Algorithm" class="headerlink" title="KMP Algorithm"></a>KMP Algorithm</h1><p>You can refer to them for the detials:</p><ol><li>KMP on <a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="noopener">Jake Boxer’s Blog</a></li><li>KMP on <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/" target="_blank" rel="noopener">Geeks-for-Geeks</a></li></ol><h2 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h2><h3 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h3><p>Whenever we detect a mismatch (after some matches), we already know some of the characters in the text of the next window. We take advantage of this information to avoid matching the characters that we know will anyway match. </p><p>To know how many characters we can skip, we pre-process pattern and get an integer array that tells us the count of characters to be skipped. </p><h3 id="The-Partial-Match-Table"><a href="#The-Partial-Match-Table" class="headerlink" title="The Partial Match Table"></a>The Partial Match Table</h3><p>Here I want to quote <a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="noopener">Jake Boxer’s perspicuous explaination</a>.</p><p>Here’s the partial match table for the pattern “abababca”:</p><table><thead><tr><th>char</th><th>a</th><th>b</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>a</th></tr></thead><tbody><tr><td>index</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>value</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>0</td><td>1</td></tr></tbody></table><blockquote><p><strong>Proper prefix</strong>: All the characters in a string, with one or more cut off the end. “S”, “Sn”, “Sna”, and “Snap” are all the proper prefixes of “Snape”.</p><p><strong>Proper suffix</strong>: All the characters in a string, with one or more cut off the beginning. “agrid”, “grid”, “rid”, “id”, and “d” are all proper suffixes of “Hagrid”.</p><p>Here, we’re interested in the first four characters (“abab”). We have three proper prefixes (“a”, “ab”, and “aba”) and three proper suffixes (“b”, “ab”, and “bab”). This time, “ab” is in both, and is two characters long, so cell four gets value 2.</p><p>let’s also try it for cell five, which concerns “ababa”. We have four proper prefixes (“a”, “ab”, “aba”, and “abab”) and four proper suffixes (“a”, “ba”, “aba”, and “baba”). Now, we have two matches: “a” and “aba” are both proper prefixes and proper suffixes. Since “aba” is longer than “a”, it wins, and cell five gets value 3.</p><p>Let’s skip ahead to cell seven (the second-to-last cell), which is concerned with the pattern “abababc”. Even without enumerating all the proper prefixes and suffixes, it should be obvious that there aren’t going to be any matches; all the suffixes will end with the letter “c”, and none of the prefixes will. Since there are no matches, cell seven gets 0.</p></blockquote><h2 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h2><p>quote <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/" target="_blank" rel="noopener">Geeks-for-Geeks</a>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lps[i] = the longest proper prefix of pat[<span class="number">0.</span>.i] </span><br><span class="line">which is also a suffix of pat[<span class="number">0.</span>.i]. </span><br><span class="line">         </span><br><span class="line">Examples of lps[] construction:</span><br><span class="line"></span><br><span class="line">For the pattern “AAAA”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">For the pattern “ABCDE”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">For the pattern “AABAACAABAA”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">For the pattern “AAACAAAAAC”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>] </span><br><span class="line"></span><br><span class="line">For the pattern “AAABAAA”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="Preprocessing-Algorithm"><a href="#Preprocessing-Algorithm" class="headerlink" title="Preprocessing Algorithm"></a>Preprocessing Algorithm</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pat[] = <span class="string">"AAACAAAA"</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">0.</span></span><br><span class="line">lps[<span class="number">0</span>] <span class="keyword">is</span> always <span class="number">0</span>, we move </span><br><span class="line">to i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">1.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">1</span>, lps[<span class="number">1</span>] = <span class="number">1</span>, i = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">1</span>, i  = <span class="number">2.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">2</span>, lps[<span class="number">2</span>] = <span class="number">2</span>, i = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">2</span>, i  = <span class="number">3.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match, <span class="keyword">and</span> len &gt; <span class="number">0</span>, </span><br><span class="line">set len = lps[len<span class="number">-1</span>] = lps[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">1</span>, i  = <span class="number">3.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match <span class="keyword">and</span> len &gt; <span class="number">0</span>, </span><br><span class="line">len = lps[len<span class="number">-1</span>] = lps[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">3.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match <span class="keyword">and</span> len = <span class="number">0</span>, </span><br><span class="line">Set lps[<span class="number">3</span>] = <span class="number">0</span> <span class="keyword">and</span> i = <span class="number">4.</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">4.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">1</span>, lps[<span class="number">4</span>] = <span class="number">1</span>, i = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">1</span>, i  = <span class="number">5.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">2</span>, lps[<span class="number">5</span>] = <span class="number">2</span>, i = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">2</span>, i  = <span class="number">6.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">3</span>, lps[<span class="number">6</span>] = <span class="number">3</span>, i = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">3</span>, i  = <span class="number">7.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match <span class="keyword">and</span> len &gt; <span class="number">0</span>,</span><br><span class="line">set len = lps[len<span class="number">-1</span>] = lps[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">2</span>, i  = <span class="number">7.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">3</span>, lps[<span class="number">7</span>] = <span class="number">3</span>, i = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">We stop here <span class="keyword">as</span> we have constructed the whole lps[].</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Here is my preprocessing code:</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; generator(<span class="built_in">string</span> pattern)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lps(pattern.size());</span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pattern.size(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[len])&#123;</span><br><span class="line">            len++;</span><br><span class="line">            lps[i] = len;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">                len = lps[len - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                len = <span class="number">0</span>; i++;</span><br><span class="line">            &#125;<span class="comment">//else</span></span><br><span class="line">        &#125;<span class="comment">//else</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> lps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Matching-Algorithm"><a href="#Matching-Algorithm" class="headerlink" title="Matching Algorithm"></a>Matching Algorithm</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (haystack.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lps = generator(needle);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.size(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle[j])&#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j = lps[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;&#125;</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; Return the index of the first occurrence of needle in haystack, or &lt;strong&gt;-1&lt;/strong&gt; if needle is not part of haystack.&lt;/p&gt;
&lt;p&gt;KMP (Knuth-Morris-Pratt Algorithm) is a classic and yet notoriously hard-to-understand algorithm.Fortunately, I found some perspicuous explainations.&lt;/p&gt;
&lt;p&gt;Here are both Brute-Force method and KMP algorithm.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="patern search" scheme="https://fudonglai.github.io/tags/patern-search/"/>
    
  </entry>
  
  <entry>
    <title>Fundamental DP Problem</title>
    <link href="https://fudonglai.github.io/2018/10/26/Fundamental-DP-Problem/"/>
    <id>https://fudonglai.github.io/2018/10/26/Fundamental-DP-Problem/</id>
    <published>2018-10-26T02:52:13.000Z</published>
    <updated>2018-12-30T03:39:37.781Z</updated>
    
    <content type="html"><![CDATA[<p>There is an interesting problem in LeetCode: <a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">Unique Paths</a>.</p><p>I found some perspicuous explanation in the comments. Thank @<a href="https://leetcode.com/yfgu0618" target="_blank" rel="noopener">YFGu0618</a> for his graph.</p><a id="more"></a><h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><blockquote><p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid.</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid.</p><p>How many possible unique paths are there?</p></blockquote><h3 id="Observations"><a href="#Observations" class="headerlink" title="Observations:"></a>Observations:</h3><p>Since the robot can only move right and down, when it arrives at a point, there are only two possibilities:</p><ol><li>It arrives at that point from above (moving down to that point);</li><li>It arrives at that point from left (moving right to that point).</li></ol><p>Thus we have the following equations: $Approach(i, j)=Approach(i - 1, j) + Approach(i, j-1)$</p><p><img src="https://assets.leetcode.com/users/yfgu0618/image_1540157891.png" alt="picture"></p><p>The boundary conditions of the above equation have some problems at the leftmost column and the uppermost row due to $(0, j)$ and $(i, 0)$ do not exist. To oversmart the problem automatically,  it’s easier that we initialize the array to something like following:</p><p><img src="https://assets.leetcode.com/users/yfgu0618/image_1540158218.png" alt="picture"></p><h3 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h3><p>So, here is my codes:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; ++j) </span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][j - <span class="number">1</span>] + <span class="built_in">map</span>[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>As can be seen, the above solution runs in $O(n^2)$ time and costs $O(m*n)$ space.</p><p>But we find that each time we update the <code>map[i][j]</code>, we only need to consider the current column(for <code>map[i-1, j]</code>) and the previous column(for <code>map[i, j-1]</code>), so only two vector can be enough.</p><p>Here is new codes:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c1(m + <span class="number">1</span>, <span class="number">0</span>), c2(c1);</span><br><span class="line">        c1[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                c2[j] = c1[j] + c2[j - <span class="number">1</span>];</span><br><span class="line">            c1 = c2;</span><br><span class="line">            c2 = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c1[m];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Further inspecting the above code, we find it needs $O(m)$ space, but if $n&lt;m$, should I convert to $O(n)$ space? And we find that <code>vector c2</code>will convert to zero in every loop, so the operation is actually <code>c1[i] += c1[i-1]</code>. Now we can implement a more efficient approach:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">           <span class="keyword">return</span> uniquePaths(n, m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(m, <span class="number">0</span>);</span><br><span class="line">        c[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - <span class="number">1</span>; ++j) </span><br><span class="line">                c[j] += c[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> c[m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Now it is prefect, how interesting it is!</p><p>PS: 2018/12/30</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) <span class="keyword">return</span> uniquePaths(n, m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;There is an interesting problem in LeetCode: &lt;a href=&quot;https://leetcode.com/problems/unique-paths/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Unique Paths&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I found some perspicuous explanation in the comments. Thank @&lt;a href=&quot;https://leetcode.com/yfgu0618&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YFGu0618&lt;/a&gt; for his graph.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="dynamic programming" scheme="https://fudonglai.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Non-Repeating Longest Substring</title>
    <link href="https://fudonglai.github.io/2018/10/20/Non-Repeating-longest-substring/"/>
    <id>https://fudonglai.github.io/2018/10/20/Non-Repeating-longest-substring/</id>
    <published>2018-10-20T10:24:49.000Z</published>
    <updated>2018-10-26T13:01:00.989Z</updated>
    
    <content type="html"><![CDATA[<p>An ingenuity to use map to solve Substring.</p><a id="more"></a><h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><blockquote><p>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3. </p></blockquote><p>###Solution</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> * Solution (DP, O(n)):</span><br><span class="line"> * </span><br><span class="line"> * Assume L[i] = s[m...i], denotes the longest substring without repeating</span><br><span class="line"> * characters that ends up at s[i], <span class="keyword">and</span> we keep a hashmap <span class="keyword">for</span> every</span><br><span class="line"> * characters between m ... i, <span class="keyword">while</span> storing &lt;character, index&gt; in the</span><br><span class="line"> * hashmap.</span><br><span class="line"> * We know that each character will appear only once.</span><br><span class="line"> </span><br><span class="line"> * Then to find s[i+<span class="number">1</span>]:</span><br><span class="line"> * <span class="number">1</span>) <span class="keyword">if</span> s[i+<span class="number">1</span>] does <span class="keyword">not</span> appear in hashmap</span><br><span class="line"> *    we can just add s[i+<span class="number">1</span>] to hash <span class="built_in">map</span>. <span class="keyword">and</span> L[i+<span class="number">1</span>] = s[m...i+<span class="number">1</span>]</span><br><span class="line"> * <span class="number">2</span>) <span class="keyword">if</span> s[i+<span class="number">1</span>] exists in hashmap, <span class="keyword">and</span> the hashmap value (the index) is k</span><br><span class="line"> *    let m = max(m, k), then L[i+<span class="number">1</span>] = s[m...i+<span class="number">1</span>], we also need to update</span><br><span class="line"> *    entry in hashmap to mark the latest occurency of s[i+<span class="number">1</span>].</span><br><span class="line"> * </span><br><span class="line"> * Since we scan the <span class="built_in">string</span> <span class="keyword">for</span> only once, <span class="keyword">and</span> the <span class="string">'m'</span> will also move from</span><br><span class="line"> * beginning to end <span class="keyword">for</span> at most once. Overall complexity is O(n).</span><br><span class="line"> *</span><br><span class="line"> * If characters are all in ASCII, we could use <span class="built_in">array</span> to mimic hashmap.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> lengthOfLongestSubstring(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dict(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            m = max(m, dict[s[i]] + <span class="number">1</span>);</span><br><span class="line">            dict[s[i]] = i;</span><br><span class="line">            len = max(len, i - m + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Complement"><a href="#Complement" class="headerlink" title="Complement"></a>Complement</h3><p>Now I’ve meet some point of it:</p><ul><li>ASSIC uses one byte to encode, $2^{8}=256$, so we can regard a 256-size vector as a hashtable. The ASSIC of character will be key, its index will be value.</li><li><p>Remeber, every value in <code>dict</code> which not equals $-1$ represents the element’s index clostest to $i$’th element. </p></li><li><p>If all the character is unique, $m$ always equals 0, longest length will increase one by one.</p></li><li>If  encount a character repeates, then we compare $m$ and the index. If $m$ is greater than index, it means the element occured in a substring before, but no big deal for current substring count. If $m$ is less than index, it means the current substring can’t be longer any more, so $m$ will update to the index.</li><li>In other word, every time we update $m$ , we actually find a substring, which is <code>string[m: i]</code>.</li><li>As for varaible <code>len</code>, it compares every loop. Only when current substring <code>i - m + 1</code>longer than before, it will update to a large length.</li></ul><p>I think the partern of solution can have a double pointer expension.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;An ingenuity to use map to solve Substring.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Substring" scheme="https://fudonglai.github.io/tags/Substring/"/>
    
  </entry>
  
  <entry>
    <title>Think Recursively</title>
    <link href="https://fudonglai.github.io/2018/10/18/Think-Recursively/"/>
    <id>https://fudonglai.github.io/2018/10/18/Think-Recursively/</id>
    <published>2018-10-18T11:12:34.000Z</published>
    <updated>2018-12-23T07:01:16.462Z</updated>
    
    <content type="html"><![CDATA[<h3 id="“Top-down”-Solution"><a href="#“Top-down”-Solution" class="headerlink" title="“Top-down” Solution"></a>“Top-down” Solution</h3><p>When you meet a tree problem, ask yourself two questions: </p><ul><li>Can you determine some parameters to help the node know the answer of itself? </li><li>Can you use these parameters and the value of the node itself to determine what should be the parameters parsing to its children? </li></ul><a id="more"></a><p> If the answers are both <strong>yes</strong>, try to solve this problem using a “top-down” recursion solution.</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> answer;       <span class="comment">// don't forget to initialize answer before call maximum_depth</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maximum_depth</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        answer = max(answer, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    maximum_depth(root-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">    maximum_depth(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="“Bottom-up”-Solution"><a href="#“Bottom-up”-Solution" class="headerlink" title="“Bottom-up” Solution"></a>“Bottom-up” Solution</h3><p>Or you can think the problem in this way: </p><p>for a node in a tree, if you know the answer of its children, can you calculate the answer of the node? </p><p>If the answer is yes, solving the problem recursively from bottom up might be a good way.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum_depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;                                   <span class="comment">// return 0 for null node</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left_depth = maximum_depth(root.left);</span><br><span class="line"><span class="keyword">int</span> right_depth = maximum_depth(root.right);</span><br><span class="line"><span class="keyword">return</span> Math.max(left_depth, right_depth) + <span class="number">1</span>;<span class="comment">// return depth of the subtree rooted at root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;“Top-down”-Solution&quot;&gt;&lt;a href=&quot;#“Top-down”-Solution&quot; class=&quot;headerlink&quot; title=&quot;“Top-down” Solution&quot;&gt;&lt;/a&gt;“Top-down” Solution&lt;/h3&gt;&lt;p&gt;When you meet a tree problem, ask yourself two questions: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Can you determine some parameters to help the node know the answer of itself? &lt;/li&gt;
&lt;li&gt;Can you use these parameters and the value of the node itself to determine what should be the parameters parsing to its children? &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Recursion" scheme="https://fudonglai.github.io/tags/Recursion/"/>
    
  </entry>
  
</feed>
