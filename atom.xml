<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FDL&#39;s BLOG</title>
  
  <subtitle>Down to earth. &lt;br&gt;Being towards death.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fudonglai.github.io/"/>
  <updated>2018-10-26T12:59:45.706Z</updated>
  <id>https://fudonglai.github.io/</id>
  
  <author>
    <name>Fudonglai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KMP for Pattern Searching</title>
    <link href="https://fudonglai.github.io/2018/10/26/KMP-for-Pattern-Searching/"/>
    <id>https://fudonglai.github.io/2018/10/26/KMP-for-Pattern-Searching/</id>
    <published>2018-10-26T08:18:39.000Z</published>
    <updated>2018-10-26T12:59:45.706Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Question:</strong> Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p><p>KMP (Knuth-Morris-Pratt Algorithm) is a classic and yet notoriously hard-to-understand algorithm.Fortunately, I found some perspicuous explainations.</p><p>Here are both Brute-Force method and KMP algorithm.</p><a id="more"></a><h1 id="Brute-Force-Implement"><a href="#Brute-Force-Implement" class="headerlink" title="Brute-Force Implement"></a>Brute-Force Implement</h1><p>It’s easy. Code is here:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (haystack.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> h = haystack.length(), n = needle.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= h - n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle.front())&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n &amp;&amp; haystack[i + j] == needle[j]; ++j)</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">if</span> (j == n)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The worst case complexity of the naive algorithm is $O(m(n-m+1))$. </p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">text[] = <span class="string">"AAAAAAAAAAAAAAAAAB"</span></span><br><span class="line">pattern[] = <span class="string">"AAAAB"</span></span><br><span class="line"><span class="comment">/*the worst case*/</span></span><br><span class="line"></span><br><span class="line">txt[] = <span class="string">"ABABABCABABABCABABABC"</span></span><br><span class="line">pat[] =  <span class="string">"ABABAC"</span> </span><br><span class="line"><span class="comment">/*not a worst case, but a bad case for Naive*/</span></span><br></pre></td></tr></table></figure><p>But the time complexity of KMP algorithm is $O(n)$ in the worst case. Of course, you need some extra space to preprocess the pattern.</p><p>Then you  can challenge yourself implement the KMP algorithm for this problem.</p><h1 id="KMP-Algorithm"><a href="#KMP-Algorithm" class="headerlink" title="KMP Algorithm"></a>KMP Algorithm</h1><p>You can refer to them for the detials:</p><ol><li>KMP on <a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="noopener">Jake Boxer’s Blog</a></li><li>KMP on <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/" target="_blank" rel="noopener">Geeks-for-Geeks</a></li></ol><h2 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h2><h3 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h3><p>Whenever we detect a mismatch (after some matches), we already know some of the characters in the text of the next window. We take advantage of this information to avoid matching the characters that we know will anyway match. </p><p>To know how many characters we can skip, we pre-process pattern and get an integer array that tells us the count of characters to be skipped. </p><h3 id="The-Partial-Match-Table"><a href="#The-Partial-Match-Table" class="headerlink" title="The Partial Match Table"></a>The Partial Match Table</h3><p>Here I want to quote <a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="noopener">Jake Boxer’s perspicuous explaination</a>.</p><p>Here’s the partial match table for the pattern “abababca”:</p><table><thead><tr><th>char</th><th>a</th><th>b</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>a</th></tr></thead><tbody><tr><td>index</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>value</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>0</td><td>1</td></tr></tbody></table><blockquote><p><strong>Proper prefix</strong>: All the characters in a string, with one or more cut off the end. “S”, “Sn”, “Sna”, and “Snap” are all the proper prefixes of “Snape”.</p><p><strong>Proper suffix</strong>: All the characters in a string, with one or more cut off the beginning. “agrid”, “grid”, “rid”, “id”, and “d” are all proper suffixes of “Hagrid”.</p><p>Here, we’re interested in the first four characters (“abab”). We have three proper prefixes (“a”, “ab”, and “aba”) and three proper suffixes (“b”, “ab”, and “bab”). This time, “ab” is in both, and is two characters long, so cell four gets value 2.</p><p>let’s also try it for cell five, which concerns “ababa”. We have four proper prefixes (“a”, “ab”, “aba”, and “abab”) and four proper suffixes (“a”, “ba”, “aba”, and “baba”). Now, we have two matches: “a” and “aba” are both proper prefixes and proper suffixes. Since “aba” is longer than “a”, it wins, and cell five gets value 3.</p><p>Let’s skip ahead to cell seven (the second-to-last cell), which is concerned with the pattern “abababc”. Even without enumerating all the proper prefixes and suffixes, it should be obvious that there aren’t going to be any matches; all the suffixes will end with the letter “c”, and none of the prefixes will. Since there are no matches, cell seven gets 0.</p></blockquote><h2 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h2><p>quote <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/" target="_blank" rel="noopener">Geeks-for-Geeks</a>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lps[i] = the longest proper prefix of pat[<span class="number">0.</span>.i] </span><br><span class="line">which is also a suffix of pat[<span class="number">0.</span>.i]. </span><br><span class="line">         </span><br><span class="line">Examples of lps[] construction:</span><br><span class="line"></span><br><span class="line">For the pattern “AAAA”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">For the pattern “ABCDE”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">For the pattern “AABAACAABAA”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">For the pattern “AAACAAAAAC”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>] </span><br><span class="line"></span><br><span class="line">For the pattern “AAABAAA”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="Preprocessing-Algorithm"><a href="#Preprocessing-Algorithm" class="headerlink" title="Preprocessing Algorithm"></a>Preprocessing Algorithm</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pat[] = <span class="string">"AAACAAAA"</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">0.</span></span><br><span class="line">lps[<span class="number">0</span>] <span class="keyword">is</span> always <span class="number">0</span>, we move </span><br><span class="line">to i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">1.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">1</span>, lps[<span class="number">1</span>] = <span class="number">1</span>, i = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">1</span>, i  = <span class="number">2.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">2</span>, lps[<span class="number">2</span>] = <span class="number">2</span>, i = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">2</span>, i  = <span class="number">3.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match, <span class="keyword">and</span> len &gt; <span class="number">0</span>, </span><br><span class="line">set len = lps[len<span class="number">-1</span>] = lps[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">1</span>, i  = <span class="number">3.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match <span class="keyword">and</span> len &gt; <span class="number">0</span>, </span><br><span class="line">len = lps[len<span class="number">-1</span>] = lps[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">3.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match <span class="keyword">and</span> len = <span class="number">0</span>, </span><br><span class="line">Set lps[<span class="number">3</span>] = <span class="number">0</span> <span class="keyword">and</span> i = <span class="number">4.</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">4.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">1</span>, lps[<span class="number">4</span>] = <span class="number">1</span>, i = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">1</span>, i  = <span class="number">5.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">2</span>, lps[<span class="number">5</span>] = <span class="number">2</span>, i = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">2</span>, i  = <span class="number">6.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">3</span>, lps[<span class="number">6</span>] = <span class="number">3</span>, i = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">3</span>, i  = <span class="number">7.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match <span class="keyword">and</span> len &gt; <span class="number">0</span>,</span><br><span class="line">set len = lps[len<span class="number">-1</span>] = lps[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">2</span>, i  = <span class="number">7.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">3</span>, lps[<span class="number">7</span>] = <span class="number">3</span>, i = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">We stop here <span class="keyword">as</span> we have constructed the whole lps[].</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Here is my preprocessing code:</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; generator(<span class="built_in">string</span> pattern)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lps(pattern.size());</span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pattern.size(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[len])&#123;</span><br><span class="line">            len++;</span><br><span class="line">            lps[i] = len;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">                len = lps[len - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                len = <span class="number">0</span>; i++;</span><br><span class="line">            &#125;<span class="comment">//else</span></span><br><span class="line">        &#125;<span class="comment">//else</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> lps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Matching-Algorithm"><a href="#Matching-Algorithm" class="headerlink" title="Matching Algorithm"></a>Matching Algorithm</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (haystack.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lps = generator(needle);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.size(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle[j])&#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j = lps[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;&#125;</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; Return the index of the first occurrence of needle in haystack, or &lt;strong&gt;-1&lt;/strong&gt; if needle is not part of haystack.&lt;/p&gt;
&lt;p&gt;KMP (Knuth-Morris-Pratt Algorithm) is a classic and yet notoriously hard-to-understand algorithm.Fortunately, I found some perspicuous explainations.&lt;/p&gt;
&lt;p&gt;Here are both Brute-Force method and KMP algorithm.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="patern search" scheme="https://fudonglai.github.io/tags/patern-search/"/>
    
  </entry>
  
  <entry>
    <title>Fundamental DP Problem</title>
    <link href="https://fudonglai.github.io/2018/10/26/Fundamental-DP-Problem/"/>
    <id>https://fudonglai.github.io/2018/10/26/Fundamental-DP-Problem/</id>
    <published>2018-10-26T02:52:13.000Z</published>
    <updated>2018-10-26T06:14:42.158Z</updated>
    
    <content type="html"><![CDATA[<p>There is an interesting problem in LeetCode: <a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">Unique Paths</a>.</p><p>I found some pespicuous explaination in the comments.</p><a id="more"></a><h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><blockquote><p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid.</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid.</p><p>How many possible unique paths are there?</p></blockquote><h3 id="Observations"><a href="#Observations" class="headerlink" title="Observations:"></a>Observations:</h3><p>Since the robot can only move right and down, when it arrives at a point, there are only two possibilities:</p><ol><li>It arrives at that point from above (moving down to that point);</li><li>It arrives at that point from left (moving right to that point).</li></ol><p>Thus we have the following equations: $Approach(i, j)=Approach(i - 1, j) + Approach(i, j-1)$</p><p><img src="http://ph6w748rg.bkt.clouddn.com/18-10-26/15711693.jpg" alt="picture"></p><p>The boundary conditions of the above equation have some problems at the leftmost column and the uppermost row due to $(0, j)$ and $(i, 0)$ do not exist. To oversmart the problem automatically,  it’s easier that we initialize the array to something like following:</p><p><img src="http://ph6w748rg.bkt.clouddn.com/18-10-26/36462436.jpg" alt="picture"></p><h3 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h3><p>So, here is my codes:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; ++j) </span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][j - <span class="number">1</span>] + <span class="built_in">map</span>[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>As can be seen, the above solution runs in $O(n^2)$ time and costs $O(m*n)$ space.</p><p>But we find that each time we update the <code>map[i][j]</code>, we only need to consider the current column(for <code>map[i-1, j]</code>) and the previous column(for <code>map[i, j-1]</code>), so only two vector can be enough.</p><p>Here is new codes:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c1(m + <span class="number">1</span>, <span class="number">0</span>), c2(c1);</span><br><span class="line">        c1[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                c2[j] = c1[j] + c2[j - <span class="number">1</span>];</span><br><span class="line">            c1 = c2;</span><br><span class="line">            c2 = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c1[m];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Further inspecting the above code, we find it needs $O(m)$ space, but if $n&lt;m$, should I convert to $O(n)$ space? And we find that <code>vector c2</code>will convert to zero in every loop, so the operation is actually <code>c1[i] += c1[i-1]</code>. Now we can implement a more efficient approach:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">           <span class="keyword">return</span> uniquePaths(n, m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(m, <span class="number">0</span>);</span><br><span class="line">        c[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - <span class="number">1</span>; ++j) </span><br><span class="line">                c[j] += c[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> c[m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Now it is prefect, how interesting it is!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;There is an interesting problem in LeetCode: &lt;a href=&quot;https://leetcode.com/problems/unique-paths/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Unique Paths&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I found some pespicuous explaination in the comments.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="dynamic programming" scheme="https://fudonglai.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Non-Repeating Longest Substring</title>
    <link href="https://fudonglai.github.io/2018/10/20/Non-Repeating-longest-substring/"/>
    <id>https://fudonglai.github.io/2018/10/20/Non-Repeating-longest-substring/</id>
    <published>2018-10-20T10:24:49.000Z</published>
    <updated>2018-10-26T13:01:00.989Z</updated>
    
    <content type="html"><![CDATA[<p>An ingenuity to use map to solve Substring.</p><a id="more"></a><h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><blockquote><p>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3. </p></blockquote><p>###Solution</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> * Solution (DP, O(n)):</span><br><span class="line"> * </span><br><span class="line"> * Assume L[i] = s[m...i], denotes the longest substring without repeating</span><br><span class="line"> * characters that ends up at s[i], <span class="keyword">and</span> we keep a hashmap <span class="keyword">for</span> every</span><br><span class="line"> * characters between m ... i, <span class="keyword">while</span> storing &lt;character, index&gt; in the</span><br><span class="line"> * hashmap.</span><br><span class="line"> * We know that each character will appear only once.</span><br><span class="line"> </span><br><span class="line"> * Then to find s[i+<span class="number">1</span>]:</span><br><span class="line"> * <span class="number">1</span>) <span class="keyword">if</span> s[i+<span class="number">1</span>] does <span class="keyword">not</span> appear in hashmap</span><br><span class="line"> *    we can just add s[i+<span class="number">1</span>] to hash <span class="built_in">map</span>. <span class="keyword">and</span> L[i+<span class="number">1</span>] = s[m...i+<span class="number">1</span>]</span><br><span class="line"> * <span class="number">2</span>) <span class="keyword">if</span> s[i+<span class="number">1</span>] exists in hashmap, <span class="keyword">and</span> the hashmap value (the index) is k</span><br><span class="line"> *    let m = max(m, k), then L[i+<span class="number">1</span>] = s[m...i+<span class="number">1</span>], we also need to update</span><br><span class="line"> *    entry in hashmap to mark the latest occurency of s[i+<span class="number">1</span>].</span><br><span class="line"> * </span><br><span class="line"> * Since we scan the <span class="built_in">string</span> <span class="keyword">for</span> only once, <span class="keyword">and</span> the <span class="string">'m'</span> will also move from</span><br><span class="line"> * beginning to end <span class="keyword">for</span> at most once. Overall complexity is O(n).</span><br><span class="line"> *</span><br><span class="line"> * If characters are all in ASCII, we could use <span class="built_in">array</span> to mimic hashmap.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> lengthOfLongestSubstring(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dict(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            m = max(m, dict[s[i]] + <span class="number">1</span>);</span><br><span class="line">            dict[s[i]] = i;</span><br><span class="line">            len = max(len, i - m + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Complement"><a href="#Complement" class="headerlink" title="Complement"></a>Complement</h3><p>Now I’ve meet some point of it:</p><ul><li>ASSIC uses one byte to encode, $2^{8}=256$, so we can regard a 256-size vector as a hashtable. The ASSIC of character will be key, its index will be value.</li><li><p>Remeber, every value in <code>dict</code> which not equals $-1$ represents the element’s index clostest to $i$’th element. </p></li><li><p>If all the character is unique, $m$ always equals 0, longest length will increase one by one.</p></li><li>If  encount a character repeates, then we compare $m$ and the index. If $m$ is greater than index, it means the element occured in a substring before, but no big deal for current substring count. If $m$ is less than index, it means the current substring can’t be longer any more, so $m$ will update to the index.</li><li>In other word, every time we update $m$ , we actually find a substring, which is <code>string[m: i]</code>.</li><li>As for varaible <code>len</code>, it compares every loop. Only when current substring <code>i - m + 1</code>longer than before, it will update to a large length.</li></ul><p>I think the partern of solution can have a double pointer expension.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;An ingenuity to use map to solve Substring.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Substring" scheme="https://fudonglai.github.io/tags/Substring/"/>
    
  </entry>
  
  <entry>
    <title>Think Recursively</title>
    <link href="https://fudonglai.github.io/2018/10/18/Think-Recursively/"/>
    <id>https://fudonglai.github.io/2018/10/18/Think-Recursively/</id>
    <published>2018-10-18T11:12:34.000Z</published>
    <updated>2018-10-26T05:53:33.297Z</updated>
    
    <content type="html"><![CDATA[<h3 id="“Top-down”-Solution"><a href="#“Top-down”-Solution" class="headerlink" title="“Top-down” Solution"></a>“Top-down” Solution</h3><p>When you meet a tree problem, ask yourself two questions: </p><ul><li>Can you determine some parameters to help the node know the answer of itself? </li><li>Can you use these parameters and the value of the node itself to determine what should be the parameters parsing to its children? </li></ul><a id="more"></a><p> If the answers are both <strong>yes</strong>, try to solve this problem using a “top-down” recursion solution.</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> answer;       <span class="comment">// don't forget to initialize answer before call maximum_depth</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maximum_depth</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        answer = max(answer, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    maximum_depth(root-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">    maximum_depth(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="“Bottom-up”-Solution"><a href="#“Bottom-up”-Solution" class="headerlink" title="“Bottom-up” Solution"></a>“Bottom-up” Solution</h3><p>Or you can think the problem in this way: </p><p>for a node in a tree, if you know the answer of its children, can you calculate the answer of the node? </p><p>If the answer is yes, solving the problem recursively from bottom up might be a good way.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum_depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;                                   <span class="comment">// return 0 for null node</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left_depth = maximum_depth(root.left);</span><br><span class="line"><span class="keyword">int</span> right_depth = maximum_depth(root.right);</span><br><span class="line"><span class="keyword">return</span> Math.max(left_depth, right_depth) + <span class="number">1</span>;<span class="comment">// return depth of the subtree rooted at root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;“Top-down”-Solution&quot;&gt;&lt;a href=&quot;#“Top-down”-Solution&quot; class=&quot;headerlink&quot; title=&quot;“Top-down” Solution&quot;&gt;&lt;/a&gt;“Top-down” Solution&lt;/h3&gt;&lt;p&gt;When you meet a tree problem, ask yourself two questions: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Can you determine some parameters to help the node know the answer of itself? &lt;/li&gt;
&lt;li&gt;Can you use these parameters and the value of the node itself to determine what should be the parameters parsing to its children? &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Recurive" scheme="https://fudonglai.github.io/tags/Recurive/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://fudonglai.github.io/2018/10/17/hello-world/"/>
    <id>https://fudonglai.github.io/2018/10/17/hello-world/</id>
    <published>2018-10-17T13:58:17.132Z</published>
    <updated>2018-10-18T11:51:53.663Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
