<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿东的算法笔记</title>
  
  <subtitle>Down to earth. &lt;br&gt;Being towards death.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fudonglai.github.io/"/>
  <updated>2019-04-30T01:56:47.677Z</updated>
  <id>https://fudonglai.github.io/</id>
  
  <author>
    <name>付东来</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对工作的揣测</title>
    <link href="https://fudonglai.github.io/2019/03/13/think-a-job/"/>
    <id>https://fudonglai.github.io/2019/03/13/think-a-job/</id>
    <published>2019-03-12T16:18:51.000Z</published>
    <updated>2019-04-30T01:56:47.677Z</updated>
    
    <content type="html"><![CDATA[<p>最近跟朋友聊了聊未来，另外还尝试跟老师做了做项目，还有一些乱七八糟的事情，使我有点感想，暂且记录下来。</p><p>先说句题外话，一个朋友跟我说，感觉一个人学习真的挺难的，经常感到孤独或者挫败然后就很难学下去。他觉得我基本就是那种不断学习，还特别有动力的人。</p><p>我当时就开始思考我这人有什么特点，我认为这主要是性格的客观因素，但确实有一点能动的主观因素的。我性格属于那种能各种浪也能沉下去钻研的，这个每个人差异比较大，就不多说了。不过培养 ”延迟满足感“ 应该是每个人可以尝试的一种方法。</p><p>比如说你健身，锻炼的时候很痛苦啊，谁不是呢？所以说能坚持下去的人寥寥无几。但是如果你能调用 ”延迟满足感“：忽略现在的这点痛苦，多想想将来练出成果之后装逼的快乐，就更有动力能坚持下来。道理就这么简单，努力学习也一样，多想想将来进入好企业，赚大钱让自己和家人过得舒服，不就是对自己心理上极大地满足吗？</p><p>说白了，就是假装把将来的快乐拿到现在来消费一下，我觉得这也算一种积极地心理暗示吧，起码是在往前看，而不是一直后悔却仍然没什么改变。同样的，你也可以假装把将来的痛苦拿到现在来尝一尝，感受感受。一个人越是能把未来看得大、看得清楚，他对自己的自律就会越强。</p><p>进入正题，说说我对将来进入社会工作的一点揣测。为什么要揣测，直接听过来人的经验不就行了吗？我认为过来人的经验当然应该听，但是还是需要自己时不时揣测一下，原因有二：</p><p>第一，过来人说的经验虽然大都正确，但你不一定能立即消化得了。</p><p>比如说，你现在去给一个初中生讲题，他可能会在你认为显而易见的一个问题卡壳很久。这不是说明他笨，而是你这个过来人相对他来说见得世面太多了，这么一个小问题早被你忽略了，即使你自己当年也卡在这里了很久。所以你给他讲的思路，可能有意无意地掺杂了更复杂的知识，比如极限或者微积分观点，这些思路的精妙之处可能不是他一时半会能体会到的。</p><p>类比回来，工作多年的大佬给我们的经验当然是肺腑之言，但是我们没有相应的见识和阅历，如果生搬硬套不仅很难体会其中的奥妙，而且很容易误解对方的意思，适得其反。我认为，他人的经验不应该是我们思考的终点，而应该是我们思维的起点，在听取他人经验的同时，还应该主动分析思考自身情况，形象一点比喻就是我们自己的探索和他人的经验 “相向而行”，相遇后才能茅塞顿开。</p><p>第二，用理论分析来指导我们的行动是十分重要的。</p><p>这话很抽象，我举个实际的例子：DNA 双螺旋结构的发现历程。我们高中生物学习了，发现 DNA 双螺旋结构的人是沃森和克里克。实际上是一位叫富兰克林的女科学家通过当时新的技术最先观察到 DNA，而沃森和克里克有深厚的数学物理和生物学功底，他们从理论上构想出很多 DNA 可能的结构模型，只是苦于没有数据进行验证。有了富兰克林的实验数据，他们很快就确定双螺旋结构符合 DNA 的真实结构。</p><p>为什么富兰克林第一个观察到 DNA 而没有发现它的双螺旋结构？因为仅从观察结果出发难有定论，你怎么能看清那是双螺旋而不是椭圆结构呢？而沃森和克里克从理论出发做到心中有谱，一旦有了实验数据，就可以较容易确定其真实结构。</p><p>类比回来，我们获得他人的经验就像实验数据，而仅靠这些还是不能准确地认识未来，还需要我们自己一系列理论推导（揣测，思考）来和实验数据相拟合，以减少预测和现实的误差。</p><p>至于怎么进行揣测，我想模仿数学结论的推导过程，从一些显而易见的结论出发，通过一系列合理的推演，得到一个更深层次的结论。为什么要以这种方式来思考？人本来就容易受到固有思维模式的影响从而带着有色眼镜看问题，无意识地加入自己的倾向。而这种模仿数学的推导方式相对来说最客观。</p><p>当然，我的思考可能不那么严谨，也可能不准确，但我会随着行业的变化或者吸收信息量的增加而不断修正自己的揣测。每个人心仪的行业不同，对各种因素给予的权重不同，所以没有什么正确的答案，我想表达的是一种观察问题的思维方式。很多人都会比较迷茫，不知道以后干啥，到底考研还是工作，到底学这个还是学那个等等，以下是我的一个简单推理。</p><p>公理 1. 大学是我交钱进去的，而企业是花钱招我进去的。</p><p>推论 1.1 大学有责任培养我成才，而企业招我是为了让我创造价值。</p><p>引理：我应该承担自己的责任，但同时不能把自己的命运寄托在他人的责任上。</p><p>推论 1.2 大学学出来不一定能成才，而进入企业的前提是能够为其创造价值。</p><p>总有人问企业重视能力还是成绩，虽然我没工作过，但根据逻辑推导，这取决于成绩和能力具体指什么，到底哪个分量大取决于哪个能给企业创造更大的价值。比如说你是美帝 Top 级别的大学毕业，这种毕业生的工程和学术能力都不会差到哪去，企业大概率会认成绩。而包括我在内的大部分人都不可能达到这个水平，那我心里得有把称了，我这成绩能证明我可以创造价值吗？如果不能，我怎么才能证明我可以创造价值，让人家花钱雇我呢？</p><p>如果你的答案是考研，我个人是这样思考的：我的目标是工作，那么这还是同样一个问题，读完研究生就能为企业创造价值吗？关注的重点是创造价值，而不是学历。再简单点说，学历证明学习的时间较长，能创造价值是指能解决问题，二者不是绝对的因果关系。就我个人而言，排除不喜欢安逸的个性因素，客观来说，考研的不确定性大，包括考试发挥，导师选择等等。我个人就是觉得我的时间很贵，很贵，不能容忍不确定性造成的时间损失。成功也许和学历有关，但是失败跟学历绝对没关系，我暂时不争当人生赢家，只要立于不败之地就好。</p><p>甚至有的人甚至都没有意识到公理 1，以及对 “能力” 这个东西的衡量标准太单一，导致高中生式的思维模式顽固不死。等走出象牙塔，我认为 “我啥都不会做，但我愿意学” 和 “这个我做过” 这两份简历，企业要后者。</p><p>推论 1.2 对我的启发：我的关注重点应该是如何创造价值。具体一点举例，我喜欢做算法和数学题，所以总是花比较多的时间做题而不做项目，最近要帮老师做个插件，就翻白眼了。现在意识到这个推论后，我认为思维能力可以锦上添花，但是写代码相当于最基本的劳动力。不是搞学术的，会再多的奇技淫巧，只能算提高天花板，扩充能力的上限，而如果不会解决业务的需求，那连门槛都迈不进去，就别说天花板了。至于怎么培养工程能力，我还在探索。</p><p>另外，掂量清楚自己的分量也很必要。具体来说，我之前的目标是搞机器学习算法，因为我这个人就喜欢去挑战困难的事，而且这块大红大紫给钱多啊！但是根据分析和过来人的经验，这个目标确实有些不切实际。且不说入坑后发现这块的水有多深，竞争有多激烈，就说接触的圈子和资源直接决定起点的高度，而我的学校，专业无疑都是劣势。</p><p>所以说干脆承认自己的平凡，先进了行业的门槛，再持续精进就好。本科几年在漫长的职业生涯中的只是个短暂的准备活动，首先把心态摆正，踏进起点再说。没办法赢在起跑线上，就算了，终点线才是真正的赢家嘛。</p><p>欢迎关注我的公众号，致力于把事情讲清楚：labuladong</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4k1unaMOseLDCmx5DJDLmfic3TOYvCgzQFlbSLH12nGbxuAwShrERfLV5k70dLPjUCwVNmUjzQib9dQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="公众号二维码"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近跟朋友聊了聊未来，另外还尝试跟老师做了做项目，还有一些乱七八糟的事情，使我有点感想，暂且记录下来。&lt;/p&gt;
&lt;p&gt;先说句题外话，一个朋友跟我说，感觉一个人学习真的挺难的，经常感到孤独或者挫败然后就很难学下去。他觉得我基本就是那种不断学习，还特别有动力的人。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="随笔" scheme="https://fudonglai.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>为什么要写文章</title>
    <link href="https://fudonglai.github.io/2019/03/13/whyWritingArticles/"/>
    <id>https://fudonglai.github.io/2019/03/13/whyWritingArticles/</id>
    <published>2019-03-12T16:12:46.000Z</published>
    <updated>2019-04-30T01:56:33.233Z</updated>
    
    <content type="html"><![CDATA[<p>对于公众号平台，我认为这是一个信息共享的平台，所以我希望传达一些独一无二的内容。什么是独一无二的呢？比如我不想写“XXX 入门攻略”这类文章，不是因为这种题材不好，而是因为网上已经有很多非常优秀的内容了，我写的不一定比他们好，还浪费我和读者的时间；我想写的是自己思考、总结的产出，或是解决问题的思考过程。这些内容是独特的，代表我的思维方式和看问题的角度，说不定能给别人带来新的视角或启发。</p><p>下面进入正题，我为什么要开始写文章（写文章有什么好处）：</p><p><strong>一、促使自己深入地思考</strong></p><p>写文章应该通俗易懂，可以假设自己在给一个完全不懂的人讲解问题，并试图给人家讲清楚。在这个过程中，你会发现很多以前认为显而易见的细节好像不是那么显而易见了，但为了给人家讲清楚，你就得跑去研究，然后自己消化一下再重新来讲，对不对？</p><p>举个例子，如何证明根号二是无理数？大致的思路是反证法：假设根号二是有理数，那么必然可以表示为一个最简分数的形式（比如 1/3, 2/7 不可再化简），假设为 n/d 。然后按以下步骤推出矛盾：n 和 d 都是偶数，即 n/d 不是一个最简分数的形式，从而得证。（图片来源于 MIT 6-042J  Mathematics for Computer Science 公开课）<img src="https://github.com/fudonglai/merge_reponsitories/blob/master/1549960242868.png?raw=true" alt="mit"></p><p>也许看一下这个推导感觉很容易，不过写一下这个过程就会思考一些新问题，比如：为什么有理数一定能被表示成分数？为什么如果一个数的平方是偶数，这个数也是偶数？这些问题都不难解释，但如果不深入一点思考，也不容易注意到，对吧？</p><p>把自己的理解写出来就是一种重新梳理，这个过程会比你想象中更困难更耗时，因为很多小问题促使你深入思考，从而进一步加深之前的理解。写下来，然后分享出来，利人利己。</p><p><strong>二、锻炼表达能力</strong></p><p>大数学家希尔伯特说过：定义清楚一个数学问题，就已经解决了百分之七十了。这句话说明，清晰地逻辑和明确的目标，对于解决问题来说是至关重要的。我所说的表达能力，不是所谓敢不敢说话，而是能不能说清楚。</p><p>把事情讲清楚不是一件简单的事，需要刻意训练的。就我自己而言，我就很难一次性把话讲清楚，具体来说就是有时候突然卡住，不知道用一个什么词语来形容自己想表达的意思，或是话语中难免夹杂一些废话，还有优化的空间。这一点因人而异吧，我和同学交流的比较少，很少在正式场合发言，那些经常演讲、作报告的人也许可以忽略这个问题。</p><p>我认为这个问题产生的原因是自己对某些事物的理解长期以一种思想意识的形态存在在大脑中，一时间要用语言表达出来说给别人听，就容易出现一些词不达意的情况。如果不刻意地定期对大脑中这些理解进行浓缩、组织和联系，就很难准确、精简地表达出来。</p><p>而写文章就能很好地解决这个问题，一方面写文章本身就促进深入思考和知识梳理，另一方面写下来比直接说出来容易得多，因为我们可以慢慢斟酌用词，直到能准确表达意思为止。我相信长此以往，语言的表达能力是能够提高的。我猜这也是为什么越是牛逼的人写出来的东西越是通俗易懂的原因，不仅因为他们心中有完整的知识体系和直达本质的洞察力，而且因为经常说给别人听，能够浓缩和组织自己的观点，达到一针见血的效果。</p><p><strong>三、容易找到志同道合的人</strong></p><p>互联网时代一个不用质疑的变化就是，信息更容易获取，人和人之间更容易建立连接了。在过去，人和人交流需要面对面，而且很可能只局限于自己的圈子；而现在通过互联网可以很容易与他人建立连接，甚至很容易和各个领域的人交流，碰撞思维的火花。但是不管交流的手段如何变化，交流的目的是一致的，就是希望和聊得来，志同道合的人成为朋友。</p><p>按照传统的方式，每遇到一个人都需要通过交流逐渐熟悉才能确定对方是否志同道合。但是对于我这种不太喜欢社交的人来说，这种与他人彼此了解的机会都不多。难道非要改变自己的性格吗？不，我认为聪明人应该充分利用现有资源来灵活拓展，而不是“硬编码”，我来分析一下传统交流方式的劣势：</p><p>问题一，在生活中受圈子所限，接触到的同学同事有限，很难接触新的人。一方面你可能会觉得无聊，另一方面，如果你是所处圈子中能力比较强的，会感到难以进步。解决这个问题很简单，只要保持开放的心态，善用互联网，很容易连接到真正的大牛，跟人家学习，看到自己的差距所在。</p><p>问题二，每次遇到新的人，都得从头开始，慢慢了解彼此。从算法分析的角度来说，这就属于冗余的操作，会降低效率；从软件开发的角度来看，这就属于重复造轮子，完全不可复用。解决的办法很简单，使用某些载体来记录自己的思想，做到“高效，可复用”。而文字表达应该是最简单，最亲民的方式了。</p><p>综上，以文字为载体表达自己的价值观或思想产出，发布到个人博客这类平台上，是最容易让他人了解自己，结交朋友的。我自己就在网上认识了不少大佬，获得了不少帮助，我想如果哪天我们能见面，肯定也能像老朋友一样有共同聊天话题。</p><p>另外，从经济学的角度看，人与人成为朋友的一个前提是消除信息不对称，简单来说就是，你怎么能证明我们应该成为朋友呢？叫我做你的朋友，凭什么呢？解决这种问题的一个方法就是“发信号”。举例来说，当你走进一家餐厅，发现他家的餐具都是银制的，吊灯都是翡翠的，那么毫无疑问，他家的菜品一定是一流的。奢侈摆设就是“信号”，普通的餐厅一定用不起这种摆设。那么说话回来，一个一直是学霸的人，一个精通某项技能的人，或是一个长期输出优质内容的人，都能发出这种“信号”证明自己的不一般，这也是获得别人认可的重要条件。</p><p><strong>四、养成良好的学习习惯</strong></p><p>自从我开始尝试写文章，主要养成了深入思考和整理记录的习惯。首先如果没有思考的习惯，根本就写不出什么独特的，有价值的东西，上文说过，不再赘述。记录的习惯是很重要的，就是说记录下来碰到深刻的见解或者自己的灵机一动并简单整理。这个小举动有两个作用，一是积累素材，可以引用进自己的文章；二是便于对零碎的灵感进行整合，相当于线索，更容易构建完整的知识体系。</p><p>举例来说，我的电脑桌面上有很多文本文件，都是经过分类的，每当我想到一些有趣的问题或观点时，我就记录进相应的文件，慢慢积累并时常整理。就是说我写文章不是“串行”而是“并行”的，这个习惯虽然不起眼，但任何事积累起来就不得了了。</p><p>我从反面论证记录整理的必要性。回想高中时代，我做数学物理题都懒得拿一张像样的草稿纸，直接在练习册上打草稿，数字也写得乱七八糟，我相信很多人，尤其是男生都跟我一样有这毛病。数学题需要清晰的逻辑，没有有条理的记录恐怕都无法检查，而且一旦出错就得全部重来，这就是屡屡算不对答案的原因。有条理的记录则会带来很多方便。</p><p>从历史的角度看，记录有价值的信息是后人“站在巨人肩膀上”的基础。中国是第一个发明瓷器的国家，但是为什么说欧洲“再发明”了瓷器？因为欧洲工匠有详细的实验记录，以致最终形成一套体系，可以制出各种瓷器，而古代中国由于政治原因，不但没有形成体系，一些技术反而由于没有记录而永久失传了。</p><p><strong>五、学会坚持做一件事</strong></p><p>”坚持“这个话题老生常谈了，坚持的力量是巨大的，这个道理很简单，简单的道理最稳固。很多人都喜欢用丧、颓废这种词来形容自己，我不知道是在调侃还是认真的。如果真是这样，我认为问题的原因是没有真正意义上坚持并成功地完成一件事，不妨拿写文章开个先河，试着坚持下去？毕竟成功才是成功之母。</p><p>我认为用文字表达自己并获得别人的共鸣不会太难，何况文章写得好是可以变现的资本，难道这还不足以让人心动？当然前提是内容要足够优质，自己要有足够的底蕴，如果获得了认可，那么更应该坚持下去，并倒逼自己更加努力学习。</p><p>至于如何坚持，我自认为还是有点发言权的，这个可以另写一篇文章了，这里简单提两点：你越把未来看得越大，越清楚，自律就越强；多跟优秀的人在一起，多看看自己和大佬的差距，你就知道自己该不该努力了。</p><p>互联网给了无数草根逆袭的机会，那些抖音网红，人气主播都是善于抓住机会的人，不要看不起他们，能合理合法赚到钱就是本事。像我这种没法靠脸吃饭的人，也许只能通过文字输出来顺应互联网浪潮了吧。</p><p>任何使自己进步的过程都是反人性的，唯一的办法就是养成习惯。我会坚持下去，也希望读者能从这篇文章中获得一点启发。</p><p>欢迎关注我的公众号，致力于把事情讲清楚：labuladong</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4k1unaMOseLDCmx5DJDLmfic3TOYvCgzQFlbSLH12nGbxuAwShrERfLV5k70dLPjUCwVNmUjzQib9dQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="公众号二维码"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于公众号平台，我认为这是一个信息共享的平台，所以我希望传达一些独一无二的内容。什么是独一无二的呢？比如我不想写“XXX 入门攻略”这类文章，不是因为这种题材不好，而是因为网上已经有很多非常优秀的内容了，我写的不一定比他们好，还浪费我和读者的时间；我想写的是自己思考、总结的
      
    
    </summary>
    
      <category term="随笔" scheme="https://fudonglai.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>浅谈递归</title>
    <link href="https://fudonglai.github.io/2019/01/30/TalkAboutRecursion/"/>
    <id>https://fudonglai.github.io/2019/01/30/TalkAboutRecursion/</id>
    <published>2019-01-30T14:35:40.000Z</published>
    <updated>2019-01-30T14:41:29.277Z</updated>
    
    <content type="html"><![CDATA[<p>递归，是计算机独有的技能，由于我们的大脑无法堆栈记录状态，所以很难递归的解决问题。但是，递归的思想是可以练就的，有了思想，就命令计算机去完成操作就行了。不要看数学上的什么递归式求封闭解，一堆推倒让人不想看，我们有计算机，不需要求递推封闭解就能优雅解决问题。</p><a id="more"></a><p>以下会举例说明我对递归的一点理解，<strong>如果你不想看下去了，请记住这几个问题怎么回答：</strong></p><ol><li>如何给一堆数字排序？ 答：先排左边再排右边，最后合并就行了，至于怎么排左边和右边，请重新阅读这句话。</li><li>孙悟空身上有多少根毛？ 答：一根毛加剩下的毛。</li><li>你今年几岁？ 答：去年的岁数加一岁……</li></ol><p>递归代码最重要的两个特征：结束条件和自我调用。自我调用是在解决子问题，而结束条件定义了最简子问题的答案。其实仔细想想，<strong>递归运用最成功的是什么？我认为是数学归纳法。</strong>我们高中都学过数学归纳法，使用场景大概是：我们推不出来某个求和公式，但是我们试了几个比较小的数，似乎发现了一点规律，然后编了一个公式，看起来应该是正确答案。但是数学是很严谨的，你哪怕穷举了一万个数都是正确的，但是第一万零一个数正确吗？这就要数学归纳法发挥神威了，可以假设我们编的这个公式在第 k 个数时成立，如果证明在第 k + 1 时也成立，那么我们编的这个公式就是正确的。</p><p>那么数学归纳法和递归有什么联系？我们刚才说了，递归代码必须要有结束条件，如果没有的话就会进入无穷无尽的自我调用，直到内存耗尽。而数学证明的难度在于，你可以尝试有穷种情况，但是难以将你的结论延伸到无穷大。这里就可以看出联系了 —— 无穷。</p><p>递归代码的精髓在于调用自己去解决规模更小的子问题，直到到达结束条件；而数学归纳法之所以有用，就在于不断把我们的猜测递归地加一，扩大结论的规模，没有结束条件，从而把结论延伸到无穷无尽，也就完成了猜测正确性的证明。</p><p><strong>从编程的视角来看</strong>（后续准备写一篇从归纳法出发，指导编程的文章），为什么要递归？</p><p>首先为了训练逆向思考的能力。递推的思维，总是看着眼前的问题思考对策，解决问题是将来时；递归的思维，逼迫我们倒着思考，看到问题的尽头，把解决问题的过程看做过去时。</p><p>第二，练习分析问题的结构，当问题可以被分解时，你能敏锐发现这个特点，进而高效解决问题。多想想归并排序是怎么做的。</p><p>第三，跳出细节，从整体上看问题。再说说归并排序，其实可以不用递归来划分左右区域的，但是代价就是代码极其难以理解，大概看一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> N = a.length;</span><br><span class="line">    <span class="comment">// 这么复杂，是对排序的不尊重。我拒绝研究这样的代码。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> sz = <span class="number">1</span>; sz &lt; N; sz = sz + sz)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lo = <span class="number">0</span>; lo &lt; N - sz; lo += sz + sz)</span><br><span class="line">            merge(a, lo, lo + sz - <span class="number">1</span>, Math.min(lo + sz + sz - <span class="number">1</span>, N - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 我还是选择递归，简单，漂亮 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    sort(a, lo, mid);</span><br><span class="line">    sort(a, mid + <span class="number">1</span>, hi);</span><br><span class="line">    merge(a, lo, mid, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来简洁漂亮是一方面，关键是可解释性很强：把左半边排序，把右半边排序，最后合并两边。而非递归版本看起来不知所云，充斥着各种难以理解的边界计算细节，而且归并排序的空间复杂度只有 logn ，对数级别的复杂度更常数级也差不多了，所以我更倾向于递归版本。</p><p>显然有时候递归处理是高效的，比如归并排序，有时候是低效的，比如数孙悟空身上的毛，因为堆栈会消耗额外空间，而简单的递推不会消耗空间。比如这个例子，给一个链表头，计算它的长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 典型的递推遍历框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node p = head; p != <span class="keyword">null</span>; p = p.next) size++;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 我偏要递归，万物皆递归 */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> size(head.next) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<strong>写递归的技巧</strong>，之前讲快排和归并的文章写了：明白一个函数的作用并相信它能完成这个任务，千万不要试图跳进细节。以下用 LeetCode 的一道题来说明：给一课二叉树，和一个目标值，节点上的值有正有负，返回树中和等于目标值的路径条数，让你编写 pathSum 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/* 来源于 LeetCode PathSum III： https://leetcode.com/problems/path-sum-iii/ */</span><br><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">      10</span><br><span class="line">     /  \</span><br><span class="line">    5   -3</span><br><span class="line">   / \    \</span><br><span class="line">  3   2   11</span><br><span class="line"> / \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 看不懂没关系，底下有更详细的分析版本，这里突出体现递归的简洁优美 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> count(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(TreeNode node, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (node.val == sum) + count(node.left, sum - node.val) + count(node.right, sum - node.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目看起来很复杂吧，不过代码却极其简洁，这就是递归的魅力。我来简单总结这个问题的<strong>解决过程</strong>：</p><p>首先明确，递归求解树的问题必然是要遍历整棵树的，所以二叉树的遍历框架（分别对左右孩子递归调用函数本身）必然要出现在主函数 pathSum 中。那么对于每个节点，他们应该干什么呢？他们应该看看，自己和脚底下的小弟们包含多少条符合条件的路径。好了，这道题就结束了。</p><p>按照前面说的技巧，根据刚才的分析来定义清楚每个递归函数应该做的事：</p><p>PathSum 函数：给他一个节点和一个目标值，他返回以这个节点为根的树中，和为目标值的路径总数。</p><p>count 函数：给他一个节点和一个目标值，他返回以这个节点为根的树中，能凑出几个以该节点为路径开头，和为目标值的路径总数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 有了以上铺垫，详细注释一下代码 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pathImLeading = count(root, sum); <span class="comment">// 自己为开头的路径数</span></span><br><span class="line">    <span class="keyword">int</span> leftPathSum = pathSum(root.left, sum); <span class="comment">// 左边路径总数（相信他能算出来）</span></span><br><span class="line">    <span class="keyword">int</span> rightPathSum = pathSum(root.right, sum); <span class="comment">// 右边路径总数（相信他能算出来）</span></span><br><span class="line">    <span class="keyword">return</span> leftPathSum + rightPathSum + pathImLeading;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(TreeNode node, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == null) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 我自己能不能独当一面，作为一条单独的路径呢？</span></span><br><span class="line">    <span class="keyword">int</span> isMe = (node.val == sum) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 左边的小老弟，你那边能凑几个 sum - node.val 呀？</span></span><br><span class="line">    <span class="keyword">int</span> leftBrother = count(node.left, sum - node.val); </span><br><span class="line">    <span class="comment">// 右边的小老弟，你那边能凑几个 sum - node.val 呀？</span></span><br><span class="line">    <span class="keyword">int</span> rightBrother = count(node.right, sum - node.val);</span><br><span class="line">    <span class="keyword">return</span>  isMe + leftBrother + rightBrother; <span class="comment">// 我这能凑这么多个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是那句话，明白每个函数能做的事，并相信他们能够完成。</p><p>总结下，PathSum 函数提供的二叉树遍历框架，在遍历中对每个节点调用 count 函数，看出先序遍历了吗（这道题什么序都是一样的）；count 函数也是一个二叉树遍历，用于寻找以该节点开头的目标值路径。好好体会吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;递归，是计算机独有的技能，由于我们的大脑无法堆栈记录状态，所以很难递归的解决问题。但是，递归的思想是可以练就的，有了思想，就命令计算机去完成操作就行了。不要看数学上的什么递归式求封闭解，一堆推倒让人不想看，我们有计算机，不需要求递推封闭解就能优雅解决问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Recursion" scheme="https://fudonglai.github.io/tags/Recursion/"/>
    
      <category term="Tree" scheme="https://fudonglai.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>何为优质？</title>
    <link href="https://fudonglai.github.io/2019/01/27/SuperiorQuality/"/>
    <id>https://fudonglai.github.io/2019/01/27/SuperiorQuality/</id>
    <published>2019-01-27T05:55:51.000Z</published>
    <updated>2019-01-27T05:57:19.672Z</updated>
    
    <content type="html"><![CDATA[<p>一直在学习薛兆丰老师的经济学专栏，发现经济学的思维真是眼光独到，感觉不写点感悟分享出来真是一种浪费。</p><p>优质来自比较，世界上存在优质产品和低质产品，问题是如何区分它们。从经济学观点看，什么叫优质产品？</p><a id="more"></a><p>一、品质稳定。</p><p>我认为包括空间和时间上的稳定。比如说，星巴克在美国的营业点和中国的营业点，提供的饮品口味都是一致的；而且饮品几年前的口味和现在的口味是差不多的。匀质是优质的必要条件，如果说星巴克在全球各地的产品品质差异很大，怎么可能享誉世界。厂家整齐划一的质量管理，就能从侧面反应厂家在质量上下的功夫，一个产品能保持质量稳定很多年是一件难得的事。就说我们个人，也没有哪件事是坚持了多年保质保量完成的吧。</p><p>二、性价比相当</p><p>这一点似乎很多人都明白，但是我们一般人所说的性价比，都是“横向”的性价比，比如说有人会认为小米手机性价比比苹果手机高之类，这种性价比属于不同产品之间的横向比较。而我想说的是同一个产品“纵向的”性价比，比如说新出的双卡双待 iPhone ，用户购买“双卡双待”这个新功能所付出的成本如果大于使用这个功能的收益，那么性价比就低，反之就高。至于这个功能的性价比我没用过不清楚，不过根据别人的评价，iPhone 双卡双待这个功能的性价比似乎是较低的。</p><p>说的通俗一点，不是质量越高越好，也不是价格越低越好，而是一分价钱一分货，对用户有用才是最好的。专业一点，就是在提高质量的过程中，边际收益等于边际成本时应该停止继续提高了，否则成本大于收益，性价比就会下降，而多出的这些成本，实际上都是消费者来买单。</p><p>其实很多社会事件也可以用经济学眼光看待，是么叫性价比相当？</p><p>再举专栏里的一个例子：几年前一个乡村的一辆校车发生意外，造成严重伤亡，结果社会各界人士就站出来说应该制定校车的安全标准。有律师参加制定这样的标准，但是最终没有制定出来，为什么呢？因为凭空写出来的标准，跟坦克车差不多了，如果要求不够高，出了事就是写标准的人的失职，而太高了的结果就是，学校和家长要承担高额的费用，实际上大家都买不起这样的校车。</p><p>一般人可能会说，那政府强制学校和家长购买这样的校车不就行了？这就是典型的缺乏经济学思维的想法，用经济学的眼光可以看到看不到的东西，你以为强制实施真的就实施了吗？学校和家长一定会有相应的对策，包括采用成本更低但安全性也更低的交通方式，比如骑自行车。</p><p>总结一下，我们做事应该算算边际成本和边际收益，盲目地提高质量也是一种错误。</p><p>发表一点感想：经济学是一种独特思维方式，让我们看到看不见的东西。我列举几个自认为很有趣的例子：</p><ol><li>小偷为什么会对社会有害呢？应为小偷只是对财富进行转移，并没有减少社会的财富总量啊？经济学告诉我们，小偷确实没有减少社会财富，但是增加了社会造锁的成本。</li><li>春节车票凭什么涨价，就不能强制压低价格吗？经济学告诉我们，涨价市场价格的自然调节，不应该强制干预，如果真的强制干预可能适得其反，比如说春运期间价格压下来，那么对于铁路公司，这部分收入的减少必然需要弥补，那么平时的车票就会涨价；价格上涨反应的是需求的增加，如果强压住价格这个尺度，那么就会引发其他尺度的竞争，甚至黑幕交易，这显然是不希望看到的。</li></ol><p>还有很多例子，以后有时间都写写感悟分享出来，经济学思维能跳出固有的思维模式，客观的看待问题，起码不会活在理想的世界里。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直在学习薛兆丰老师的经济学专栏，发现经济学的思维真是眼光独到，感觉不写点感悟分享出来真是一种浪费。&lt;/p&gt;
&lt;p&gt;优质来自比较，世界上存在优质产品和低质产品，问题是如何区分它们。从经济学观点看，什么叫优质产品？&lt;/p&gt;
    
    </summary>
    
      <category term="经济学思维" scheme="https://fudonglai.github.io/categories/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E6%80%9D%E7%BB%B4/"/>
    
    
      <category term="other" scheme="https://fudonglai.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>我是这样思考的</title>
    <link href="https://fudonglai.github.io/2019/01/26/HowToThink/"/>
    <id>https://fudonglai.github.io/2019/01/26/HowToThink/</id>
    <published>2019-01-26T14:12:30.000Z</published>
    <updated>2019-02-19T04:55:58.431Z</updated>
    
    <content type="html"><![CDATA[<p>今天写两道题的思考过程吧，算法嘛，就不要像高中生那样死记硬背解法了，我个人认为，一方面不断积累见过的问题类型，另一方面要敢于天马行空地思考，说不定就“灵机一动”突破了固有的人类思维，获得了 logn 的黑魔法呢？以下简单说说我的一些思路。</p><a id="more"></a><p>我认为对问题的观察和思考的重要性是高于给出问题的具体解法的，思考需要天马行空，想想有什么不可以呢，很多灵感其实都是问题在不同维度的碰撞产生的。以下简单聊聊从古语中窥探算法的思路。</p><p>这个问题是：给一个长度为 n 的数组，其中有一个数字出现的次数大于 n / 2，称这个数为 “众数” ，请找出这个众数。比如 [1,2,3,2,2]，这个元素就是 2 。</p><p>关键在于，如何最大限度利用信息。根据香农大佬的理论，信息可以消除不确定性，对于算法来说，<strong>充分利用信息必然可以提高算法的效率</strong>。这道题当然可以用一个字典记录各个不同元素出现的次数，但是应该这样想：如果目标元素出现的次数不是大于总数的一半，这种方法一样可以解决，所以说这个方法是泛化的，没有利用这个题目的特殊性。不必说，不是最优的，浪费了空间。</p><p>既然知道目标元素出现的次数是大于元素总数的一半的，那么就要想如何利用这个信息，回忆一下相似的问题解法。首先，简单分析这个问题的特性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">显然，如果众数一定存在，那么这些数字排序后，中间的那个数一定是众数。</span><br></pre></td></tr></table></figure><p>根据这个性质，我们自然可以想到排序，比如快排，可以不耗费内存空间，花费 nlogn 的时间就可完成。不过进一步思考：<strong>算法的核心在于让计算机少做事情</strong>，我们只想要中间的那一个数，如果全排序的话显然让计算机多做了不必要的事，所以可以进一步优化，用快速选择算法选择第 n / 2 个元素就行了，可以进一步减少时间耗费。</p><p>PS：快速选择很好理解，实际上就是快排的分区函数的变形，利用了这个事实：每次分区点之前的值都小于该点，之后的值都大于该点。只要稍作修改，不用全排序就可以得到第 k 大的值。</p><p>想到这里，这个特性能挖掘利用的信息似乎已经到头了，没法再进一步优化了。现在我们退一步想，是否还有更多有趣的特性信息没有被我们发现呢？怎么思考这个问题呢，还记得递归思维的精髓是什么吗？是想办法<strong>缩小问题的规模，分而治之</strong>。这个问题能不能分治呢？尝试一下：如果把原数组一分为二，众数可能转移到其中任意一半，或是同时分布在两半中，显然没办法合并出答案。</p><p>不过这并不代表我们这个思路白想了，思考将数组一分为二的思路失败的原因，是由于分解问题的力度太大了，导致结果的不确定性。那么可以力度小一点试试。</p><p>想想这句古语：“以正和，以奇胜”。这个“奇”字是多音，奇数的那个音。意思是打仗要靠人多，小于等于敌方兵力的那部分就中和了，要靠多出来的那部分取胜。我们根据古语，设想一个战场上两国战士厮杀，可以观察得到这个事实：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在原来的数组中，如果 m ！= n ，那么同时删除这两个数之后，数组中的众数不会发生变化。</span><br></pre></td></tr></table></figure><p>怎么样，这是一个很好的优化入口，可以缩小问题规模，而且能维持答案的正确性，当然我们的前提是确定数组中存在众数。这再次证明，只要你敢想，总会有点意想不到的发现。明白了原理，代码就不难理解了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> majority = nums[<span class="number">0</span>], count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == majority) &#123; count++; &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">0</span>)  &#123; majority = nums[i]; &#125; </span><br><span class="line">        <span class="keyword">else</span>  &#123; count--; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> majority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解法在 O(n) 时间内就能完成，应该是最优化的方案了。不过我认为我们不该局限在计算机算法上，这个问题似乎也是个统计问题，显然如果数据量非常大，遍历一遍都嫌多（比如说，设想给天上所有星星的质量找众数），那咋整呀？其实我们完全可以换个思路嘛，如果数据集中的值是随机分布的，我们取一小部分出来分析，比如说拿一万个出来，找到他们的众数，根据最基本的概率论原理，这个众数就是原数据集的众数呀！话说回来，如果数据集不是随机的也好办，我们自己随机选取不就行了！其实这属于概率算法，很有趣的，其中比较有名的有蒙特卡罗方法，简单而有效，以后有机会写一写。</p><p>最后说说这句古语吧。“以正和，以奇胜” 告诉我们不要过度迷信所谓弯道超车，出奇制胜。历史上出奇制胜，以少胜多的例子是有的，而且以后一定还会有，但这属于特例。我们不应该抱有妄念，企图以特例搏总体。具体到生活中，我觉得可以总结成以下三点：</p><ol><li>不要幻想好运从天而降，任何事情的成功都是从量变的积累到质变的飞跃的。期待着彩票中一百万，不如踏踏实实学习积累，化茧成蝶。</li><li>明白自己能力的边界，不去奢求超出能力范围外的事。比如说，我高中数学考试总喜欢去怼最难的导数、几何题，结果就是难题带来的分没有简单题丢掉的分多。我这就是还没有 “正和” 呢，就想着 “奇胜”，自然是考不好的。</li><li>差异化不是目标，做好事情才是目标。比如说，看一个人代码写得好不好，在于是否利用了高效的算法，合理的设计模式，而不在于用的什么语言，用的是 IDE 还是记事本。把事情做好，本身就是一种差异化。</li></ol><p>希望这篇文章能带给你一些启发～</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天写两道题的思考过程吧，算法嘛，就不要像高中生那样死记硬背解法了，我个人认为，一方面不断积累见过的问题类型，另一方面要敢于天马行空地思考，说不定就“灵机一动”突破了固有的人类思维，获得了 logn 的黑魔法呢？以下简单说说我的一些思路。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Array" scheme="https://fudonglai.github.io/tags/Array/"/>
    
      <category term="Other" scheme="https://fudonglai.github.io/tags/Other/"/>
    
  </entry>
  
  <entry>
    <title>二分搜索详解</title>
    <link href="https://fudonglai.github.io/2019/01/21/BinarySearch/"/>
    <id>https://fudonglai.github.io/2019/01/21/BinarySearch/</id>
    <published>2019-01-21T08:14:29.000Z</published>
    <updated>2019-04-30T01:57:38.943Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找，学过一点点算法的人都会，但是很简单的查找算法变体非常广泛，并且非常不容易写正确，不信你就试试？几个月前在 LeetCode 看二分搜索的时候就有点云里雾里，道理我都懂，怎么就是写不对？？现在再回头做以前的题，好像有点开窍了，赶紧记录下来。</p><a id="more"></a><p><strong>PS：Template II 是最核心的结论。</strong></p><p>首先，二分搜索不是只能简简单单的在一堆有序数列中找一个元素，再设计算法时，只要看到有序序列，第一就要想到 Binary Search，这是最高效的算法，<strong>具体操作区别在于”二分“判断的部分</strong>。总体来说，二分查找的框架是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums，<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, <span class="keyword">int</span> hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>; <span class="comment">//防止溢出而已</span></span><br><span class="line">        <span class="keyword">if</span> (左半边可以排除)</span><br><span class="line">            调整 lo;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            调整 hi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo 或 hi 或 <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个简单的框架有四个地方可以自由设计：</p><ol><li><code>hi</code>的取值，可以取为<code>nums.size() - 1</code>，也可能是<code>nums.size()</code>，看具体用哪一个代码模板了（下文讲到）。</li><li>如果使用不同模板，<code>while</code>条件的判断也不同，取决于上一条。</li><li>mid 的计算，我们知道计算机除法是向下取整，所以这个 mid 并不一定是严谨的正中间，有可能会偏差，但这个偏差一定是偏左。注意到这一点会帮助我们在模板二的调整操作。</li><li>如何调整<code>lo</code>和<code>hi</code>，到底等于<code>mid</code>还是<code>mid+１</code>还是<code>mid-1</code>？这个取决于上一点，还取决于我们要搜索 target 的左侧边界还是右侧边界。你要问 target 不就是一个数吗，为什么还有左侧右侧边界？应为这个序列不一定是没有重复数字的，假设序列 <code>[1,2,3,3,4]</code>，让你查找 3 的区间，你是是不是得查找左侧边界和右侧边界？</li></ol><h1 id="Template-I"><a href="#Template-I" class="headerlink" title="Template I"></a>Template I</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// found target</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简陋的二分查找函数，只能查找单个元素，我还没想到什么适合它的变体。而且它的结果是”随机“的，就是说遇到有 target 值重复的情况，根据初始 lo 和 hi 的值的不同，返回的 target 索引可能是不同的。</p><p>话说为什么会这样？因为有一个条件判断了<code>nums[min] == target</code>的情况，这就是说只要找到了就 return，自然无法找到重复 target 的边界了。我个人不喜欢这样的搜索，有点”硬编码“的味道，我还是喜欢不用 <code>==</code>判断，让算法自然收敛到左侧或者右侧，后面的模板都按自然收敛的风格设计。</p><p>这样有啥好处呢？平均复杂度确实低一些，比如说有可能第一次循环就恰好落到 target 值了，那就直接结束了。而自然收敛的算法复杂度是稳定的 O(lgn)。不过，lgn 你懂得，顶级黑魔法了，根本不在乎多搜索这几下嘛。</p><h1 id="Template-II"><a href="#Template-II" class="headerlink" title="Template II"></a>Template II</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            hi = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            lo = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[lo] == target ? lo : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找的高级模式，注意区别，把每轮循环对<code>hi</code>的更新修改了，把等号和大于号合并了，并在开头添加了判断。</p><p>这里的精髓有两个：</p><ol><li>到底是<code>&gt;=</code>还是<code>&lt;=</code>？</li><li>到底是<code>lo = mid + 1</code>还是<code>hi = mid - 1</code>还是<code>lo</code>和<code>hi</code>都等于<code>mid</code>？</li></ol><p><strong>解决第一个问题的关键是判断 <code>nums[mid]</code> 恰好撞上 <code>target</code> 的情况，来决定带不带等号。</strong>我发现必须是 hi = mid 那个判断带等号，这是这个框架决定的，应为除法自然向下取整，恰好撞上 target 时必须是 hi = mid，否则如果是 lo = mid + 1 的话会跳过这个 mid，也就是跳过了 target，跳过了正确结果，必然是错误的。</p><p><strong>解决第二个问题的关键是思考算法结束的最后一步，已经收缩到两个元素了，不妨假设在<code>[1,2]</code>中搜索 2</strong>，计算mid 时结果不可避免地偏左，这就必须要求<code>lo</code>必须自加才能满足 while 的结束条件，否则就会陷入无限循环（模板三解决该问题就不需要自加，而是直接更改了 while 的条件）。</p><p>在解决问题的同时我发现这个算法结果是左侧边界，为什么，是因为除法自然左偏的结果吗？不是！而是 if 条件判断中不等号中等号的位置来决定，当算法计算出<code>nums[mid] == target</code> 时，执行的更新<code>hi</code>的操作，就是说<code>hi</code>在向左收敛，最终收敛到左侧边界。</p><p>那我把等号给到小于判断上，是不是就可以收敛到右侧边界？不行！上面第一个问题就在解释，这是必须的，由除法向下取整的性质决定的，请仔细体会下。</p><p><strong>所以总结下，以上逻辑的因果链是：由于除法的向下取整性质，决定了必须是<code>lo = lo + 1</code>以避免无限循环，从而决定了等号必须给到大于号，否则算法会跳过正确答案而出错；因此此算法的结果是收敛到左侧边界的。</strong></p><p>那么我就是想让算法收敛到右侧怎么办？根据以上的因果链，关键在于除法的性质，如果让除法能向上取整就好说了。这个简单，这样写都可以：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (lo + hi + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (lo + hi) / <span class="number">2</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>不一定要严谨的向上取整，因为算法会自然调整，只要避免无限循环就会收敛。向右取整决定了避免无限循环必须更新<code>hi = mid - 1</code>；更改<code>hi</code>就决定了等号需要给到更新<code>lo</code>的条件判断里，也就是必须<code>&lt;=</code>。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (lo + hi + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// int mid = lo + (hi - lo) / 2 + 1; Both OK</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            hi = mid - <span class="number">1</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            lo = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[hi] == target ? hi : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，到此，二分搜索的代码写起来已经不会有啥 bug 了，而且能够自由调整收敛方向，这个模板是我最常用的。下面再介绍一种模板吧，其实和这个差不多，一个原理，了解一下好了。</p><h1 id="Template-III"><a href="#Template-III" class="headerlink" title="Template III"></a>Template III</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) <span class="comment">//!!!</span></span><br><span class="line">                hi = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lo = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hi == nums.size())  <span class="keyword">return</span> nums[lo] == target ? lo : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[lo] == target) <span class="keyword">return</span> lo; <span class="comment">//!!!</span></span><br><span class="line">        <span class="keyword">if</span> (nums[hi] == target) <span class="keyword">return</span> hi; <span class="comment">//!!!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">higher_bound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) <span class="comment">//!!!</span></span><br><span class="line">                hi = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                lo = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hi == nums.size())  <span class="keyword">return</span> nums[lo] == target ? lo : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[hi] == target) <span class="keyword">return</span> hi; <span class="comment">//!!!</span></span><br><span class="line">        <span class="keyword">if</span> (nums[lo] == target) <span class="keyword">return</span> lo; <span class="comment">//!!!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个模板有它的特色，就是不用担心陷入无限循环，搜索左侧边界和右侧边界除了等号的区别外，还有个判断先后的问题需要注意，不过这些细节只要认真研究边界情况，都可解决。</p><h1 id="Easy-Problem"><a href="#Easy-Problem" class="headerlink" title="Easy Problem"></a>Easy Problem</h1><p>给一个数组，如何找到<code>peak element</code>的索引？比如 [1,2,3,4,3,2,1] 中 4 就是<code>peak element</code>，返回 4 的索引 3 。假设<code>nums[-1]</code>和<code>nums[nums.size()]</code>都是<code>-inf</code>。</p><p>这就是二分搜索的简单变体啊，只不过把 <code>nums[mid]</code> 和 target 的大小判断改成了<code>nums[mid]</code>处在”上坡“还是”下坡“的判断罢了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>欢迎关注我的公众号，致力于把事情讲清楚：labuladong</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4k1unaMOseLDCmx5DJDLmfic3TOYvCgzQFlbSLH12nGbxuAwShrERfLV5k70dLPjUCwVNmUjzQib9dQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="公众号二维码"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二分查找，学过一点点算法的人都会，但是很简单的查找算法变体非常广泛，并且非常不容易写正确，不信你就试试？几个月前在 LeetCode 看二分搜索的时候就有点云里雾里，道理我都懂，怎么就是写不对？？现在再回头做以前的题，好像有点开窍了，赶紧记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Search" scheme="https://fudonglai.github.io/tags/Search/"/>
    
      <category term="Array" scheme="https://fudonglai.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>感知机</title>
    <link href="https://fudonglai.github.io/2019/01/16/Perceptron/"/>
    <id>https://fudonglai.github.io/2019/01/16/Perceptron/</id>
    <published>2019-01-16T02:46:07.000Z</published>
    <updated>2019-04-30T01:57:19.204Z</updated>
    
    <content type="html"><![CDATA[<p>纸上得来终觉浅，绝知此事要躬行，只有亲自实现一个简单的感知机，遇到各种突发奇想的疑问然后尝试解决，才能真正掌握原理。<br><a id="more"></a></p><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><p>输入空间为 $\chi \in R^n$，输出空间 $\Upsilon \in {+1,-1}$，输入空间到输出空间映射的函数为<br>$$f(x) = sign(w \cdot x + b)$$</p><p>其中符号函数<br>$$ sign(x) =<br>\begin{cases}<br>+1, &amp; x&gt;=0 \<br>-1, &amp; x&lt;0 \<br>\end{cases} $$</p><p>只要数据集线性可分，就可以把所有实例点正确划分到超平面两侧，即对于 $y = +1$ 的点，$w \cdot x &gt; 0$，对于 $y = -1$ 的点，$w \cdot x &lt; 0$</p><h1 id="学习策略"><a href="#学习策略" class="headerlink" title="学习策略"></a>学习策略</h1><p>学习的目的就是最优化问题，就是最小化误分点个数，但是误分点个数显然是离散的，无法求导，所以感知机模型采取所有 <strong>误分点</strong> 到超平面的距离：<br>$$\frac{1}{||w||} |w \cdot x_i + b|$$</p><p>注意这个公式是初中就学过的点到直线的距离公式，把点坐标代入直线方程求绝对值然后放到分子，再把直线方程系数做平方和开根号放到分母。这个公式就是那个公式的通用版，适用于高维超平面而已。</p><p>那么如何才能找到误分点呢，仔细看下本段落标题上面那句话，知道了正确划分，自然就知道了错误划分的表现。同时注意符号，求解优化问题，我们都要改成求最小值问题。设集合 $M$ 是误分点集合，所有误分点到超平面总距离为</p><p>$$-\sum_{x_i \in M}\frac{1}{||w||} y_i (w \cdot x_i + b)$$</p><p>由此我们可以定义损失函数<br>$$L(w, b) = -\sum_{x_i \in M} y_i (w \cdot x_i + b)$$</p><p>求解最小化问题<br>$$\min_{w,b} L(w, b) = -\sum_{x_i \in M} y_i (w \cdot x_i + b)$$</p><p>按照梯度的方向下降就能减少误分点了<br>$$\nabla_w L(w, b) = -\sum_{x \in M} y_ix_i$$<br>$$\nabla_b L(w, b) = -\sum_{x \in M} y_i$$</p><p>每次对参数进行更新<br>$$w \leftarrow w + \eta y_i x_i$$<br>$$b \leftarrow b + \eta y_i$$</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n, l=<span class="number">0.001</span>)</span>:</span></span><br><span class="line">    <span class="string">""" n 为数据维度，l 为梯度步长 """</span></span><br><span class="line">        self.w = np.ones(n, dtype=np.float32)</span><br><span class="line">        self.b = <span class="number">0</span></span><br><span class="line">        self.l = l</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sign</span><span class="params">(self, X, y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (self.w @ X + self.b) * y</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fit</span><span class="params">(self, X_train, y_train)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            wrong_count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(X_train)):</span><br><span class="line">                X = X_train[i]</span><br><span class="line">                y = y_train[i]</span><br><span class="line">                <span class="keyword">if</span> self.sign(X, y) &lt;= <span class="number">0</span>:</span><br><span class="line">                    self.w += self.l * np.dot(X, y)</span><br><span class="line">                    self.b += self.l * y</span><br><span class="line">                    wrong_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> wrong_count == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> (self.w, self.b)</span><br></pre></td></tr></table></figure><p>用 <code>sklearn</code> 包中 <code>iris</code> 数据集作为测试数据集，一系列处理后画图<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">perceptron = Model(<span class="number">2</span>, <span class="number">0.01</span>)</span><br><span class="line">perceptron.fit(X, y)</span><br><span class="line">x_points = np.linspace(<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>)</span><br><span class="line">y_points = <span class="number">-1</span>*(perceptron.w[<span class="number">0</span>] * x_points + perceptron.b)/perceptron.w[<span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p><img src="https://github.com/fudonglai/merge_reponsitories/blob/master/perceptron.png?raw=true" alt="perceptron"></p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><p>在处理数据，将输出空间的数据改成 -1 和 +1 的时候，我在纠结到底应该是在超平面以上是 +1 还是以下是 +1，事实证明都可以，因为参数会自动调整，只要跟着梯度的方向走就行了。</p><p>欢迎关注我的公众号，致力于把事情讲清楚：labuladong</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4k1unaMOseLDCmx5DJDLmfic3TOYvCgzQFlbSLH12nGbxuAwShrERfLV5k70dLPjUCwVNmUjzQib9dQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="公众号二维码"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;纸上得来终觉浅，绝知此事要躬行，只有亲自实现一个简单的感知机，遇到各种突发奇想的疑问然后尝试解决，才能真正掌握原理。&lt;br&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://fudonglai.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Statistics" scheme="https://fudonglai.github.io/tags/Statistics/"/>
    
      <category term="Mathematics" scheme="https://fudonglai.github.io/tags/Mathematics/"/>
    
  </entry>
  
  <entry>
    <title>最小二乘法和正则化</title>
    <link href="https://fudonglai.github.io/2019/01/12/Statistics-1/"/>
    <id>https://fudonglai.github.io/2019/01/12/Statistics-1/</id>
    <published>2019-01-11T17:51:14.000Z</published>
    <updated>2019-01-16T04:19:13.068Z</updated>
    
    <content type="html"><![CDATA[<p>经过半年的数学，英语，算法学习，阿东又要重回机器学习算法的摸爬滚打中了，现在从统计学习方法开始边学边总结。之前学习过一遍，但是由于当时的知识有限，学起来略有困难，现在不仅有了更强的能力，而且开源社区对这方面的资源也日益完善，首先感谢各位大佬对我学习的帮助，尤其感谢<a href="https://github.com/fengdu78/lihang-code" target="_blank" rel="noopener">黄海广博士</a>将本书翻译成代码，对我们来说确实是一条学习捷径。</p><a id="more"></a><p>系列文章文按照本人学习李航<a href="">《统计学习方法》</a>的顺序，结合吴恩达老师的机器学习课程，记录一些重点和个人的思考，希望能帮助到大家。</p><h1 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h1><p>高斯于1823年在误差 $e_1, … ,e_n$ 独立同分布的假定下,证明了最小二乘方法的一个最优性质: 在所有无偏的线性估计类中,最小二乘方法是其中方差最小的！</p><p>最小二乘法就是设计出一个假设函数 $f(x)$，利用原始训练数据集 $T=(x_i, y_i), i \in [1, m]$，拟合出一组参数 $\omega(\omega_0, \omega_1…\omega_m)$，计算残差 $r_i=f(x_i)-y_i$ 使得损失函数 $Loss(\omega, f) = \sum_{i=1}^mr_i^2$ 最小。其实这个很好想明白吧？我写以上一堆数学符号只是为了重新熟悉一下 Mathjax 的语法，向 Markdown 工程师的方向更进一步，哈哈。</p><p>我们常用的假设函数是多项式函数<br>$$H(x)=w_0+w_1x+w_2x^2+…w_nx^n$$</p><p>为啥来？因为多项式函数的次数足够大的时候，是可以无限逼近很多曲线的，不过次数并不是越多越好的，看具体实现。</p><p>机器学习本质就是拟合，以便对未知作出预测，我们的目的就是最小化损失函数 $Loss(x)$，即<br>$$\min_\omega \sum_{i=1}^m(H(x_i)-y_i)^2$$</p><p>这里用 Python 代码模仿一个简单的最小二乘法示例，先生成了一个含有噪声的 $sin(2\pi x)$图像，然后用不同次数的多项式拟合，代码如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sin(x * np.pi * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit_func</span><span class="params">(p, x)</span>:</span></span><br><span class="line">    <span class="comment"># 这里 p 需要是一个序列，作为每个多项式的系数</span></span><br><span class="line">    <span class="comment"># 相当于之前的权值向量 w</span></span><br><span class="line">    f = np.polyld(p)</span><br><span class="line">    <span class="keyword">return</span> f(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">residuals</span><span class="params">(p, x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> fit_func(x, p) - y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fitting</span><span class="params">(M=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    M 为多项式的次数</span></span><br><span class="line"><span class="string">    """</span>    </span><br><span class="line">    <span class="comment"># 随机初始化多项式参数</span></span><br><span class="line">    p_init = np.random.rand(M+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 最小二乘法</span></span><br><span class="line">    p_lsq = leastsq(residuals_func, p_init, args=(x, y))</span><br><span class="line">    print(<span class="string">'Fitting Parameters:'</span>, p_lsq[<span class="number">0</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 可视化</span></span><br><span class="line">    plt.plot(x_points, real_func(x_points), label=<span class="string">'real'</span>)</span><br><span class="line">    plt.plot(x_points, fit_func(p_lsq[<span class="number">0</span>], x_points), label=<span class="string">'fitted curve'</span>)</span><br><span class="line">    plt.plot(x, y, <span class="string">'bo'</span>, label=<span class="string">'noise'</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    <span class="keyword">return</span> p_lsq</span><br></pre></td></tr></table></figure><p>p_lsq_1 = fitting(M=1)]</p><p><img src="https://github.com/fudonglai/merge_reponsitories/blob/master/Screenshot%20from%202018-12-10%2011-49-09.png?raw=true" alt="picture"></p><p>p_lsq_3 = fitting(M=3)</p><p><img src="https://github.com/fudonglai/merge_reponsitories/blob/master/download.png?raw=true" alt="picture"></p><p>p_lsq_9 = fitting(M=9)</p><p><img src="https://github.com/fudonglai/merge_reponsitories/blob/master/download%20%281%29.png?raw=true" alt="picture"></p><p>显然最后一个过拟合，第一个拟合不足，第二个还差不多。</p><h1 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h1><p>为了解决过拟合，添加正则化项，模型越复杂，正则化项越大，越能抑制过拟合。<br>正则化项的一般形式为<br>$$\min_{f\in F} \frac{1}{N} \sum_{i=1}^n L(y_i, f(x_i)) + \lambda J(f) $$</p><p>其中 $L(y_i, f(x_i))$ 表示损失函数，说白了就是误差，就是说着一块要越小越好，越小越准确啊。一般我们损失函数都是平方函数，正则化项可以考虑 $L_1$ 或 $L_2$ 范数，一般用 $L_2$ 范数比较多吧。</p><p>那么我们解决的问题就是最小化损失函数</p><p>$$ L(w) = \frac{1}{N} (f(x_i;w)-y_i)^2 + \frac{\lambda}{2}||w||^2 $$</p><p>$||w||$ 是 $L_2$ 范数，$||w||= \sqrt{w~w^T}$，至于为什么，我推荐<a href="https://www.cnblogs.com/weizc/p/5778678.html" target="_blank" rel="noopener">一篇博客</a>。</p><p>以下是算法代码，从这里我发现了一点之前没有注意过的问题：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">residuals_func_regularization</span><span class="params">(p, x, y)</span>:</span></span><br><span class="line">    ret = fit_func(p, x) - y</span><br><span class="line">    ret = np.append(ret, np.sqrt(<span class="number">0.5</span>*regularization*np.square(p))) <span class="comment"># L2范数作为正则化项</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></p><p>我发现一个问题：np.append() 函数是直接在向量之后增加，相当于增加了原始向量的长度，而我记得以前学习正则化的时候，是直接把罚项加到损失函数里面，这样最小化损失函数的时候也可以同时最小化罚项，也就是简化了模型参数。而且上面那个公式不是写了要对 $L_2$ 范数平方吗，那对罚项再开根号有什么意义，都是求最小值，为何要徒增计算量？</p><p>我觉得这个函数这样写都可以:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_residuals_func_regularization</span><span class="params">(p, x, y)</span>:</span></span><br><span class="line">    ret = fit_func(p, x) - y</span><br><span class="line">    ret = np.append(ret, np.sqrt(<span class="number">0.5</span>*regularization*np.square(p)))</span><br><span class="line">    <span class="comment"># ret = np.append(ret, 0.5*regularization*np.square(p))</span></span><br><span class="line">    <span class="comment"># ret = ret + 0.5*regularization*np.square(p)</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure></p><p>我试了下，果然都可以，应为思想都没变，都是要同时最小化损失函数和权值向量，只是 append 的话就是把正则项同时作为损失参考指标而已，相当于把损失函数和正则项分开，同时优化。</p><p>我对这里正则化的理解是，多项式系数越高，模型越复杂，就是说参数越多，可以把每个次数的单项式理解成一个特征，然而有的特征并不是重点，却占有较大权值，应该舍弃，但是如果没有正则化项的话，这些特征就是过拟合的元凶。而有了正则化，迫使参数和模型的复杂度同时降低，就使这种特征的权值很低，接近于 0，相当于减少了冗余特征，增加了模型的泛化能力。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经过半年的数学，英语，算法学习，阿东又要重回机器学习算法的摸爬滚打中了，现在从统计学习方法开始边学边总结。之前学习过一遍，但是由于当时的知识有限，学起来略有困难，现在不仅有了更强的能力，而且开源社区对这方面的资源也日益完善，首先感谢各位大佬对我学习的帮助，尤其感谢&lt;a href=&quot;https://github.com/fengdu78/lihang-code&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;黄海广博士&lt;/a&gt;将本书翻译成代码，对我们来说确实是一条学习捷径。&lt;/p&gt;
    
    </summary>
    
      <category term="Machine Learning" scheme="https://fudonglai.github.io/categories/Machine-Learning/"/>
    
    
      <category term="Statistics" scheme="https://fudonglai.github.io/tags/Statistics/"/>
    
      <category term="Mathematics" scheme="https://fudonglai.github.io/tags/Mathematics/"/>
    
  </entry>
  
  <entry>
    <title>排序I - 归并 &amp; 快排</title>
    <link href="https://fudonglai.github.io/2019/01/10/Quick-Merge-Sort/"/>
    <id>https://fudonglai.github.io/2019/01/10/Quick-Merge-Sort/</id>
    <published>2019-01-10T11:03:18.000Z</published>
    <updated>2019-01-11T03:13:06.950Z</updated>
    
    <content type="html"><![CDATA[<p>最经又刷了不少算法题，啃了啃《算法导论》，觉得很多算法光写而不拿出来总结，还是不能体会出精髓，于是将自己吸收的东西总结一下，力求能让其他人都看懂。同时练习一下 C++ 泛型编程，写成泛型算法。</p><a id="more"></a><h1 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h1><p>归并排序，典型的分治算法；分治，典型的递归结构。</p><p>分治算法可以分三步走：分解 -&gt; 解决 -&gt; 合并</p><ol><li>分解原问题为结构相同的子问题。</li><li>分解到某个容易求解的边界之后，进行第归求解。</li><li>将子问题的解合并成原问题的解。</li></ol><p><strong>递归</strong> 并不是一种算法，而只是一种编程技巧，例如在分治算法的第二步，很容易看出递归结构，所以分治算法都是由递归实现的。关于递归，我会抽时间专门写一篇文章，从数学和计算机的角度来简单分析一下。</p><p>这里只说一点我编写递归代码的心得：<strong>递归函数只做一件事，并且你相信它一定能做好</strong>，千万不要跳进这个函数里面企图探究更多细节，否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。就举个最简单的例子：遍历二叉树。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    traverse(root-&gt;left);</span><br><span class="line">    traverse(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几行代码就足以扫荡任何一棵二叉树了。我想说的是，对于递归函数<code>traverse(root)</code>，我们只要相信：给它一个根节点<code>root</code>，它就能遍历这棵树，因为写这个函数不就是为了这个目的吗？所以我们只需要把这个节点的左右节点再甩给这个函数就行了，因为我相信它能完成任务的。那么遍历一棵N叉数呢？太简单了好吧，和二叉树一模一样啊。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (child : root-&gt;children)</span><br><span class="line">        traverse(child);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于遍历的什么前、中、后序，那都是显而易见的，对于N叉树，显然没有中序遍历。</p><p>写了这么多题外话，就是让你记住，<strong>明确写出来的这个函数的职责，并且相信它一定能完成</strong>，这样就能看懂，甚至随手写出漂亮的递归代码了。在之后的<a href="">回溯算法</a>，<a href="">动态规划</a>中还会有大量算法由递归实现。现在言归正传。</p><p>归并排序，我们就叫这个函数<code>merge_sort</code>吧，按照我们上面说的，要明确该函数的职责，即<strong>对传入的一个数组排序</strong>。OK，那么这个问题能不能分解呢？当然可以！给一个数组排序，不就等于给该数组的两半分别排序，然后合并就完事了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(一个数组)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (可以很容易处理) <span class="keyword">return</span>;</span><br><span class="line">    merge_sort(左半个数组);</span><br><span class="line">    merge_sort(右半个数组);</span><br><span class="line">    merge(左半个数组, 右半个数组);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，这个算法也就这样了，完全没有任何难度。记住之前说的，相信函数的能力，传给他半个数组，那么这半个数组就已经被排好了。而且你会发现这不就是个二叉树遍历模板吗？为什么是后序遍历？因为我们分治算法的套路是 <strong>分解 -&gt; 解决（触底） -&gt; 合并（回溯）</strong> 啊，先左右分解，再处理合并，回溯就是在退栈，就相当于后序遍历了。至于<code>merge</code>函数，参考两个有序链表的合并，简直一模一样，下面直接贴代码吧。</p><p>注意三点就行：</p><ol><li>我给每一半数组的最后一位添加了一个哨兵位，理论上应该是正无穷，这里用INT_MAX代替。</li><li>形参 <code>begin</code>, <code>end</code>参考 C++ 迭代器，取左闭右开区间，即数组范围在 <code>[begin, end)</code>。</li><li><code>pivot = begin + (end - begin) / 2</code>实际上就是取中值，防止溢出罢了。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= end - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line">    merge_sort(nums, begin, pivot);</span><br><span class="line">    merge_sort(nums, pivot, end);</span><br><span class="line">    merge(nums, begin, pivot, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> pivot, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left(nums.begin() + begin, nums.begin() + pivot);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right(nums.begin() + pivot, nums.begin() + end);</span><br><span class="line">    left.push_back(INT_MAX);</span><br><span class="line">    right.push_back(INT_MAX);</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>, q = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left[p] &lt; right[q]) &#123;</span><br><span class="line">            nums[i] = left[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[i] = right[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h1><p>之所以把快速排序和归并排序放在一起，因为他俩很像，尤其是算法框架上，但是区别也很明显：</p><ol><li>归并排序是典型的分治思想，遵循 分解 -&gt; 处理 -&gt; 合并 的模式，<strong>观察归并代码，递归调用是在分解问题，<code>merge</code>函数兼顾处理和合并操作。</strong>快排不是分治的模式，而是遵行 <strong>预处理 -&gt; 分解 -&gt; 回溯</strong> 的模式，关键在于预处理阶段，<code>partition</code>函数能够将一个元素放到正确的位置，并将数组分成两半。</li><li>观察函数执行的过程，归并排序是从左到右或从右到左形成有序，而快速排序是单点突破，每次递归都会将某个元素排好，放到它的最终位置，而这个元素的选择是随机的，并没有什么规律。</li></ol><p>快排的<strong>关键点在于<code>partition</code>函数，返回划分点的索引，并使该点左侧的值都小于该点，右侧都大于该点</strong>。</p><p>划分完成后，再对这两半数组递归调用<code>quick_sort</code>函数即可。所以这个框架看起来像这个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(数组)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (没办法再分了) <span class="keyword">return</span>;</span><br><span class="line">    划分点 = partition(数组);</span><br><span class="line">    quick_sort(划分点左边的数组);</span><br><span class="line">    quick_sort(划分点右边的数组);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是个前序遍历二叉树嘛，至于为什么，你应该能猜出来了。<code>partition</code>函数就不好形容了，直接看代码好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> pivot, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    swap(nums[end - <span class="number">1</span>], nums[pivot]);</span><br><span class="line">    <span class="keyword">int</span> i = begin - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = begin; j &lt; end - <span class="number">1</span>; j++) &#123; <span class="comment">//!!!!!!!!!!</span></span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt; nums[end - <span class="number">1</span>])</span><br><span class="line">            swap(nums[++i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums[end - <span class="number">1</span>], nums[i + <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end - begin &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> partitioned = partition(nums, begin, end - <span class="number">1</span>, end);</span><br><span class="line">    quick_sort(nums, begin, partitioned);</span><br><span class="line">    quick_sort(nums, partitioned + <span class="number">1</span>, end); <span class="comment">//!!!!!!!!!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打感叹号的地方尤其需要注意，<code>j=begin</code>, <code>partitioned + 1</code>, 这两个地方我没注意，调了半天 bug 。</p><p>记住递归调用的时候是传入划分点左右的数组，<strong>不包括划分点本身！</strong>否则算法就会无限递归下去。</p><p>最后放一个 C++ 写的快排泛型算法，参照 Github 上的项目编写（泛型写起来麻烦点，但是用起来真香）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SortAlgorithm &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> CompareType=<span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::value_type&gt;&gt;</span><br><span class="line">    Iterator partition(<span class="keyword">const</span> Iterator begin, <span class="keyword">const</span> Iterator end, <span class="keyword">const</span> Iterator pivot_iter,</span><br><span class="line">                       CompareType compare = CompareType()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> size = <span class="built_in">std</span>::distance(begin, end);</span><br><span class="line">        assert(size &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) <span class="keyword">return</span> end;</span><br><span class="line">        assert(<span class="built_in">std</span>::distance(begin, pivot_iter) &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">std</span>::distance(pivot_iter, end) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">auto</span> smaller_next = begin;</span><br><span class="line">        <span class="keyword">auto</span> current = begin;</span><br><span class="line">        <span class="keyword">while</span> (current != end - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compare(*current, *(end - <span class="number">1</span>))) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(*current, *smaller_next);</span><br><span class="line">                smaller_next++;</span><br><span class="line">            &#125;</span><br><span class="line">            current++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::swap(*smaller_next, *(end - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> smaller_next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> CompareType=<span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::value_type&gt;&gt;</span><br><span class="line">    <span class="keyword">void</span> quick_sort(<span class="keyword">const</span> Iterator begin, <span class="keyword">const</span> Iterator end, CompareType compare = CompareType()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> size = <span class="built_in">std</span>::distance(begin, end);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">auto</span> partitioned_iter = partition(begin, end, end - <span class="number">1</span>, compare); <span class="comment">//end-1 as pivot</span></span><br><span class="line">        quick_sort(begin, partitioned_iter, compare);</span><br><span class="line">        quick_sort(partitioned_iter + <span class="number">1</span>, end, compare);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最经又刷了不少算法题，啃了啃《算法导论》，觉得很多算法光写而不拿出来总结，还是不能体会出精髓，于是将自己吸收的东西总结一下，力求能让其他人都看懂。同时练习一下 C++ 泛型编程，写成泛型算法。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Sort" scheme="https://fudonglai.github.io/tags/Sort/"/>
    
      <category term="算法导论" scheme="https://fudonglai.github.io/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数组旋转算法</title>
    <link href="https://fudonglai.github.io/2018/12/23/Rotate-Array/"/>
    <id>https://fudonglai.github.io/2018/12/23/Rotate-Array/</id>
    <published>2018-12-23T05:19:18.000Z</published>
    <updated>2019-04-30T01:57:01.644Z</updated>
    
    <content type="html"><![CDATA[<p>交换数组的两个区域很简单吗？</p><p>以下给出链表解法，递归解法，连续翻转，杂技解法。</p><a id="more"></a><p>题目和图片来自 <a href="https://leetcode.com/explore/featured/card/top-interview-questions-easy/92/array/646/" target="_blank" rel="noopener">LeetCode</a>。</p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h2><p>Given an array, rotate the array to the right by <em>k</em> steps, where <em>k</em> is non-negative.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5,6,7] and k = 3</span><br><span class="line">Output: [5,6,7,1,2,3,4]</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: [7,1,2,3,4,5,6]</span><br><span class="line">rotate 2 steps to the right: [6,7,1,2,3,4,5]</span><br><span class="line">rotate 3 steps to the right: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [-1,-100,3,99] and k = 2</span><br><span class="line">Output: [3,99,-1,-100]</span><br><span class="line">Explanation: </span><br><span class="line">rotate 1 steps to the right: [99,-1,-100,3]</span><br><span class="line">rotate 2 steps to the right: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><h2 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection:"></a>Reflection:</h2><p>这个问题实际上可以简化为如何交换数组的两部分，但是在思维模式上还是有差别，那么首先按照题目的意思，Rotate 一个数组，相当于循环位移每个元素？显然对于数组来说，看起来简单的整体移动涉及大量数据搬移，可以说非常低效。数组要是能连接成一个环就好了？那我用链表造个环不就完事了。</p><p>抛开循环移动这个思维，<code>Rotate</code>这个操作的结果不就是把数组某个节点两边数据交换了一下吗？这个操作看起来也好简单啊，swap 就完了？但是事实好像并没有这么简单。</p><h2 id="Approach-I-Cycle-Linked-List"><a href="#Approach-I-Cycle-Linked-List" class="headerlink" title="Approach I: Cycle Linked List"></a>Approach I: Cycle Linked List</h2><p><strong>Time Complexity: O(n), Space Complexity: O(n)</strong></p><p>我们创造一个环链表，记住开头元素位置，然后走相应步数之后，把这个地方作为开头，读取环链表，得到的就是结果了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode *p = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : nums) &#123;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> ListNode(n);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = head-&gt;next;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> step = nums.size() - k % nums.size();</span><br><span class="line">    <span class="keyword">while</span> (step--) p = p-&gt;next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        nums[i] = p-&gt;val;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-II-Recursion"><a href="#Approach-II-Recursion" class="headerlink" title="Approach II: Recursion"></a>Approach II: Recursion</h2><p><strong>Time Complexity: O(n), Space Complexity: O(n)</strong></p><p>抛开整体移动，直接粗暴地交换元素的话，两个区域长度相同的话直接<code>swap</code> n/2 次就完全交换了，但是如果两个区域长度不同，长的那部分就会有剩余，该剩余区域还需要和长区域经过交换的那个区域交换，以还原长区域的原始顺序，然后这个交换过程又会产生长短不一的问题，然后请重新阅读这段话。</p><p>子问题和原问题结构完全相同，规模更小，明显的递归结构，结束边界就是两个区域长度相等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursiveSwap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    k %= length;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) </span><br><span class="line">        swap(nums[start + i], nums[nums.size() - k + i]);</span><br><span class="line">    recursiveSwap(nums, k, start + k, length - k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间复杂度是最坏情况，也就是交换<code>nums[0]</code>和<code>nums[1...size-1]</code>的极端情况。</p><p>写出该递归数学形式，求解封闭解，可以把该函数改为封闭递推形式：</p><p><strong>Time Complexity: O(n), Space Complexity: O(1)</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">for</span> (; k %= n; n -= k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            swap(nums[i], nums[n - k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于递归式求解封闭解，需要数学技巧，并且写出来的代码基本看不懂，不会就算了。</p><h2 id="Approach-III-Magic-Method"><a href="#Approach-III-Magic-Method" class="headerlink" title="Approach III: Magic Method"></a>Approach III: Magic Method</h2><p><strong>Time Complexity: O(n), Space Complexity: O(1)</strong></p><p>类似链表解法，但是不需要额外的链表节点表示，直接在数组上进行跳跃。反正描述不清楚，看代码自行体会一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums: [1, 2, 3, 4, 5, 6]</span><br><span class="line">k: 2</span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/media/original_images/189_Rotate_Array.png" alt="example"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>; step &lt; nums.size(); start++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curr = start;</span><br><span class="line">            <span class="keyword">int</span> prev_val = nums[start];</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> next = (curr + k) % nums.size();</span><br><span class="line">                <span class="keyword">int</span> temp = nums[next];</span><br><span class="line">                nums[next] = prev_val;</span><br><span class="line">                prev_val = temp;</span><br><span class="line">                curr = next;</span><br><span class="line">                step++;</span><br><span class="line">            &#125; <span class="keyword">while</span> (curr != start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-IV-KISS"><a href="#Approach-IV-KISS" class="headerlink" title="Approach IV: KISS"></a>Approach IV: KISS</h2><p><strong>Time Complexity: O(n), Space Complexity: O(1)</strong></p><p>只有看到这里的真的猛士才配拥有真正的终极算法。</p><p>交换两段数据？只要分别反转这两段，再把整个数组反转就行了，不信自己数一数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Keep it simple, stupid.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.size();</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        reverse(nums.begin(), nums.begin() + n - k);</span><br><span class="line">        reverse(nums.begin() + n - k, nums.end());</span><br><span class="line">        reverse(nums.begin(), nums.end());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>欢迎关注我的公众号，致力于把事情讲清楚：labuladong</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4k1unaMOseLDCmx5DJDLmfic3TOYvCgzQFlbSLH12nGbxuAwShrERfLV5k70dLPjUCwVNmUjzQib9dQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="公众号二维码"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;交换数组的两个区域很简单吗？&lt;/p&gt;
&lt;p&gt;以下给出链表解法，递归解法，连续翻转，杂技解法。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Array" scheme="https://fudonglai.github.io/tags/Array/"/>
    
      <category term="LinkedList" scheme="https://fudonglai.github.io/tags/LinkedList/"/>
    
      <category term="Recursion" scheme="https://fudonglai.github.io/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>深度复制随机链表</title>
    <link href="https://fudonglai.github.io/2018/12/22/deepCopyRandomLink/"/>
    <id>https://fudonglai.github.io/2018/12/22/deepCopyRandomLink/</id>
    <published>2018-12-22T15:03:31.000Z</published>
    <updated>2018-12-22T15:12:00.952Z</updated>
    
    <content type="html"><![CDATA[<p>以下有三种常规解决方案，和一种杂技解法。</p><p>Best Approach: Time Complexity O(n), Space Complexity O(1).</p><a id="more"></a><p><strong>题目及图片均源于 <a href="https://leetcode.com/explore/interview/card/top-interview-questions-hard/117/linked-list/841/]" target="_blank" rel="noopener">LeetCode</a> </strong>。</p><p>题目：给一个链表，这个链表有点特殊，即每个节点还包含一个随机指针，随机指向链表中的某一个节点，请你深度复制（DeepCopy）这个链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list with a random pointer.</span></span><br><span class="line"><span class="comment"> * class RandomListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     RandomListNode next, random;</span></span><br><span class="line"><span class="comment"> *     RandomListNode(int x) &#123; this.label = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/problems/copy-list-with-random-pointer/Figures/138/138_Copy_List_Random_1.png" alt="RandomLinkedList"></p><p>首先想到，这随机链表不就是个图吗？首先就想到 <a href="https://leetcode.com/problems/clone-graph/" target="_blank" rel="noopener">Clone Graph</a>，最起码有深度优先和广度优先两种方法。</p><h2 id="Approach-I-DFS"><a href="#Approach-I-DFS" class="headerlink" title="Approach I: DFS"></a>Approach I: DFS</h2><p><strong>Time Complexity O(n), Space Complexity O(n)</strong></p><p>递归实现简单易懂，确定边界条件，然后调用自己就完事了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;RandomListNode, RandomListNode&gt;</span><br><span class="line">        visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span> (visited.containsKey(head)) <span class="keyword">return</span> visited.get(head);</span><br><span class="line">        RandomListNode cp = <span class="keyword">new</span> RandomListNode(head.label);</span><br><span class="line">        visited.put(head, cp);</span><br><span class="line">        cp.next = copyRandomList(head.next);</span><br><span class="line">        cp.random = copyRandomList(head.random);</span><br><span class="line">        <span class="keyword">return</span> cp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-II-BFS"><a href="#Approach-II-BFS" class="headerlink" title="Approach II: BFS"></a>Approach II: BFS</h2><p><strong>Time Complexity O(n), Space Complexity O(n)</strong></p><p>这段是我用 C++ 写的，借鉴图克隆的算法，可以说都是一套模板了，个人认为没有递归舒服。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;RandomListNode*, RandomListNode*&gt; <span class="built_in">map</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;RandomListNode*&gt; q;</span><br><span class="line">        q.push(head);</span><br><span class="line">        <span class="built_in">map</span>[head] = <span class="keyword">new</span> RandomListNode(head-&gt;label);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="keyword">auto</span> front = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;next &amp;&amp; <span class="built_in">map</span>.find(front-&gt;next) == <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                <span class="built_in">map</span>[front-&gt;next] = <span class="keyword">new</span> RandomListNode(front-&gt;next-&gt;label);</span><br><span class="line">                q.push(front-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;random &amp;&amp; <span class="built_in">map</span>.find(front-&gt;random) == <span class="built_in">map</span>.end()) &#123;</span><br><span class="line">                <span class="built_in">map</span>[front-&gt;random] = <span class="keyword">new</span> RandomListNode(front-&gt;random-&gt;label);</span><br><span class="line">                q.push(front-&gt;random);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">map</span>[front]-&gt;random = <span class="built_in">map</span>[front-&gt;random];</span><br><span class="line">            <span class="built_in">map</span>[front]-&gt;next = <span class="built_in">map</span>[front-&gt;next];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[head];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-III-Double-Pointer"><a href="#Approach-III-Double-Pointer" class="headerlink" title="Approach III: Double Pointer"></a>Approach III: Double Pointer</h2><p><strong>Time Complexity O(n), Space Complexity O(n)</strong></p><p>常规方法吧，类似双指针同步操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;RandomListNode, RandomListNode&gt;</span><br><span class="line">        visited = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> RandomListNode <span class="title">getCloneNode</span><span class="params">(RandomListNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="keyword">if</span> (!visited.containsKey(node))</span><br><span class="line">            visited.put(node, <span class="keyword">new</span> RandomListNode(node.label));</span><br><span class="line">        <span class="keyword">return</span> visited.get(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        RandomListNode oldNode = head;</span><br><span class="line">        RandomListNode newNode = getCloneNode(head);</span><br><span class="line">        <span class="keyword">while</span> (oldNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            newNode.next = getCloneNode(oldNode.next);</span><br><span class="line">            newNode.random = getCloneNode(oldNode.random);</span><br><span class="line">            oldNode = oldNode.next;</span><br><span class="line">            newNode = newNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Approach-IV：Magic-Method"><a href="#Approach-IV：Magic-Method" class="headerlink" title="Approach IV：Magic Method"></a>Approach IV：Magic Method</h2><p><strong>Time Complexity O(n), Space Complexity O(1)</strong></p><p>比较难想到，竟然不需要额外存储空间来记录已生成的节点？</p><p>本方法分为两步走：</p><ol><li><p>克隆原节点的 next 域和 random 域，然后将克隆的节点（cloned）放到原始节点（original）之后，此处需要链表插入操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cloned.next = original.next</span><br><span class="line">original.next = cloned</span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/articles/Figures/138/138_Copy_List_Random_9_1.png" alt="step1"></p></li><li>解开 cloned 和 original 的连接，分为两条链表，完成复制。</li></ol><p><img src="https://leetcode.com/articles/Figures/138/138_Copy_List_Random_10.png" alt="step2"></p><p>Java 代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">copyRandomList</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        RandomListNode original = head;</span><br><span class="line">        <span class="keyword">while</span> (original != <span class="keyword">null</span>) &#123;</span><br><span class="line">            RandomListNode cloned = <span class="keyword">new</span> RandomListNode(original.label);</span><br><span class="line">            cloned.next = original.next;</span><br><span class="line">            original.next = cloned;</span><br><span class="line">            original = cloned.next;</span><br><span class="line">        &#125;</span><br><span class="line">        original = head;</span><br><span class="line">        <span class="keyword">while</span> (original != <span class="keyword">null</span>) &#123;</span><br><span class="line">            original.next.random = </span><br><span class="line">                (original.random != <span class="keyword">null</span>) ? original.random.next : <span class="keyword">null</span>;</span><br><span class="line">            original = original.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        RandomListNode cloned_head = head.next;</span><br><span class="line">        RandomListNode cloned = cloned_head;</span><br><span class="line">        original = head;</span><br><span class="line">        <span class="keyword">while</span> (cloned != <span class="keyword">null</span>) &#123;</span><br><span class="line">            original.next = cloned.next;</span><br><span class="line">            original = original.next;</span><br><span class="line">            cloned.next = (original != <span class="keyword">null</span>) ? original.next : <span class="keyword">null</span>;</span><br><span class="line">            cloned = cloned.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloned_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下有三种常规解决方案，和一种杂技解法。&lt;/p&gt;
&lt;p&gt;Best Approach: Time Complexity O(n), Space Complexity O(1).&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="LinkedList" scheme="https://fudonglai.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>现代C语言--I</title>
    <link href="https://fudonglai.github.io/2018/11/19/Modern-C-Lang/"/>
    <id>https://fudonglai.github.io/2018/11/19/Modern-C-Lang/</id>
    <published>2018-11-18T17:09:53.000Z</published>
    <updated>2019-04-30T01:57:49.723Z</updated>
    
    <content type="html"><![CDATA[<p>C语言简单而隐晦的角落。</p><a id="more"></a><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><p>scanf 遇到的字符不是当前内容时， 会把它放回原处，在扫描下一个输入项或下一次调用 scanf 时再试图读入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">float</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%f%f"</span>, &amp;i, &amp;j, &amp;x, &amp;y);</span><br></pre></td></tr></table></figure><p>Suppose that the user enters three lines of input:</p><blockquote><p>1-20.3-4.0e3</p></blockquote><ul><li>第一个转换符是 %d，第一个非空字符是 1，可以出现在整数中，下一个字符是 ”-“，scanf 认为它不应该出现在整数内部，所以把 “-” 放回原处，把 1 读入 i 。</li><li>第二个读入 -20 之后发现小数点，scanf 认为它不该出现在整数中，所以把 -20 读入 j 。</li><li>第三个读入 .3，发现负号不该出现在浮点数中间，所以把 0.3 读入 x 。</li><li>最后把 -4*10^3 读入 y，并把最后的换行符放回原处。</li></ul><p>在读取格式串时遇到任何空白字符，scanf 会跳过空白符直到遇到非空白符尝试读取。</p><p>如 <code>&quot;%d/%d&quot;</code> 格式串，输入<code>5/    96</code>，能够成功读取两个整数。</p><p>如输入<code>5  /    96</code>，则在读取 5 后无法匹配 <code>/</code>而把之后的所有留给下次 scanf 调用。</p><h2 id="的副作用（side-effect）"><a href="#的副作用（side-effect）" class="headerlink" title="+= 的副作用（side effect）"></a>+= 的副作用（side effect）</h2><p>如果 v 有副作用，那么 v += e 不等价于 v = v + e 。</p><p>因为 v += e 只会导致一次 v 的求值，而 v = v + e 有两次。</p><p>如 <code>a[i++] += 1</code> 只会导致 i 自增 1；</p><p>而 <code>a[i++] = a[i++] + 1</code> 导致 i 自增 2 。</p><h2 id="getchar"><a href="#getchar" class="headerlink" title="getchar"></a>getchar</h2><p>getchar(), putchar() faster than scanf and printf.</p><p><strong>idiom</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">'\n'</span>) <span class="comment">/*skips rest of line*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((ch = getchar()) == <span class="string">' '</span>) <span class="comment">/*skips blanks*/</span></span><br></pre></td></tr></table></figure><p>如果混用 scanf 和 getchar，注意 scanf 读取剩下的字符（包括换行符）会被 getchar 读取。</p><h2 id="使用-lf-读取-double-型的值，用-f-进行显示"><a href="#使用-lf-读取-double-型的值，用-f-进行显示" class="headerlink" title="使用 %lf 读取 double 型的值，用 %f 进行显示"></a>使用 %lf 读取 double 型的值，用 %f 进行显示</h2><p>因为 printf 和 scanf 都没有限制参数个数，使用了可变长度参数列表。</p><p>当调用可变长度参数列表函数时编译器安排 float 自动转化成 double 型，所以 printf 无法区分 float 和 double，所以可以用 %f 表示 float 和 double。</p><p>但是 scanf 用指针指向变量，必须知道地址上存储的类型，否则如果 float 和 double 位模式不同，scanf 会存储错误的字节数量。</p><h2 id="typedef-优于宏定义"><a href="#typedef-优于宏定义" class="headerlink" title="typedef 优于宏定义"></a>typedef 优于宏定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR_TO_INT int *</span></span><br><span class="line">PTR_TO_INT p, q;</span><br><span class="line"><span class="comment">// int *p, q;</span></span><br><span class="line"><span class="comment">// typedef will be better</span></span><br></pre></td></tr></table></figure><h2 id="远离-1"><a href="#远离-1" class="headerlink" title="远离 1"></a>远离 1</h2><p>下标从 0 开始，注意数组的下标越界陷阱。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">    a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可能会导致无限循环。因为 <code>a[10]</code>已经越界，如果变量 <code>i</code>如果储存在这块空间，则错误地把<code>i</code>赋值为 0，无限循环。</p><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><p>如果给定长度和初始化列表，列表长度为0 或超过长度都是非法的，如果小于长度，剩余位置自动初始化为 0 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">/*initial value: 1,2,0,0,0,0,0,0,0,0*/</span></span><br></pre></td></tr></table></figure><p><strong>多维数组初始化：</strong></p><ul><li>如果一行给出的列表不能填满该行，该行剩余填满 0 。</li><li>如果给出的列表行数不足数组行数，剩余行数全部填满 0 。</li><li>如果去掉大括号也可以，一旦填满一行，编译器自动去填下一行。（危险）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">               &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="comment">/* 1,2,0,0,</span></span><br><span class="line"><span class="comment">   1,2,3,4,</span></span><br><span class="line"><span class="comment">   0,0,0,0,</span></span><br><span class="line"><span class="comment">   0,0,0,0 */</span></span><br></pre></td></tr></table></figure><p>所以要全部初始化为 0 应该是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m[<span class="number">4</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><h2 id="数组和指针区别"><a href="#数组和指针区别" class="headerlink" title="数组和指针区别"></a>数组和指针区别</h2><ol><li><p>数组名不能被赋予新值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (*a != <span class="number">0</span>)</span><br><span class="line">    a++;<span class="comment">/*WRONG*/</span></span><br></pre></td></tr></table></figure></li><li><p><code>sizeof()</code>对数组名和指针效果不同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len_of_a = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); <span class="comment">/* len_of_a == 3 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line"><span class="keyword">int</span> len_of_p = <span class="keyword">sizeof</span>(p); <span class="comment">/* len_of_p == sizeof(int*) */</span></span><br></pre></td></tr></table></figure><p>sizeof 对普通指针计算一个指针在内存中的字节长度，这取决于机器。</p><p>sizeof 对数组名计算该数组在内存中的总字节长度，所以可以那样求得数组元素个数。</p></li></ol><h2 id="函数形式参数中-int-a-还是-int-a"><a href="#函数形式参数中-int-a-还是-int-a" class="headerlink" title="函数形式参数中 int *a 还是 int a[ ] ?"></a>函数形式参数中 int *a 还是 int a[ ] ?</h2><p>考虑到函数参数传入的是拷贝，<code>int *a</code> 和 <code>int a[]</code> 完全相同，即便后者形式好像是数组，实际上也是普通指针，没有任何数组名的特殊技能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);  <span class="comment">/*WRONG*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组型参数"><a href="#数组型参数" class="headerlink" title="数组型参数"></a>数组型参数</h2><p>传入一维数组时，不需要写长度，写了也没用。</p><p>传入多为数组时，只有第一维长度是不必要的。因为要让编译器知道一个元素长度到底是多少。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> a[<span class="number">10</span>])</span></span>&#123;  <span class="comment">//OK</span></span><br><span class="line">    <span class="comment">/* equal to fun(int a[]) and fun(int* a) */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">10</span>])</span></span>&#123; <span class="comment">//correct</span></span><br><span class="line">    <span class="comment">/* because complier konws there are sizeof(int) * 10 </span></span><br><span class="line"><span class="comment">    bits between a[0] and a[1] */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* fun2(int a[][]) is WRONG */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="i-a"><a href="#i-a" class="headerlink" title="i [a] ???"></a>i [a] ???</h2><p>对编译器而言：<code>i[a] == *(i + a) == a[i]</code></p><h2 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h2><p>最后一个是空字符<code>/0</code>，其 ASCII 码为 0 ，而数字 <code>0</code> 的 ASCII 码为 48 。</p><h2 id="字符数组和数组指针"><a href="#字符数组和数组指针" class="headerlink" title="字符数组和数组指针"></a>字符数组和数组指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> date_arr[] = <span class="string">"Nov 20"</span>;</span><br><span class="line"><span class="keyword">char</span>* date_ptr = <span class="string">"Nov 20"</span>;</span><br></pre></td></tr></table></figure><ul><li><code>date_ptr</code>是指针变量，可以再指向其他值，<code>date_arr</code>不能。</li><li><code>date_ptr</code>指向的字符串是字面值，不可修改，<code>date_arr</code>可以随意修改。</li></ul><p>初始化字符数组时类似普通数组，若填不满空位添 0 ，超过限制就非法，但是不会检查最后是否有停止标识符<code>/0</code>。</p><p>考虑 <code>printf</code>和<code>scanf</code>第一个参数都是接受字符串常量，即该串的首地址。</p><h2 id="读写字符串"><a href="#读写字符串" class="headerlink" title="读写字符串"></a>读写字符串</h2><h3 id="printf-amp-amp-puts"><a href="#printf-amp-amp-puts" class="headerlink" title="printf &amp;&amp; puts"></a>printf &amp;&amp; puts</h3><p>printf 逐个读取字符，直到读到空字符，如果空字符丢失，继续读，知道在内存找到一个空字符为止。</p><p>puts 接受一个参数没有格式串，写完字符串后自动添加换行符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">"abcdef"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.3s"</span>, str); <span class="comment">// abc</span></span><br><span class="line"><span class="built_in">puts</span>(str); <span class="comment">// abcdef</span></span><br></pre></td></tr></table></figure><h3 id="scanf-amp-amp-gets"><a href="#scanf-amp-amp-gets" class="headerlink" title="scanf &amp;&amp; gets"></a>scanf &amp;&amp; gets</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEN 11</span></span><br><span class="line"><span class="keyword">char</span> str[LEN];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line"><span class="comment">/* input: "   hello world"*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   str: 'h','e','l','l','o','\0', ...</span></span><br><span class="line"><span class="comment">   scanf never get string with space, skip blank and end at blank,</span></span><br><span class="line"><span class="comment">   and add '\0' automatically.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">gets(str); <span class="comment">//all will be recieved, but dangerous</span></span><br></pre></td></tr></table></figure><p>欢迎关注我的公众号，致力于把事情讲清楚：labuladong</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/map09icNxZ4k1unaMOseLDCmx5DJDLmfic3TOYvCgzQFlbSLH12nGbxuAwShrERfLV5k70dLPjUCwVNmUjzQib9dQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="公众号二维码"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C语言简单而隐晦的角落。&lt;/p&gt;
    
    </summary>
    
      <category term="C Programming Language" scheme="https://fudonglai.github.io/categories/C-Programming-Language/"/>
    
    
  </entry>
  
  <entry>
    <title>KMP for Pattern Searching</title>
    <link href="https://fudonglai.github.io/2018/10/26/KMP-for-Pattern-Searching/"/>
    <id>https://fudonglai.github.io/2018/10/26/KMP-for-Pattern-Searching/</id>
    <published>2018-10-26T08:18:39.000Z</published>
    <updated>2018-12-22T15:26:59.248Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Question:</strong> Return the index of the first occurrence of needle in haystack, or <strong>-1</strong> if needle is not part of haystack.</p><p>KMP (Knuth-Morris-Pratt Algorithm) is a classic and yet notoriously hard-to-understand algorithm.Fortunately, I found some perspicuous explainations.</p><p>Here are both Brute-Force method and KMP algorithm.</p><a id="more"></a><h1 id="Brute-Force-Implement"><a href="#Brute-Force-Implement" class="headerlink" title="Brute-Force Implement"></a>Brute-Force Implement</h1><p>It’s easy. Code is here:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (haystack.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> h = haystack.length(), n = needle.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= h - n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle.front())&#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; n &amp;&amp; haystack[i + j] == needle[j]; ++j)</span><br><span class="line">                ;</span><br><span class="line">            <span class="keyword">if</span> (j == n)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;<span class="comment">//if</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The worst case complexity of the naive algorithm is $O(m(n-m+1))$. </p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">text[] = <span class="string">"AAAAAAAAAAAAAAAAAB"</span></span><br><span class="line">pattern[] = <span class="string">"AAAAB"</span></span><br><span class="line"><span class="comment">/*the worst case*/</span></span><br><span class="line"></span><br><span class="line">txt[] = <span class="string">"ABABABCABABABCABABABC"</span></span><br><span class="line">pat[] =  <span class="string">"ABABAC"</span> </span><br><span class="line"><span class="comment">/*not a worst case, but a bad case for Naive*/</span></span><br></pre></td></tr></table></figure><p>But the time complexity of KMP algorithm is $O(n)$ in the worst case. Of course, you need some extra space to preprocess the pattern.</p><p>Then you  can challenge yourself implement the KMP algorithm for this problem.</p><h1 id="KMP-Algorithm"><a href="#KMP-Algorithm" class="headerlink" title="KMP Algorithm"></a>KMP Algorithm</h1><p>You can refer to them for the detials:</p><ol><li>KMP on <a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="noopener">Jake Boxer’s Blog</a></li><li>KMP on <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/" target="_blank" rel="noopener">Geeks-for-Geeks</a></li></ol><h2 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h2><h3 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h3><p>Whenever we detect a mismatch (after some matches), we already know some of the characters in the text of the next window. We take advantage of this information to avoid matching the characters that we know will anyway match. </p><p>To know how many characters we can skip, we pre-process pattern and get an integer array that tells us the count of characters to be skipped. </p><h3 id="The-Partial-Match-Table"><a href="#The-Partial-Match-Table" class="headerlink" title="The Partial Match Table"></a>The Partial Match Table</h3><p>Here I want to quote <a href="http://jakeboxer.com/blog/2009/12/13/the-knuth-morris-pratt-algorithm-in-my-own-words/" target="_blank" rel="noopener">Jake Boxer’s perspicuous explaination</a>.</p><p>Here’s the partial match table for the pattern “abababca”:</p><table><thead><tr><th>char</th><th>a</th><th>b</th><th>a</th><th>b</th><th>a</th><th>b</th><th>c</th><th>a</th></tr></thead><tbody><tr><td>index</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>value</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>0</td><td>1</td></tr></tbody></table><blockquote><p><strong>Proper prefix</strong>: All the characters in a string, with one or more cut off the end. “S”, “Sn”, “Sna”, and “Snap” are all the proper prefixes of “Snape”.</p><p><strong>Proper suffix</strong>: All the characters in a string, with one or more cut off the beginning. “agrid”, “grid”, “rid”, “id”, and “d” are all proper suffixes of “Hagrid”.</p><p>Here, we’re interested in the first four characters (“abab”). We have three proper prefixes (“a”, “ab”, and “aba”) and three proper suffixes (“b”, “ab”, and “bab”). This time, “ab” is in both, and is two characters long, so cell four gets value 2.</p><p>let’s also try it for cell five, which concerns “ababa”. We have four proper prefixes (“a”, “ab”, “aba”, and “abab”) and four proper suffixes (“a”, “ba”, “aba”, and “baba”). Now, we have two matches: “a” and “aba” are both proper prefixes and proper suffixes. Since “aba” is longer than “a”, it wins, and cell five gets value 3.</p><p>Let’s skip ahead to cell seven (the second-to-last cell), which is concerned with the pattern “abababc”. Even without enumerating all the proper prefixes and suffixes, it should be obvious that there aren’t going to be any matches; all the suffixes will end with the letter “c”, and none of the prefixes will. Since there are no matches, cell seven gets 0.</p></blockquote><h2 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h2><p>quote <a href="http://www.geeksforgeeks.org/searching-for-patterns-set-2-kmp-algorithm/" target="_blank" rel="noopener">Geeks-for-Geeks</a>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">lps[i] = the longest proper prefix of pat[<span class="number">0.</span>.i] </span><br><span class="line">which is also a suffix of pat[<span class="number">0.</span>.i]. </span><br><span class="line">         </span><br><span class="line">Examples of lps[] construction:</span><br><span class="line"></span><br><span class="line">For the pattern “AAAA”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">For the pattern “ABCDE”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">For the pattern “AABAACAABAA”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">For the pattern “AAACAAAAAC”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>] </span><br><span class="line"></span><br><span class="line">For the pattern “AAABAAA”, </span><br><span class="line">lps[] is [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h3 id="Preprocessing-Algorithm"><a href="#Preprocessing-Algorithm" class="headerlink" title="Preprocessing Algorithm"></a>Preprocessing Algorithm</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pat[] = <span class="string">"AAACAAAA"</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">0.</span></span><br><span class="line">lps[<span class="number">0</span>] <span class="keyword">is</span> always <span class="number">0</span>, we move </span><br><span class="line">to i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">1.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">1</span>, lps[<span class="number">1</span>] = <span class="number">1</span>, i = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">1</span>, i  = <span class="number">2.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">2</span>, lps[<span class="number">2</span>] = <span class="number">2</span>, i = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">2</span>, i  = <span class="number">3.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match, <span class="keyword">and</span> len &gt; <span class="number">0</span>, </span><br><span class="line">set len = lps[len<span class="number">-1</span>] = lps[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">1</span>, i  = <span class="number">3.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match <span class="keyword">and</span> len &gt; <span class="number">0</span>, </span><br><span class="line">len = lps[len<span class="number">-1</span>] = lps[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">3.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match <span class="keyword">and</span> len = <span class="number">0</span>, </span><br><span class="line">Set lps[<span class="number">3</span>] = <span class="number">0</span> <span class="keyword">and</span> i = <span class="number">4.</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">0</span>, i  = <span class="number">4.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">1</span>, lps[<span class="number">4</span>] = <span class="number">1</span>, i = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">1</span>, i  = <span class="number">5.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">2</span>, lps[<span class="number">5</span>] = <span class="number">2</span>, i = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">2</span>, i  = <span class="number">6.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">3</span>, lps[<span class="number">6</span>] = <span class="number">3</span>, i = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">3</span>, i  = <span class="number">7.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] do <span class="keyword">not</span> match <span class="keyword">and</span> len &gt; <span class="number">0</span>,</span><br><span class="line">set len = lps[len<span class="number">-1</span>] = lps[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">len = <span class="number">2</span>, i  = <span class="number">7.</span></span><br><span class="line">Since pat[len] <span class="keyword">and</span> pat[i] match, do len++, </span><br><span class="line">store it <span class="keyword">in</span> lps[i] <span class="keyword">and</span> do i++.</span><br><span class="line">len = <span class="number">3</span>, lps[<span class="number">7</span>] = <span class="number">3</span>, i = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">We stop here <span class="keyword">as</span> we have constructed the whole lps[].</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Here is my preprocessing code:</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; generator(<span class="built_in">string</span> pattern)&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lps(pattern.size());</span><br><span class="line">    lps[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; pattern.size(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[len])&#123;</span><br><span class="line">            len++;</span><br><span class="line">            lps[i] = len;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">                len = lps[len - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                len = <span class="number">0</span>; i++;</span><br><span class="line">            &#125;<span class="comment">//else</span></span><br><span class="line">        &#125;<span class="comment">//else</span></span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> lps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Matching-Algorithm"><a href="#Matching-Algorithm" class="headerlink" title="Matching Algorithm"></a>Matching Algorithm</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (haystack.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lps = generator(needle);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.size(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack[i] == needle[j])&#123;</span><br><span class="line">            i++, j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j = lps[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == needle.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;&#125;</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; Return the index of the first occurrence of needle in haystack, or &lt;strong&gt;-1&lt;/strong&gt; if needle is not part of haystack.&lt;/p&gt;
&lt;p&gt;KMP (Knuth-Morris-Pratt Algorithm) is a classic and yet notoriously hard-to-understand algorithm.Fortunately, I found some perspicuous explainations.&lt;/p&gt;
&lt;p&gt;Here are both Brute-Force method and KMP algorithm.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="patern search" scheme="https://fudonglai.github.io/tags/patern-search/"/>
    
  </entry>
  
  <entry>
    <title>Fundamental DP Problem</title>
    <link href="https://fudonglai.github.io/2018/10/26/Fundamental-DP-Problem/"/>
    <id>https://fudonglai.github.io/2018/10/26/Fundamental-DP-Problem/</id>
    <published>2018-10-26T02:52:13.000Z</published>
    <updated>2018-12-30T03:39:37.781Z</updated>
    
    <content type="html"><![CDATA[<p>There is an interesting problem in LeetCode: <a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">Unique Paths</a>.</p><p>I found some perspicuous explanation in the comments. Thank @<a href="https://leetcode.com/yfgu0618" target="_blank" rel="noopener">YFGu0618</a> for his graph.</p><a id="more"></a><h3 id="Description"><a href="#Description" class="headerlink" title="Description:"></a>Description:</h3><blockquote><p>A robot is located at the top-left corner of a <em>m</em> x <em>n</em> grid.</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid.</p><p>How many possible unique paths are there?</p></blockquote><h3 id="Observations"><a href="#Observations" class="headerlink" title="Observations:"></a>Observations:</h3><p>Since the robot can only move right and down, when it arrives at a point, there are only two possibilities:</p><ol><li>It arrives at that point from above (moving down to that point);</li><li>It arrives at that point from left (moving right to that point).</li></ol><p>Thus we have the following equations: $Approach(i, j)=Approach(i - 1, j) + Approach(i, j-1)$</p><p><img src="https://assets.leetcode.com/users/yfgu0618/image_1540157891.png" alt="picture"></p><p>The boundary conditions of the above equation have some problems at the leftmost column and the uppermost row due to $(0, j)$ and $(i, 0)$ do not exist. To oversmart the problem automatically,  it’s easier that we initialize the array to something like following:</p><p><img src="https://assets.leetcode.com/users/yfgu0618/image_1540158218.png" alt="picture"></p><h3 id="Implement"><a href="#Implement" class="headerlink" title="Implement"></a>Implement</h3><p>So, here is my codes:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">map</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m + <span class="number">1</span>; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; ++j) </span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][j - <span class="number">1</span>] + <span class="built_in">map</span>[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">map</span>[m][n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>As can be seen, the above solution runs in $O(n^2)$ time and costs $O(m*n)$ space.</p><p>But we find that each time we update the <code>map[i][j]</code>, we only need to consider the current column(for <code>map[i-1, j]</code>) and the previous column(for <code>map[i, j-1]</code>), so only two vector can be enough.</p><p>Here is new codes:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c1(m + <span class="number">1</span>, <span class="number">0</span>), c2(c1);</span><br><span class="line">        c1[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">                c2[j] = c1[j] + c2[j - <span class="number">1</span>];</span><br><span class="line">            c1 = c2;</span><br><span class="line">            c2 = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c1[m];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Further inspecting the above code, we find it needs $O(m)$ space, but if $n&lt;m$, should I convert to $O(n)$ space? And we find that <code>vector c2</code>will convert to zero in every loop, so the operation is actually <code>c1[i] += c1[i-1]</code>. Now we can implement a more efficient approach:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (m &gt; n)</span><br><span class="line">           <span class="keyword">return</span> uniquePaths(n, m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c(m, <span class="number">0</span>);</span><br><span class="line">        c[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m - <span class="number">1</span>; ++j) </span><br><span class="line">                c[j] += c[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> c[m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Now it is prefect, how interesting it is!</p><p>PS: 2018/12/30</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; m) <span class="keyword">return</span> uniquePaths(n, m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;There is an interesting problem in LeetCode: &lt;a href=&quot;https://leetcode.com/problems/unique-paths/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Unique Paths&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I found some perspicuous explanation in the comments. Thank @&lt;a href=&quot;https://leetcode.com/yfgu0618&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;YFGu0618&lt;/a&gt; for his graph.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="dynamic programming" scheme="https://fudonglai.github.io/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Non-Repeating Longest Substring</title>
    <link href="https://fudonglai.github.io/2018/10/20/Non-Repeating-longest-substring/"/>
    <id>https://fudonglai.github.io/2018/10/20/Non-Repeating-longest-substring/</id>
    <published>2018-10-20T10:24:49.000Z</published>
    <updated>2018-10-26T13:01:00.989Z</updated>
    
    <content type="html"><![CDATA[<p>An ingenuity to use map to solve Substring.</p><a id="more"></a><h3 id="Example"><a href="#Example" class="headerlink" title="Example:"></a>Example:</h3><blockquote><p>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3. </p></blockquote><p>###Solution</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> * Solution (DP, O(n)):</span><br><span class="line"> * </span><br><span class="line"> * Assume L[i] = s[m...i], denotes the longest substring without repeating</span><br><span class="line"> * characters that ends up at s[i], <span class="keyword">and</span> we keep a hashmap <span class="keyword">for</span> every</span><br><span class="line"> * characters between m ... i, <span class="keyword">while</span> storing &lt;character, index&gt; in the</span><br><span class="line"> * hashmap.</span><br><span class="line"> * We know that each character will appear only once.</span><br><span class="line"> </span><br><span class="line"> * Then to find s[i+<span class="number">1</span>]:</span><br><span class="line"> * <span class="number">1</span>) <span class="keyword">if</span> s[i+<span class="number">1</span>] does <span class="keyword">not</span> appear in hashmap</span><br><span class="line"> *    we can just add s[i+<span class="number">1</span>] to hash <span class="built_in">map</span>. <span class="keyword">and</span> L[i+<span class="number">1</span>] = s[m...i+<span class="number">1</span>]</span><br><span class="line"> * <span class="number">2</span>) <span class="keyword">if</span> s[i+<span class="number">1</span>] exists in hashmap, <span class="keyword">and</span> the hashmap value (the index) is k</span><br><span class="line"> *    let m = max(m, k), then L[i+<span class="number">1</span>] = s[m...i+<span class="number">1</span>], we also need to update</span><br><span class="line"> *    entry in hashmap to mark the latest occurency of s[i+<span class="number">1</span>].</span><br><span class="line"> * </span><br><span class="line"> * Since we scan the <span class="built_in">string</span> <span class="keyword">for</span> only once, <span class="keyword">and</span> the <span class="string">'m'</span> will also move from</span><br><span class="line"> * beginning to end <span class="keyword">for</span> at most once. Overall complexity is O(n).</span><br><span class="line"> *</span><br><span class="line"> * If characters are all in ASCII, we could use <span class="built_in">array</span> to mimic hashmap.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> lengthOfLongestSubstring(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dict(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            m = max(m, dict[s[i]] + <span class="number">1</span>);</span><br><span class="line">            dict[s[i]] = i;</span><br><span class="line">            len = max(len, i - m + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Complement"><a href="#Complement" class="headerlink" title="Complement"></a>Complement</h3><p>Now I’ve meet some point of it:</p><ul><li>ASSIC uses one byte to encode, $2^{8}=256$, so we can regard a 256-size vector as a hashtable. The ASSIC of character will be key, its index will be value.</li><li><p>Remeber, every value in <code>dict</code> which not equals $-1$ represents the element’s index clostest to $i$’th element. </p></li><li><p>If all the character is unique, $m$ always equals 0, longest length will increase one by one.</p></li><li>If  encount a character repeates, then we compare $m$ and the index. If $m$ is greater than index, it means the element occured in a substring before, but no big deal for current substring count. If $m$ is less than index, it means the current substring can’t be longer any more, so $m$ will update to the index.</li><li>In other word, every time we update $m$ , we actually find a substring, which is <code>string[m: i]</code>.</li><li>As for varaible <code>len</code>, it compares every loop. Only when current substring <code>i - m + 1</code>longer than before, it will update to a large length.</li></ul><p>I think the partern of solution can have a double pointer expension.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;An ingenuity to use map to solve Substring.&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Substring" scheme="https://fudonglai.github.io/tags/Substring/"/>
    
  </entry>
  
  <entry>
    <title>Think Recursively</title>
    <link href="https://fudonglai.github.io/2018/10/18/Think-Recursively/"/>
    <id>https://fudonglai.github.io/2018/10/18/Think-Recursively/</id>
    <published>2018-10-18T11:12:34.000Z</published>
    <updated>2018-12-23T07:01:16.462Z</updated>
    
    <content type="html"><![CDATA[<h3 id="“Top-down”-Solution"><a href="#“Top-down”-Solution" class="headerlink" title="“Top-down” Solution"></a>“Top-down” Solution</h3><p>When you meet a tree problem, ask yourself two questions: </p><ul><li>Can you determine some parameters to help the node know the answer of itself? </li><li>Can you use these parameters and the value of the node itself to determine what should be the parameters parsing to its children? </li></ul><a id="more"></a><p> If the answers are both <strong>yes</strong>, try to solve this problem using a “top-down” recursion solution.</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> answer;       <span class="comment">// don't forget to initialize answer before call maximum_depth</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">maximum_depth</span><span class="params">(TreeNode* root, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123;</span><br><span class="line">        answer = max(answer, depth);</span><br><span class="line">    &#125;</span><br><span class="line">    maximum_depth(root-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">    maximum_depth(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="“Bottom-up”-Solution"><a href="#“Bottom-up”-Solution" class="headerlink" title="“Bottom-up” Solution"></a>“Bottom-up” Solution</h3><p>Or you can think the problem in this way: </p><p>for a node in a tree, if you know the answer of its children, can you calculate the answer of the node? </p><p>If the answer is yes, solving the problem recursively from bottom up might be a good way.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximum_depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;                                   <span class="comment">// return 0 for null node</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> left_depth = maximum_depth(root.left);</span><br><span class="line"><span class="keyword">int</span> right_depth = maximum_depth(root.right);</span><br><span class="line"><span class="keyword">return</span> Math.max(left_depth, right_depth) + <span class="number">1</span>;<span class="comment">// return depth of the subtree rooted at root</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;“Top-down”-Solution&quot;&gt;&lt;a href=&quot;#“Top-down”-Solution&quot; class=&quot;headerlink&quot; title=&quot;“Top-down” Solution&quot;&gt;&lt;/a&gt;“Top-down” Solution&lt;/h3&gt;&lt;p&gt;When you meet a tree problem, ask yourself two questions: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Can you determine some parameters to help the node know the answer of itself? &lt;/li&gt;
&lt;li&gt;Can you use these parameters and the value of the node itself to determine what should be the parameters parsing to its children? &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://fudonglai.github.io/categories/Algorithm/"/>
    
    
      <category term="Recursion" scheme="https://fudonglai.github.io/tags/Recursion/"/>
    
  </entry>
  
</feed>
